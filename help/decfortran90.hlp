1 f90
 Invokes the DIGITAL Fortran 90 (Fortran 90) compiler.  This command
 can also invoke other software components (such as preprocessors,
 or the ld linker), depending on which files or options are
 specified on the command line.  The f90 command produces object
 code files in DIGITAL UNIX Alpha extended coff format; it is
 described in detail in your DIGITAL Fortran user manual.  (See also
 f90(1).)

 Format:

     f90 [options] filename [options]

 If you specify more than one option or filename, separate each with
 a space.  Some options include keywords.  For more information, see
 Parameters.

 f90 sends its output to "stderr".  Upon program completion, the f90
 driver returns one of the following status values:
     0 - SUCCESS
     1 - FAILURE
     2 - SUBPROCESS_FAILURE (preprocessor, decfort90, or ld)
     3 - SIGNAL

 If the environment variable DECF90 is set, the value is used as the
 name of the compiler to invoke.  If the environment variable TMPDIR
 is set, the value is used as the directory for temporary files.

 If the environment variable DECF90_CC is set, its value is used as
 the name of the CC command to invoke.

 If the environment variable DECF90_INIT is defined, its value has
 to have the form
     [[pre] [:: [post]]

 where the items in "[...]" are optional and can be empty, and where
 "pre" and "post" are strings to be added to the command line.
 "pre" is added to the front of the command line, before any
 characters the user typed; "post" is added to the end of the
 command line.

 Your DIGITAL Fortran kit contains a Help file in text format.  To
 search for information in this file, enter the following command to
 display the file:

    % more /usr/lib/cmplrs/fort90/decfort90.hlp

 To search for a specific item, enter a slash (/) followed by the
 item.  For example, once the Help file is displayed, you can search
 for run-time error message number 138 by entering the following:

    /138
2 Parameters          
 Options

 Indicates either special actions to be performed by the compiler or
 linker, or special properties of input or output files.

 If you specify more than one option, separate each option with a
 space.

 Certain options have the format of "-option keyword", where the
 "keyword" can be abbreviated to its shortest unique prefix.  For
 example, -assume noaccuracy can be abbreviated as -assume noac.

 For more information about command line options, see f90(1).  If
 you are using LSE, you can see f90(1) by entering the following
 command at the LSE prompt:

    LSE> cli man f90

 Filename

 Specifies one (or more) source programs to be compiled.  If you
 specify more than one filename, separate each filename with a
 space.

 The f90 command interprets filename suffixes as follows:

  o  Files with the suffix .f90 are assumed to be free-form source
     files.  Files with the suffix .f, .for, or .FOR are assumed to
     be fixed-form source files.

  o  When the -c flag is specified without the -o flag, an object
     file is created in the current directory that has the basename
     of the source file with the .o suffix.  For example, in source
     file myfile.f, myfile is the basename; so, the object program
     is named myfile.o.

     If the source program is compiled and loaded, the .o file is
     deleted.

  o  Files with the suffix .F are interpreted as Fortran fixed-form
     source programs, which must be processed by the C preprocessor
     (cpp(1)) before being compiled.

  o  Files with the suffix .i are interpreted as Fortran fixed-form
     source programs that have been preprocessed by cpp(1).  They
     are compiled without further preprocessing.

  o  Files with the suffux .i90 are interpreted as Fortran 90
     free-form source programs that have been preprocessed by
     cpp(1).  They are compiled without further preprocessing.


 For each MODULE declaration in a source file, a module information
 named module.mod is created.

 When a source program requires preprocessing by cpp(1), the name of
 the output file generated by the preprocessor consists of the
 basename of the source input file with the appropriate preprocessor
 suffix.  For example:

     m4     myfile.r =>  myfile.p
     efl    myfile.e =>  myfile.f 
     ratfor myfile.r =>  myfile.f
     cpp    myfile.F =>  myfile.i

 Note that if you have myfile.F and myfile.f as distinct files,
 cpp(1) overwrites myfile.f to produce an output file with the same
 name.

 The f90 command defines the following cpp(1) macros to cpp(1):
 LANGUAGE_FORTRAN_90, __LANGUAGE_FORTRAN_90__, LANGUAGE_FORTRAN,
 __LANGUAGE_FORTRAN__, unix, __unix__, __alpha, and __osf__.
2 Options                          
 Indicate either special actions to be performed by the compiler or
 linker, or special properties of input or output files.

 You can override some options specified on the command line by
 using the OPTIONS statement, the AUTOMATIC and STATIC statements,
 and directives (CDEC$) in your Fortran source program.  The options
 specified by the OPTIONS statement affect only the program unit
 where the statement occurs.

 For descriptions of all command line options, see f90(1) by
 entering the following command at the LSE prompt:

    LSE> cli man f90
2 Examples            

 1.  % f90 -V aaa.f bbb.f ccc.f

     This command causes the files aaa.f, bbb.f, and ccc.f to be
     compiled into one temporary object file, which is then passed
     to the ld linker.  The ld linker produces the executable file
     a.out.  The -V option causes the compiler to create the listing
     file aaa.1.

 2.  % f90 -o foo ax.f bx.f cx.f

     This command causes the files ax.f, bx.f, and cx.f to be
     compiled as one program, with the resulting executable file
     foo.

 3.  % f90 -c -O4 ax.f bx.f cx.f

     This command causes the files ax.o, bx.o and cx.o to be
     created.  Inter-procedural optimization is hindered because
     these input files are separately compiled.

 4.  % f90 -c -o foo.o -O4 ax.f bx.f cx.f

     This command causes the files ax.f, bx.f and cx.f to be
     compiled as one program, with the resulting object file foo.o.
     This produces better optimization.

2 Release_Notes

 For DIGITAL Fortran 90 release notes, refer to:

     /usr/lib/cmplrs/fort/relnotes
2 Built-in_Functions
 Built-in functions perform utility operations that are useful in
 communicating with subprograms written in languages other than
 Fortran.

 See also Intrinsics.
3 %LOC   
 %LOC (arg)
 Returns the internal address of a storage item.  The argument can
 be a variable, an expression, or the name of a procedure.  (It must
 not be the name of an internal procedure or statement function.) It
 can be of any data type.  The result is an INTEGER*8 data type.

 In the case of global symbolic constants, %LOC returns the value of
 the constant rather than an address.

 The %LOC built-in function serves the same purpose as the LOC
 intrinsic.
3 %REF   
 %REF (arg)

 Forces an actual argument in a CALL statement or function reference
 to be passed by reference:  the address of the argument is passed
 to the subprogram.  By default, Fortran passes all numeric values
 by reference.
3 %VAL   
 %VAL (arg)

 Forces an actual argument in a CALL statement or function reference
 to be passed by value.  The "arg" is passed as a 64-bit immediate
 value.  If "arg" is integer (or logical) and less than 64 bits in
 size, it is sign-extended to a 64-bit value.

 When a complex "arg" is passed, two 64-bit values (one containing
 the real part, the other containing the imaginary part) are passed
 by immediate value.
3 %DESCR (VMS only)   
 %DESCR (arg)

 Forces an actual argument in a CALL statement or function reference
 to be passed by descriptor:  the address of a descriptor of the
 argument is passed to the subprogram.  By default, Fortran passes
 all character values by descriptor.
2 Character_Sets    
 DIGITAL Fortran supports the following characters:

  o  The Fortran 90 character set, consisting of those ASCII
     characters which can appear in Fortran 90 language syntax.
     This character set is a superset of the FORTRAN 77 character
     set.

  o  Other printable characters, which can appear in comments,
     character constants, Hollerith constants, character string edit
     descriptors, and input/output records.

3 ASCII
 The following table represents the ASCII character set (characters
 with decimal values 0 through 127).  Except for SP and HT, the
 characters with names are nonprintable.

 To determine the hexadecimal value of an ASCII character, combine
 the values in the column (0-7) and the row (0-F) that relate to the
 character.  For example, the value of the character representing
 the equal sign is 3D(hex).





   +------------------------------------------+
   |     0     1     2    3   4   5   6   7   |
   +---+--------------------------------------+
   | 0 | NUL   DLE   SP   0   @   P   `   p   |
   | 1 | SOH   DC1   !    1   A   Q   a   q   |
   | 2 | STX   DC2   "    2   B   R   b   r   |
   | 3 | ETX   DC3   #    3   C   S   c   s   |
   | 4 | EOT   DC4   $    4   D   T   d   t   |
   | 5 | ENQ   NAK   %    5   E   U   e   u   |
   | 6 | ACK   SYN   &    6   F   V   f   v   |
   | 7 | BEL   ETB   '    7   G   W   g   w   |
   | 8 | BS    CAN   (    8   H   X   h   x   |
   | 9 | HT    EM    )    9   I   Y   i   y   |
   | A | LF    SUB   *    :   J   Z   j   z   |
   | B | VT    ESC   +    ;   K   [   k   {   |
   | C | FF    FS    ,    <   L   \   l   |   |
   | D | CR    GS    -    =   M   ]   m   }   |
   | E | SO    RS    .    >   N   ^   n   ~   |
   | F | SI    US    /    ?   O   _   o   DEL |
   +---+--------------------------------------+

 The characters with names are defined as follows:


   NUL   Null                 DC1   Device Control 1(XON)
   SOH   Start of Heading     DC2   Device Control 2
   STX   Start of Text        DC3   Device Control 3(XOFF)
   ETX   End of Text          DC4   Device Control 4
   EOT   End of Transmission  NAK   Negative Acknowledge
   ENQ   Enquiry              SYN   Synchronous Idle
   ACK   Acknowledge          ETB   End of Transmission Block
   BEL   Bell                 CAN   Cancel
   BS    Backspace            EM    End of Medium
   HT    Horizontal Tab       SUB   Substitute
   LF    Line Feed            ESC   Escape
   VT    Vertical Tab         FS    File Separator
   FF    Form Feed            GS    Group Separator
   CR    Carriage Return      RS    Record Separator
   SO    Shift Out            US    Unit Separator
   SI    Shift In             SP    Space
   DLE   Data Link Escape     DEL   Delete

3 DEC_Multinational
 The DEC Multinational Character Set is available on OpenVMS and
 DIGITAL UNIX systems.

 The ASCII character set comprises the first half of the DEC
 Multinational Character Set.  The following table represents the
 second half of the DEC Multinational Character Set (characters with
 decimal values 128 through 255).  These characters cannot be output
 on some older terminals and printers.  Note that the characters
 with names are nonprintable.

 To determine the hexadecimal value of an ASCII character, combine
 the values in the column (8-F) and the row (0-F) that relate to the
 character.  For example, the value of the character representing
 the pound sterling sign is A3(hex).


    +------------------------------------------+
    |     8     9      A   B   C   D   E   F   |
    +---+--------------------------------------+
    | 0 |       DCS        °   À       à       |
    | 1 |       PU1    ¡   ±   Á   Ñ   á   ñ   |
    | 2 |       PU2    ¢   ²   Â   Ò   â   ò   |
    | 3 |       STS    £   ³   Ã   Ó   ã   ó   |
    | 4 | IND   CCH            Ä   Ô   ä   ô   |
    | 5 | NEL   MW     ¥   µ   Å   Õ   å   õ   |
    | 6 | SSA   SPA        ¶   Æ   Ö   æ   ö   |
    | 7 | ESA   EPA    §   ·   Ç   ×   ç   ÷   |
    | 8 | HTS          ¨       È   Ø   è   ø   |
    | 9 | HTJ          ©   ¹   É   Ù   é   ù   |
    | A | VTS          ª   º   Ê   Ú   ê   ú   |
    | B | PLD   CSI    «   »   Ë   Û   ë   û   |
    | C | PLU   ST         ¼   Ì   Ü   ì   ü   |
    | D | RI    OSC        ½   Í   Ý   í   ý   |
    | E | SS2   PM             Î       î       |
    | F | SS3   APC        ¿   Ï   ß   ï       |
    +---+--------------------------------------+

 The characters with names are defined as follows:


   IND   Index            PU1   Private Use 1
   NEL   Next Line        PU2   Private Use 2
   SSA   Start of         STS   Set Transmit State
           Selected Area
   ESA   End of Selected  CCH   Cancel Character
           Area
   HTS   Horizontal Tab   MW    Message Waiting
           Set
   HTJ   Horizontal       SPA   Start of Protected 
           Tab Set with           Area
           Justification
   VTS   Vertical Tab     EPA   End of Protected 
           Set                    Area
   PLD   Partial Line     CSI   Control Sequence 
           Down                   Introducer
   PLU   Partial Line Up  ST    String Terminator
   RI    Reverse Index    OSC   Operating System 
                                  Command
   SS2   Single Shift 2   PM    Privacy Message
   SS3   Single Shift 3   APC   Application
   DCS   Device Control
           String
3 Fortran_90_Standard
 The character set specified by the Fortran 90 Standard consists of
 all uppercase and lowercase letters (A-Z and a-z), the digits 0-9,
 the underscore (_), and the following special characters:

         (blank or space)       :    (colon)
    =    (equal sign)           !    (exclamation point)
    +    (plus sign)            "    (quotation mark)       
    -    (minus sign)           %    (percent sign)  
    *    (asterisk)             &    (ampersand) 
    /    (slash)                ;    (semicolon)
    (    (left parenthesis)     <     (less than)
    )    (right parenthesis)    >     (greater than)
    ,    (comma)                ?     (question mark)
    .    (period)               $    (dollar sign)          
    '    (apostrophe)           
3 DIGITAL_Fortran         
 The DIGITAL Fortran character set includes the entire Fortran 90
 Standard set plus the special character <Tab> (tab).

 All printable characters (those in the range 20(hex) through
 7E(hex), or A1(hex) through FE(hex)) can appear in comments,
 character constants, and Hollerith constants.
3 Printable_Characters
 Printable characters include the tab character (09 hex), those
 ASCII characters with codes in the range 20(hex) through 7E(hex),
 and those characters in the DEC Multinational Extension to the
 ASCII Character Set with codes in the range A1(hex) through
 FE(hex).

 Printable characters that are not in the Fortran 90 character set
 (see CHAR FORTRAN_90 in online Help) can only appear in comments,
 character constants, Hollerith constants, character string edit
 descriptors, and input/output records.
2 Compatibility_Features
 DIGITAL Fortran provides the following language features to
 facilitate compatibility with other versions of Fortran:

  o  The DEFINE FILE, ENCODE, DECODE, and FIND statements

  o  An alternative syntax for the PARAMETER statement

  o  The VIRTUAL statement

  o  The AND, OR, XOR, IMAG, LSHIFT, and RSHIFT intrinsic functions

  o  An alternative syntax for octal and hexadecimal constants

  o  An alternative syntax for a record specifier

  o  An alternative syntax for the DELETE statement

  o  An alternative form for namelist external records

  o  Record structures

  o  DIGITAL Fortran pointers


 These language features are particularly useful in transporting
 older Fortran programs to systems on Alpha processors.  However,
 you should avoid using them in new programs on these systems, and
 in new programs for which portability to other Fortran 90
 implementations is important.
3 DEFINE_FILE           
 The DEFINE FILE statement establishes the size and structure of
 files with relative organization and associates them with a logical
 unit number.  The DEFINE FILE statement is comparable to the OPEN
 statement (in situations where you can use the OPEN statement, it
 is the preferable mechanism for creating and opening files).
 Statement format:

    DEFINE FILE u(m, n, U, asv) [,u(m, n, U, asv)]...

    u    Is an integer constant or variable that specifies the 
         logical unit number.

    m    Is an integer constant or variable that specifies the 
         number of records in the file.

    n    Is an integer constant or variable that specifies the 
         length of each record in 16-bit words (2 bytes).

    U    Specifies that the file is unformatted (binary); this 
         is the only acceptable entry in this position.

    asv  Is an integer variable, called the associated variable 
         of the file.  At the end of each direct access I/O 
         operation, the record number of the next higher numbered 
         record in the file is assigned to "asv"; "asv" must not 
         be a dummy argument.

 The DEFINE FILE statement specifies that a file containing "m"
 fixed-length records, each composed of n 16-bit words, exists (or
 is to exist) on the specified logical unit.  The records in the
 file are numbered sequentially from 1 through "m".

 A DEFINE FILE statement must be executed before the first direct
 access I/O statement referring to the specified file, even though
 the DEFINE FILE statement does not itself open the file.  The file
 is actually opened when the first direct access I/O statement for
 the unit is executed.

 If this I/O statement is a WRITE statement, a new relative
 organization file is created.  If it is a READ or FIND statement,
 an existing file is opened, unless the specified file does not
 exist.  If a file does not exist, an error occurs.
3 DELETE              
 In DIGITAL Fortran, you can specify the following form of the
 DELETE statement when deleting records from a relative file:

   DELETE (u'r [,ERR=s] [,IOSTAT=ios])

   u   Is the number of the logical unit containing the 
       record to be deleted.

   r   Is the positional number of the record to be deleted.

   s   Is the label of an executable statement that receives 
       control if an error condition occurs.

   ios Is a scalar default integer variable that is defined 
       as a positive integer if an error occurs and zero if 
       no error occurs.

 This form deletes the direct access record specified by r.
3 ENCODE_and_DECODE     
 The ENCODE and DECODE statements transfer data between variables or
 arrays in internal storage.  The ENCODE statement translates data
 from internal (binary) form to character form.  Inversely, the
 DECODE statement translates data from character to internal form.
 These statements are comparable to using internal files in
 formatted sequential WRITE and READ statements, respectively.
 Statement format:

    ENCODE (c,f,b [,IOSTAT=ios] [,ERR=s]) [list]
    DECODE (c,f,b [,IOSTAT=ios] [,ERR=s]) [list]

    c      Is an integer expression.  In the ENCODE statement, 
           "c" is the number of characters (in bytes) to be 
           translated to character form.  In the DECODE statement, 
           "c" is the number of characters to be translated to 
           internal form.
  
    f      Is a format identifier.  An error occurs if more than 
           one record is specified.

    b      Is a scalar or array reference. If b is an array 
           reference, its elements are processed in the 
           order of subscript progression. The data type of "b"
           determines the number of characters that ENCODE or
           DECODE can process.

           In the ENCODE statement, "b" receives the characters 
           after translation to external form.  If less than "c" 
           characters are received, the remaining character
           positions are filled with blank characters. 

           In the DECODE statement, "b" contains the characters 
           to be translated to internal form.

    ios    Is a scalar default integer variable that is defined 
           as a positive integer if an error occurs, and zero 
           if no error occurs.

    s      Is the label of an executable statement.

    list   Is an I/O list.  

           In the ENCODE statement, the "list" contains the data 
           to be translated to character form.  In the DECODE 
           statement, the "list" receives the data after 
           translation to internal form.

           The interaction between the format specifier and the 
           I/O list is the same as for a formatted I/O statement.
3 FIND                    
 The FIND statement positions a direct access file at a particular
 record and sets the associated variable of the file to that record
 number.  It is comparable to a direct access READ statement with no
 I/O list, and can open an existing file.  No data transfer takes
 place.  Statement format:

    FIND (u'r [,ERR=s] [,IOSTAT=ios])
    FIND ([UNIT=]u, REC=r [,ERR=s] [,IOSTAT=ios])

    u     Is a logical unit number.  It must refer to a
          relative organization file.

    r     Is the direct access record number.  It cannot 
          be less than one or greater than the number of 
          records defined for the file.

    s     Is the label of the executable statement that 
          receives control if an error occurs.

    ios   Is an integer variable or integer array element 
          that is defined as a positive integer if an error 
          occurs, and as a zero if no error occurs.
3 Intrinsic_Functions    
 DIGITAL Fortran allows certain intrinsic functions for
 compatibility with FORTRAN for RISC.  The following list shows
 these functions and their equivalents:

    Function    Equivalent Function
    --------    -------------------
    AND         IAND 
    OR          IOR
    XOR         IEOR
    LSHIFT      ISHFT with a positive second argument
    RSHIFT      ISHFT with a negative second argument
3 Namelist_Record
 You can use the following form for an external record:

   $group-name object = value [object = value]...$[END]


   group-name  Is the name of the group containing the objects 
               to be given values. The name must have been 
               previously defined in a NAMELIST statement in 
               the scoping unit.

   object      Is the name (or subobject designator) of an 
               entity defined in the NAMELIST declaration of 
               the group name. The object name must not contain 
               embedded blanks, but it can be preceded or 
               followed by blanks.

   value       Is a null value, a constant (or list of constants), 
               a repetition of constants in the form r*c, or a 
               repetition of null values in the form r*.

 If more than one object=value or more than one value is specified,
 they must be separated by value separators.

 A value separator is any number of blanks, or a comma or slash,
 preceded or followed by any number of blanks.

 Comments (beginning with !  only) can appear anywhere in namelist
 input.  The comment extends to the end of the source line.
3 Octal_Hex_Syntax      
 In DIGITAL Fortran, you can use the following alternative syntax
 for octal and hexadecimal constants:

                 Alternative Syntax   Equivalent
                 ------------------   ----------
    Octal        '0..7'O              O'0..7'
    Hexadecimal  '0..F'X              Z'0..F'

 In the above syntax forms, you can use a quotation mark(") in place
 of an apostrophe (').
3 PARAMETER              
 This statement is similar to the one discussed in Help topic:
 Statements PARAMETER; they both assign a symbolic name to a
 constant.  However, this PARAMETER statement differs from the other
 one in the following two ways:  its list is not bounded with
 parentheses; and the form of the constant, rather than implicit or
 explicit typing of the symbolic name, determines the data type of
 the variable.  Statement format:

    PARAMETER p=c [,p=c]...

    p  Is a symbolic name.

    c  Is a constant, the symbolic name of a constant, or a 
       compile-time constant expression.
3 Record_Specifier_Syntax
 In DIGITAL Fortran, you can specify the following form for a record
 specifier:

    'r

    r  Is a numeric expression with a value that represents 
       the position of the record to be accessed using direct 
       access I/O.  The value must be greater than or equal to 1, 
       and less than or equal to the maximum number of records 
       allowed in the file. If necessary, a record number is 
       converted to integer data type before being used.
3 Record_Structures
 A record is a named data entity, consisting of one or more fields,
 which you can use when you need to declare and operate on
 multi-field data structures in your programs.

 To create a record, you must have a structure declaration (to
 describe the fields in the record) and a RECORD statement to
 establish the record in memory.
4 Examples            
 Structure APPOINTMENT:

    Structure /APPOINTMENT/       
      RECORD /DATE/             APP_DATE
      STRUCTURE /TIME/          APP_TIME (2)
          LOGICAL*1             HOUR, MINUTE
      END STRUCTURE
      CHARACTER*20              APP_MEMO (4)
      LOGICAL*1                 APP_FLAG
    END STRUCTURE

 The following statement results in the creation of both a variable
 named NEXT_APP and a 10-element array named APP_list.  Both the
 variable and each element of the array have the form of the
 structure APPOINTMENT.

    RECORD /APPOINTMENT/ NEXT_APP,APP_list(10)

 The following examples illustrate aggregate and scalar field
 references.

 Aggregate:

   NEXT_APP                ! the record NEXT_APP
   NEXT_APP.APP_TIME(1)    ! an array field of the variable
                           ! NEXT_APP
   APP_list(3).APP_DATE    ! a 4-byte array field in the record array
                           ! APP_list(3)

 Scalar:

   NEXT_APP.APP_FLAG       ! a LOGICAL field of the record
                           ! NEXT_APP

   NEXT_APP.APP_MEMO(1)(1:1)
                           ! The first character of APP_MEMO(1),
                           ! a character*20 field of the record
                           ! NEXT_APP
4 Field_References    
 Fields within a record may be accessed collectively or
 individually.  Record references are either qualified or
 unqualified.

 A qualified reference refers to a typed data item and can be used
 wherever an ordinary variable is allowed.  Type conversion rules
 are the same as for variables.  Its form is:

    rname[.cfname...cfname].afname

 Unqualified references refer to a record structure or substructure
 and can be used (in most cases) like arrays, for example:

    rname[.cfname...cfname]

    rname    Is the name used in the RECORD statement to 
             identify a record.

    cfname   Is a substructure field name within the record 
             identified by record-name.

    afname   Is the name of a typed data item within a structure 
             declaration.
4 Aggregate_Reference  
 An aggregate reference resolves into a reference to a structured
 data item (a record structure or substructure).  For example:

 Data Declarations:

    STRUCTURE /STRA/
        INTEGER  INTFLD, INTFLDARY (10)
    END STRUCTURE
      . . .
    STRUCTURE /STRB/
        CHARACTER*20  CHARFLD
        INTEGER  INTFLD, INTFLDARY (10)
        STRUCTURE STRUCFLD
            COMPLEX  CPXFLD, CPXFLDARY (10)
        END STRUCTURE
        RECORD  /STRA/  RECFLD, RECFLDARY (10)
    END STRUCTURE
      . . .
    RECORD  /STRB/  REC, RECARY (10)

 Reference Examples:

    REC --- A record name
    RECARY(1) --- A record array reference
    REC.RECFLD --- A reference to a substructure
    REC.RECFLDARY(1) --- A reference to a substructure array element
    RECARY(1).RECFLD --- A reference to a substructure in a record
      array element
    RECARY(1).RECFLDARY(1) --- A reference to a substructure array
      element in a record array
3 VIRTUAL                
 The VIRTUAL statement is included for compatibility with PDP-11
 FORTRAN.  It has the same form and effect as the DIMENSION
 statement (see Help Topic:  Statements DIMENSION).
3 DIGITAL_Fortran_POINTER             
 This POINTER statement is different from the Fortran 90 POINTER
 statement.  This POINTER statement establishes pairs of variables
 and pointers, in which each pointer contains the address of its
 paired variable.  Statement format:

    POINTER ((pointer,pointee) [,(pointer,pointee)]...

    pointer  Is a variable whose value is used as the 
             address of the pointee.

    pointee  Is a variable, array, array declarator, record
             structure, record array, or record array 
             specification.

 The following are rules and behavior for the "pointer" argument:

  o  Two pointers can have the same value, so pointer aliasing is
     allowed.

  o  When used directly, a pointer is treated like an integer
     variable.  A pointer occupies two numeric storage units, so it
     is a 64-bit quantity (INTEGER*8).

  o  A pointer cannot be a pointee.

  o  A pointer cannot appear in an ASSIGN statement and cannot have
     the following attributes:

        ALLOCATABLE  PARAMETER
        EXTERNAL     POINTER
        INTRINSIC    TARGET

     A pointer can appear in a DATA statement with integer literals
     only.

  o  Integers can be converted to pointers, so you can point to
     absolute memory locations.

  o  A pointer variable cannot be declared to have any other data
     type.

  o  A pointer cannot be a function return value.

  o  You can give values to pointers by doing the following:

      -  Retrieve addresses by using the LOC intrinsic function (or
         %LOC built-in function)

      -  Allocate storage for an object by using the MALLOC
         intrinsic function (or by using malloc(3f) on DIGITAL UNIX
         systems or LIB$GET_VM on OpenVMS systems)

         For example:

            Using %LOC:                   Using MALLOC:

            integer i(10)                 integer i(10)
            integer i1 (10) /10*10/       pointer (p,i)
            pointer (p,i)                 p = malloc (40)
            p = %loc (i1)                 i(2) = i(2) + 1
            i(2) = i(2) + 1

            Using LIB$GET_VM:

            INTEGER I(10)
            INTEGER LIB$GET_VM, STATUS
            POINTER (P,I)
            STATUS = LIB$GET_VM(P,40)
            IF (.NOT. STATUS) CALL EXIT(STATUS)
            I(2) = I(2) + 1

         The value in a pointer is used as the pointee's base
         address.



 The following are rules and behavior for the "pointee" argument:

  o  A pointee is not allocated any storage.  References to a
     pointee look to the current contents of its associated pointer
     to find the pointee's base address.

  o  A pointee can appear in only one POINTER statement.

  o  A pointee array can have fixed, adjustable, or assumed
     dimensions.

  o  A pointee cannot appear in a COMMON, DATA, EQUIVALENCE, or
     NAMELIST statement and cannot have the following attributes:

        ALLOCATABLE    POINTER
        AUTOMATIC      SAVE
        INTENT         STATIC
        OPTIONAL       TARGET
        PARAMETER 

  o  A pointee cannot be a dummy argument.

  o  A pointee cannot be a function return value.

  o  A pointee cannot be a record field or an array element.

  o  A pointee cannot be zero-sized.

  o  A pointee cannot be an automatic object.

  o  A pointee cannot be the name of a generic interface block.

  o  If a pointee is of derived type, it must be of sequence type.

2 Data              
 Each constant, variable, array, expression, or function reference
 in a Fortran statement represents typed data.  The data type of
 these items can be inherent in their constructions, implied by
 convention, or explicitly declared.

 Each data type has a name, a set of associated values, a way to
 denote the values, and operations to manipulate and interpret these
 values.

 There are two categories of data types:  intrinsic and derived.
 The names of the intrinsic data types are predefined and are always
 accessible.  Derived data types are user-defined data types that
 are made up of intrinsic or derived data types.
3 Arrays               
 An array is a set of scalar elements that have the same type and
 kind type parameters.  Any object that is declared with an array
 specification is an array.  Arrays can be declared with a type
 declaration statement, a DIMENSION statement, or a COMMON
 statement.

 An array can be referenced by element (using subscripts), by
 section (using a section subscript list), or as a whole.

 A section subscript list consists of subscripts, subscript
 triplets, or vector subscripts.  At least one subscript in the list
 must be a subscript triplet or vector subscript.

 When an array name without any subscripts appears in an intrinsic
 operation (for example, addition), the operation applies to the
 whole array (all elements in the array).

 An array has the following properties:

  o  Data type

     An array can have any intrinsic or derived type.  The data type
     of an array is either specified in a type declaration
     statement, or implied by the first letter of its name.  All
     elements of the array have the same type and kind type
     parameters.  If a value assigned to an individual array element
     is not the same as the type of the array, it is converted to
     the array's type.

  o  Rank

     The rank of an array is the number of dimensions in the array.
     An array can have up to seven dimensions.  A rank-one array
     represents a column of data (a vector), a rank-two array
     represents a table of data arranged in columns and rows (a
     matrix), a rank-three array represents a table of data on
     multiple pages (or planes), and so forth.

  o  Bounds

     Arrays have a lower and upper bound in each dimension.  These
     bounds determine the range of values that can be used as
     subscripts for the dimension.  The value of either bound can be
     positive, negative, or zero.

     The bounds of a dimension are defined in an array
     specification.

  o  Size

     The size of an array is the total number of elements in the
     array (the product of the array's extents).

     The extent of a dimension is the number of elements in that
     dimension.  It is determined as follows:  upper bound - lower
     bound + 1.  If the value of any of an array's extents is zero,
     the array has a size of zero.

  o  Shape

     The shape of an array is determined by its rank and extents,
     and can be represented as a rank-one array (vector) where each
     element is the extent of the corresponding dimension.

     Two arrays with the same shape are said to be conformable.  A
     scalar is conformable to an array of any shape.


 The name and rank of an array are constant and must be specified
 when the array is declared.  The extent of each dimension can be
 constant, but does not need to be.  The extents can vary during
 program execution if the array is a dummy argument array, an
 automatic array, an array pointer, or an allocatable array.

 A whole array is referenced by the array name.  Individual elements
 in a named array are referenced by a scalar subscript or list of
 scalar subscripts (if there is more than one dimension).  A section
 of a named array is referenced by a section subscript.

 Consider the following array declaration:

   INTEGER L(2:11,3)

 The properties of array L are as follows:

   Data type:   INTEGER
   Rank:        2 (two dimensions)
   Bounds:      First dimension: 2 to 11
                Second dimension: 1 to 3
   Size:        30 (the product of the extents: 10 x 3)
   Shape:       10 by 3 (a vector of the extents (10,3))

 The following example shows other valid ways to declare this array:

   DIMENSION L(2:11,3)
   INTEGER, DIMENSION(2:11,3) :: L
   COMMON L(2:11,3)

 The following example shows references to array elements, array
 sections, and a whole array:

   REAL B(10)      ! Declares a rank-one array with 10 elements

   INTEGER C(5,8)  ! Declares a rank-two array with 5 elements 
                   !   in dimension one and 8 elements in 
                   !   dimension two
   ...
   B(3) = 5.0      ! Reference to an array element 
   B(2:5) = 1.0    ! Reference to an array section consisting of
                   !   elements: B(2), B(3), B(4), B(5)
   ...
   C(4,8) = I      ! Reference to an array element 
   C(1:3,3:4) = J  ! Reference to an array section consisting of
                   !   elements:  C(1,3) C(1,4)
                   !              C(2,3) C(2,4)
                   !              C(3,3) C(3,4)
   B = 99          ! Reference to a whole array consisting of
                   !   elements: B(1), B(2), B(3), B(4), B(5),
                   !   B(6), B(7), B(8), B(9), and B(10)
4 Declarators
 An array specification (or array declarator) declares the shape of
 an array.  It takes the following form:

   (array-spec)

   array-spec   Is one of the following array specifications:

                Explicit-shape 
                Assumed-shape  
                Assumed-size   
                Deferred-shape 

 The array specification is appended to the name of the array when
 the array is declared.

 The following examples show different forms of array
 specifications:

 SUBROUTINE SUB(N, C, D, Z)
   REAL, DIMENSION(N, 15) :: IARRY  ! An explicit-shape array 
   REAL C(:), D(0:)                 ! An assumed-shape array
   REAL, POINTER :: B(:,:)          ! A deferred-shape array pointer 
   REAL :: Z(N,*)                   ! An assumed-size array

   REAL, ALLOCATABLE, DIMENSION(:) :: K  ! A deferred-shape 
                                         !    allocatable array

5 Explicit_Shape
 An explicit-shape array is declared with explicit values for the
 bounds in each dimension of the array.  An explicit-shape
 specification takes the following form:

    [lower-bound:] upper-bound [,[lower-bound:] upper-bound ]...

 The lower bound (if present) and the upper bound are specification
 expressions that have a positive, negative, or zero value.  If
 necessary, the bound value is converted to integer type.

 If the lower bound is not specified, it is assumed to be 1.

 The bounds can be specified as constant or nonconstant expressions,
 as follows:

  o  If the bounds are constant expressions, the subscript range of
     the array in a dimension is the set of integer values between
     and including the lower and upper bounds.  If the lower bound
     is greater than the upper bound, the range is empty, the extent
     in that dimension is zero, and the array has a size of zero.

  o  If the bounds are nonconstant expressions, the array must be
     declared in a procedure.  The bounds can have different values
     each time the procedure is executed, since they are determined
     when the procedure is entered.

  o  If the bounds are nonconstant expressions, they can have
     different values each time the procedure in which the array is
     declared is executed, since the bounds are determined when the
     procedure is entered.

     The bounds are not affected by any redefinition or undefinition
     of the specification variables that occurs while the procedure
     is executing.

     The following explicit-shape arrays can specify nonconstant
     bounds:

        - An automatic array (the array is a local 
             variable)
        - An adjustable array (the array is a dummy 
             argument to a subprogram)


 The following are examples of explicit-shape specifications:

   INTEGER I(3:8, -2:5) ! Rank-two array; range of dimension one is
   ...                  !  3 to 8, range of dimension two is -2 to 5
   SUBROUTINE SUB(A, B, C)
     INTEGER :: B, C
     REAL, DIMENSION(B:C) :: A  ! Rank-one array; range is B to C
6 Automatic_Arrays
 An automatic array is an explicit-shape array that is a local
 variable.  Automatic arrays are only allowed in function and
 subroutine subprograms, and are declared in the specification part
 of the subprogram.  At least one bound of an automatic array must
 be a nonconstant specification expression.  The bounds are
 determined when the subprogram is called.

 The following example shows automatic arrays:

   SUBROUTINE SUB1 (A, B)
     INTEGER A, B, LOWER
     COMMON /BOUND/ LOWER
     ...
     INTEGER AUTO_ARRAY1(B)
     ...
     INTEGER AUTO_ARRAY2(LOWER:B)
     ...
     INTEGER AUTO_ARRAY3(20, B*A/2)
   END SUBROUTINE
6 Adjustable_Arrays
 An adjustable array is an explicit-shape array that is a dummy
 argument to a subprogram.  At least one bound of an adjustable
 array must be a nonconstant specification expression.  The bounds
 are determined when the subprogram is called.

 The array specification can contain integer variables that are
 either dummy arguments or variables in a common block.

 When the subprogram is entered, each dummy argument specified in
 the bounds must be associated with an actual argument.  If the
 specification includes a variable in a common block, it must have a
 defined value.  The array specification is evaluated using the
 values of the actual arguments, as well as any constants or common
 block variables that appear in the specification.

 The size of the adjustable array must be less than or equal to the
 size of the array that is its corresponding actual argument.

 To avoid possible errors in subscript evaluation, make sure that
 the bounds expressions used to declare multidimensional adjustable
 arrays match the bounds as declared by the caller.

 In the following example, the function computes the sum of the
 elements of a rank-two array.  Notice how the dummy arguments M and
 N control the iteration:

     FUNCTION MY_SUM(A, M, N)
       DIMENSION A(M, N)
       SUMX = 0.0
       DO J = 1, N
         DO I = 1, M
           SUMX = SUMX + A(I, J)
         END DO
       END DO
       MY_SUM = SUMX
     END FUNCTION

 The following are examples of calls on SUM:

   DIMENSION A1(10,35), A2(3,56)
   SUM1 = MY_SUM(A1,10,35)
   SUM2 = MY_SUM(A2,3,56)
5 Assumed_Shape
 An assumed-shape array is a dummy argument array that assumes the
 shape of its associated actual argument array.  An assumed-shape
 specification takes the following form:

    [lower-bound]: [,[lower-bound]:] ...

 The lower bound is a specification expression.  If the lower bound
 is not specified, it is assumed to be 1.

 The rank of the array is the number of colons (:) specified.

 The value of the upper bound is the extent of the corresponding
 dimension of the associated actual argument array + lower-bound -
 1.

 The following is an example of an assumed-shape specification:

   INTERFACE
     SUBROUTINE SUB(M)
       INTEGER M(:, 1:, 5:)
     END SUBROUTINE
   END INTERFACE
   INTEGER L(20, 5:25, 10)
   CALL SUB(L)
   
   SUBROUTINE SUB(M)
     INTEGER M(:, 1:, 5:)
   END SUBROUTINE

 Array M has the same extents as array L, but array M has bounds
 (1:20, 1:21, 5:14).

 Note that an explicit interface is required when calling a routine
 that expects an assumed-shape or pointer array.
5 Assumed_Size
 An assumed-size array is a dummy argument array that assumes the
 size (only) of its associated actual argument array; the rank and
 extents can differ for the actual and dummy arrays.  An
 assumed-size specification takes the following form:

    [exp-shape-spec,] [exp-shape-spec,]... [lower-bound:] *

 The exp-shape-spec is an explicit-shape specification (see DATA
 ARRAY DECL EXPL in online Help).

 The lower bound and upper bound are specification expressions that
 have a positive, negative, or zero value.  If necessary, the bound
 value is converted to integer type.  If a lower bound is not
 specified, it is assumed to be 1.

 The asterisk (*) represents the upper bound of the last dimension.

 The rank of the array is the number of explicit-shape
 specifications plus 1.

 The size of the array is assumed from the actual argument
 associated with the assumed-size dummy array as follows:

  o  If the actual argument is an array of type other than default
     character, the size of the dummy array is the size of the
     actual array.

  o  If the actual argument is an array element of type other than
     default character, the size of the dummy array is a + 1 - s,
     where "s" is the subscript value and "a" is the size of the
     actual array.

  o  If the actual argument is a default character array, array
     element, or array element substring, and it begins at character
     storage unit b of an array with n character storage units, the
     size of the dummy array is as follows:

       MAX(INT((n + 1 - b) / y), 0)

     The "y" is the length of an element of the dummy array.


 An assumed-size array can only be used as a whole array reference
 in the following cases:

  o  When it is an actual argument in a procedure reference that
     does not require the shape

  o  In the intrinsic function LBOUND


 Because the actual size of an assumed-size array is unknown, an
 assumed-size array cannot be used as any of the following in an I/O
 statement:

  o  An array name in the I/O list

  o  A unit identifier for an internal file

  o  A run-time format specifier


 The following is an example of an assumed-size specification:

   SUBROUTINE SUB(A, N)
     REAL A, N
     DIMENSION A(1:N, *)
     ...
5 Deferred_Shape
 A deferred-shape array is an array pointer or an allocatable array.

 The array specification contains a colon (:) for each dimension of
 the array.  No bounds are specified.  The bounds (and shape) of
 allocatable arrays and array pointers are determined when space is
 allocated for the array during program execution.

 An array pointer is an array declared with the POINTER attribute.
 Its bounds and shape are determined when it is associated with a
 target by pointer assignment, or when the pointer is allocated by
 execution of an ALLOCATE statement.

 In pointer assignment, the lower bound of each dimension of the
 array pointer is the result of the LBOUND intrinsic function
 applied to the corresponding dimension of the target.  The upper
 bound of each dimension is the result of the UBOUND intrinsic
 function applied to the corresponding dimension of the target.

 A pointer dummy argument can be associated only with a pointer
 actual argument.  An actual argument that is a pointer can be
 associated with a nonpointer dummy argument.

 A function result can be declared to have the pointer attribute.

 An allocatable array is declared with the ALLOCATABLE attribute.
 Its bounds and shape are determined when the array is allocated by
 execution of an ALLOCATE statement.

 The following are examples of deferred-shape specifications:

   REAL, ALLOCATABLE :: A(:,:)       ! Allocatable array
   REAL, POINTER :: C(:), D (:,:,:)  ! Array pointers
4 Whole_Arrays
 A whole array is referenced by the name of the array (without any
 subscripts).  It can be a named constant or a variable.

 If a whole array appears in a nonexecutable statement, the
 statement applies to the entire array.  For example:

   INTEGER, DIMENSION(2:11,3) :: L   ! Specifies the type and 
                                     !    dimensions of array L

 If a whole array appears in an executable statement, the statement
 applies to all of the elements in the array.  For example:

   L = 10             ! The value 10 is assigned to all the
                      !   elements in array L

   WRITE *, L         ! Prints all the elements in array L
4 Subscripts    
 Arrays can be referenced by individual elements or by a range of
 elements (array sections).  A subscript list (appended to the array
 name) indicates which array element or array section is being
 referenced.

 In the subscript list for an array section, at least one of the
 subscripts must be a subscript triplet or vector subscript.

 DIGITAL Fortran permits intrinsic noninteger expressions for
 subscripts, but they are converted to integers before use (any
 fractional parts are truncated).
4 Elements
 An array element is one of the scalar data items that make up an
 array.  A subscript list (appended to the array or array component)
 determines which element is being referred to.  A reference to an
 array element takes the following form:

   array [(s-list)]

     array   Is the name of an array.

     s-list  Is a list of one or more subscripts. The 
             number of subscripts must equal the rank of 
             the array.
             
             Each subscript must be a scalar numeric 
             expression with a value that is within the 
             bounds of its dimension.

 Each array element inherits the type, kind type parameter, and
 certain attributes (INTENT, PARAMETER, and TARGET) of the parent
 array.  An array element cannot inherit the POINTER attribute.

 If an array element is of type character, it can be followed by a
 substring range in parentheses; for example:

   ARRAY_D(1,2) (1:3)    ! elements are substrings of length 3

 However, by convention, such an object is considered to be a
 substring rather than an array element.

 The following are some valid array element references for an array
 declared as REAL B(10,20):  B(1,3), B(10,10), and B(5,8).

 For information on arrays as structure components, see DATA DERIVED
 COMP in online Help.
5 Order_of_Elements
 The elements of an array form a sequence known as the array element
 order.  The position of an element in this sequence is its
 subscript order value.

 The elements of an array are stored as a linear sequence of values.
 A one-dimensional array is stored with its first element in the
 first storage location and its last element in the last storage
 location of the sequence.  A multidimensional array is stored so
 that the leftmost subscripts vary most rapidly.  This is called the
 order of subscript progression.

 In an array section, the subscript order of the elements is their
 order within the section itself.  For example, if an array is
 declared as B(20), the section B(4:19:4) consists of elements B(4),
 B(8), B(12), and B(16).  The subscript order value of B(4) in the
 array section is 1; the subscript order value of B(12) in the
 section is 3.
4 Sections
 An array section is a portion of an array that is an array itself.
 It is an array subobject.  A section subscript list (appended to
 the array or array component) determines which portion is being
 referred to.  A reference to an array section takes the following
 form:

    array [(sect-s-list)] [(substring-range)]

    array            Is the name of an array.

    sect-s-list      Is a list of one or more section 
                     subscripts (subscripts, subscript 
                     triplets, or vector subscripts) 
                     indicating a set of elements along 
                     a particular dimension.

                     At least one of the items in the section 
                     subscript list must be a subscript 
                     triplet or vector subscript. Each 
                     subscript and subscript triplet must be 
                     a scalar numeric expression. Each vector 
                     subscript must be a rank-one integer 
                     expression.

    substring-range  Is a substring range in the form 
                     [expr]:[expr].  Each expression specified 
                     must be a scalar numeric expression.

                     The array (or array component) preceding 
                     the substring range must be of type character.

 If no section subscript list is specified, the rank and shape of
 the array section is the same as the parent array.

 Otherwise, the rank of the array section is the number of vector
 subscripts and subscript triplets that appear in the list.  Its
 shape is a rank-one array where each element is the number of
 integer values in the sequence indicated by the corresponding
 subscript triplet or vector subscript.

 If any of these sequences is empty, the array section has a size of
 zero.  The subscript order of the elements of an array section is
 that of the array object that the array section represents.

 Each array section inherits the type, kind type parameter, and
 certain attributes (INTENT, PARAMETER, and TARGET) of the parent
 array.  An array section cannot inherit the POINTER attribute.

 The following shows valid references to array sections:

   REAL, DIMENSION(20) :: B
   ...
   PRINT *, B(2:20:5)  ! the section consists of elements 
                       !     B(2), B(7), B(12), and B(17)
   K = (/3, 1, 4/)   

   B(K) = 0.0  ! section B(K) is a rank-one array with 
               ! shape (3) and size 3. (0.0 is assigned to 
               ! B(1), B(3), and B(4).)

 Consider the following declaration:

   CHARACTER(LEN=15) C(10,10)

 An array section referenced as C(:,:)(1:3) is an array of shape
 (10,10) whose elements are substrings of length 3 of the
 corresponding elements of C.
5 Triplets
 A subscript triplet consists of three parts:  the first two parts
 designate a range of subscript values and the third part designates
 the increment (stride) between each value.  It takes the following
 form:

   [subscript-1] : [subscript-2] [:stride]

   subscript-1   Is a scalar numeric expression representing 
                 the first value in the subscript sequence.
                 If omitted, the declared lower bound of the 
                 dimension is used.

   subscript-2   Is a scalar numeric expression representing 
                 the last value in the subscript sequence.
                 If omitted, the declared upper bound of the 
                 dimension is used.

                 When indicating sections of an assumed-size 
                 array, this subscript must be specified.

   stride        Is a scalar numeric expression representing 
                 the increment between successive subscripts 
                 in the sequence.  It must have a nonzero value.
                 If it is omitted, it is assumed to be 1.

 The stride has the following effects:

  o  If the stride is positive, the subscript range starts with the
     first subscript and is incremented by the value of the stride,
     until the largest value less than or equal to the second
     subscript is attained.

     For example, if an array has been declared as B(6,3,2), the
     array section specified as B(2:4,1:2,2) is a rank-two array
     with shape (3,2) and size 6.  It consists of the following six
     elements:

         B(2,1,2)   B(2,2,2)
         B(3,1,2)   B(3,2,2)
         B(4,1,2)   B(4,2,2)

     If the first subscript is greater than the second subscript,
     the range is empty.

  o  If the stride is negative, the subscript range starts with the
     value of the first subscript and is decremented by the absolute
     value of the stride, until the smallest value greater than or
     equal to the second subscript is attained.

     For example, if an array has been declared as A(15), the array
     section specified as A(10:3:-2) is a rank-one array with shape
     (4) and size 4.  It consists of the following four elements:

         A(10)
         A(8)
         A(6)
         A(4)

     If the second subscript is greater than the first subscript,
     the range is empty.


 If a range specified by the stride is empty, the array section has
 a size of zero.

 A subscript in a subscript triplet need not be within the declared
 bounds for that dimension if all values used to select the array
 elements are within the declared bounds.  For example, if an array
 has been declared as A(15), the array section specified as
 A(4:16:10) is valid.  The section is a rank-one array with shape
 (2) and size 2.  It consists of elements A(4) and A(14).

 If the subscript triplet does not specify bounds or stride, but
 only a colon (:), the entire declared range for the dimension is
 used.
5 Vector_Subscripts
 A vector subscript is a rank-one array of integer values (within
 the declared bounds for the dimension).  It is used to select a
 sequence of elements from a parent array.  The sequence does not
 have to be in order, and it can contain duplicate values.

 For example, A is a rank-two array of shape (4,6).  B and C are
 rank-one arrays of shape (2) and (3), respectively, with the
 following values:

   B = (/1,4/)
   C = (/2,1,1/)         ! Will result in a many-one 
                         !   array section

 Array section A(3,B) consists of elements A(3,1) and A(3,4).  Array
 section A(C,1) consists of elements A(2,1), A(1,1), and A(1,1).
 Array section A(B,C) consists of the following elements:

   A(1,2)   A(1,1)   A(1,1)
   A(4,2)   A(4,1)   A(4,1)

 An array section with a vector subscript that has two or more
 elements with the same value is called a many-one array section.  A
 many-one section must not appear on the left of the equals sign in
 an assignment statement, or as an input item in a READ statement.

 The following assignments to C also show examples of vector
 subscripts:

   INTEGER A(2), B(2), C(2)
   ...
   B    = (/1,2/)
   C(B) = A(B)
   C    = A((/1,2/))        

 An array section with a vector subscript must not be any of the
 following:

  o  An internal file

  o  An actual argument associated with a dummy array that is
     defined or redefined (if the INTENT attribute is specified, it
     must be INTENT(IN))

  o  The target in a pointer assignment statement


 If the sequence specified by the vector subscript is empty, the
 array section has a size of zero.
4 Constructors
 An array constructor is a sequence of scalar values that is
 interpreted as a rank-one array.  The array element values are
 those specified in the sequence.  An array constructor takes the
 following form:

    (/ac-value-list/)

    ac-value-list  Is a list of one or more expressions 
                   or implied-do loops. Each ac-value must 
                   have the same type and kind type parameter.

 An implied-do loop in an array constructor takes the following
 form:

   (ac-value-list, do-variable = expr1, expr2 [,expr3])

   do-variable  Is the name of a scalar integer variable.  
                Its scope is that of the implied-do loop.

   expr         Is a scalar integer expression. The expr1 
                and expr2 specify a range of values for 
                the loop; expr3 specifies the stride.

 The array constructor has the same type as the ac-value-list
 expressions.

 If the sequence of values specified by the array constructor is
 empty (there are no expressions or the implied-do loop produces no
 values), the rank-one array has a size of zero.

 The ac-value specifies the following:

  o  If it is a scalar expression, its value specifies an element of
     the array constructor.

  o  If it is an array expression, the values of the elements of the
     expression, in array element order, specify the corresponding
     sequence of elements of the array constructor.

  o  If it is an implied-do loop, it is expanded to form an array
     constructor value sequence under the control of the DO
     variable, as in the DO construct.


 If every expression in an array constructor is a constant
 expression, the array constructor is a constant expression.

 If an implied-do loop is contained within another implied-do loop
 (nested), they cannot have the same DO variable (do-variable).

 There are three forms for an ac-value, as follows:

   C1 = (/4,8,7,6/)                  ! A scalar expression
   C2 = (/B(I, 1:5), B(I:J, 7:9)/)   ! An array expression
   C3 = (/(I, I=1, 4)/)              ! An implied-do loop

 You can also mix these forms, for example:

   C4 = (/4, A(1:5), (I, I=1, 4), 7/)             

 To define arrays of more than one dimension, use the RESHAPE
 intrinsic function.

 The following are alternative forms for array constructors:

  o  Square brackets (instead of parentheses and slashes) to enclose
     array constructors; for example, the following two array
     constructors are equivalent:

       INTEGER C(4)
       C = (/4,8,7,6/)
       C = [4,8,7,6]

  o  A colon-separated triplet (instead of an implied-do loop) to
     specify a range of values and a stride; for example, the
     following two array constructors are equivalent:

       INTEGER D(3)
       D = (/1:5:2/)              ! Triplet form
       D = (/(I, I=1, 5, 2)/)     ! Implied-do loop form


 The following example shows an array constructor using an
 implied-do loop:

   INTEGER ARRAY_C(10)
   ARRAY_C = (/(I, I=30, 48, 2)/)

 The values of ARRAYC are the even numbers 30 through 48.

 The following example shows an array constructor of derived type
 that uses a structure constructor:

   TYPE EMPLOYEE
     INTEGER ID
     CHARACTER(LEN=30) NAME
   END TYPE EMPLOYEE
   
   TYPE(EMPLOYEE) CC_4T(4)
   CC_4T = (/EMPLOYEE(2732,"JONES"), EMPLOYEE(0217,"LEE"),     &
             EMPLOYEE(1889,"RYAN"), EMPLOYEE(4339,"EMERSON")/)

 The following example shows how the RESHAPE intrinsic function is
 used to create a multidimensional array:

   E = (/2.3, 4.7, 6.6/)
   D = RESHAPE(SOURCE = (/3.5,(/2.0,1.0/),E/), SHAPE = (/2,3/))

 D is a rank-two array with shape (2,3) containing the following
 elements:

   3.5   1.0   4.7
   2.0   2.3   6.6
4 Dynamic_Data        
 Allocatable arrays and pointer targets can be dynamically allocated
 (created) and deallocated (freed), by using the ALLOCATE and
 DEALLOCATE statements, respectively.

 Pointers are associated with targets by pointer assignment or by
 allocating the target.  They can be dynamically disassociated from
 targets by using the NULLIFY statement.
3 Constants            
 A constant is a fixed value.  The value of a constant can be a
 numeric value, a logical value, or a character string.

 A constant that has a name is a named constant.  A named constant
 can be of any type, including derived type, and it can be
 array-valued.  A named constant has the PARAMETER attribute and is
 specified in a type declaration statement or PARAMETER statement.

 A constant that does not have a name is a literal constant.  A
 literal constant must be of intrinsic type and it cannot be
 array-valued.

 There are nine types of literal constants:  integer, real, complex,
 binary, octal, hexadecimal, logical, character, and Hollerith.
 Binary, octal, hexadecimal, and Hollerith constants have no data
 type; they assume a data type that conforms to the context in which
 they are used.
4 Binary             
 You can use this type of constant wherever numeric constants are
 allowed; it assumes a numeric data type according to its context.

 A binary constant has one of these forms:

   B'd[d...]'      
   B"d[d...]"      

   d   Is a binary (base 2) digit (0 or 1).

 You can specify up to 128 binary digits in a binary constant.
4 Character      
 A character constant is a string of printable ASCII characters
 enclosed by delimiters.  It takes one of the following forms:

   [k_]'c[c...]'       
   [k_]"c[c...]"

   k  Is the optional kind type parameter (1 is the default).
      It must be followed by an underscore.

   c  Is a printable ASCII character

 If no kind type parameter is specified, the type is default
 character.

 The length of the character constant is the number of characters
 between the delimiters.  In the apostrophe format, two consecutive
 apostrophes represent a single apostrophe.  In the quotation mark
 format, two consecutive quotation marks represent a single
 quotation mark.

 The length of a character constant must be in the range 0 to 2000.
5 C_Strings
 String values in the C language are terminated with null characters
 (CHAR(0)) and can contain nonprintable characters (such as a
 backspace).

 Nonprintable characters are specified by escape sequences.  An
 escape sequence is denoted by using the backslash (\) as an escape
 character, followed by a single character indicating the
 nonprintable character desired.

 This type of string is specified by using a standard string
 constant followed by the character C.  The standard string constant
 is then interpreted as a C-language constant.  Backslashes are
 treated as escapes, and a null character is automatically appended
 to the end of the string (even if the string already ends in a null
 character).

 The following C-style escape sequences are allowed in character
 constants:

    Escape Sequence    Represents
    ---------------    ----------
    \a                 A bell
    \b                 A backspace
    \f                 A formfeed
    \n                 A new line
    \r                 A carriage return
    \t                 A horizontal tab
    \v                 A vertical tab
    \x"hh"             A hexadecimal bit pattern
    \"ooo"             An octal bit pattern
    \0                 A null character
    \\                 A backslash 

 If a character constant contains any other escape sequence, the
 backslash is ignored.

 A C string must also be a valid Fortran string.  If the string is
 delimited by apostrophes, apostrophes in the string itself must be
 represented by two consecutive apostrophes ('').

 For example, the escape sequence \'string causes a compiler error
 because Fortran interprets the apostrophe as the end of the string.
 The correct form is \''string.

 If the string is delimited by quotation marks, quotation marks in
 the string itself must be represented by two consecutive quotation
 marks ("").

 The sequences \"ooo" and \x"hh" allow any ASCII character to be
 given as a one- to three-digit octal or a one- to two-digit
 hexadecimal character code.  Each octal digit must be in the range
 0 to 7, and each hexadecimal digit must be in the range 0 to F.
 For example, the C strings '\010'C and '\x08'C) both represent a
 backspace character followed by a null character.

 The C string '\\abcd'C) is equivalent to the string '\abcd' with a
 null character appended.  The string ''C represents the ASCII null
 character.
4 Complex        
 A complex constant consists of a pair of real or integer constants.
 The two constants are separated by a comma and enclosed in
 parentheses.  The first constant represents the real part of the
 number and the second constant represents the imaginary part.

 DIGITAL Fortran provides two kind type parameters for data of type
 complex:  COMPLEX(KIND=4) (or COMPLEX*8) and COMPLEX(KIND=8) (or
 COMPLEX*16).  COMPLEX(KIND=8) is DOUBLE COMPLEX.  The type
 specifier for the complex type is COMPLEX; the type specifier for
 the double complex type is DOUBLE COMPLEX.

 If a kind type parameter is specified, the complex constant has the
 kind specified.  If no kind type parameter is specified, the kind
 type of both parts is default real, and the constant is of type
 default complex.

 A COMPLEX (COMPLEX(KIND=4) or COMPLEX*8) constant has 
 the form:

  (c,c)         

   c   Is an integer or REAL (REAL(KIND=4) or REAL*4) 
       constant

 A DOUBLE COMPLEX (COMPLEX(KIND=8) or COMPLEX*16) constant 
 has the form:

  (c,c)             

   c   Is an integer, REAL (REAL(KIND=4) or REAL*4), or 
       DOUBLE PRECISION (REAL(KIND=8) or REAL*8) constant.
       At least one of the pair must be a DOUBLE PRECISION 
       constant.

 Note that the comma and parentheses are required.
4 Hexadecimal        
 You can use this type of constant wherever numeric constants are
 allowed; it assumes a numeric data type according to its context.

 A hexadecimal constant has one of these forms:

   Z'd[d...]'
   Z"d[d...]"

   d   Is a hexadecimal (base 16) digit in the range 0 - 9, 
       or a letter in the range A - F, or a - f

 You can specify up to 128 bits in hexadecimal (32 hexadecimal
 digits) constants.  Leading zeros are ignored.
4 Hollerith      
 A Hollerith constant is a string of printable characters preceded
 by a character count and the letter H.  It is used only in numeric
 expressions and has the form:

   nHc[c...]

   n     Is an unsigned, nonzero integer constant stating the
         number of characters in the string (including tabs 
         and spaces).

   c     Is a printable ASCII character.

 A Hollerith constant can be a string of 1 to 2000 characters and is
 stored as a byte string, one character per byte.

 Hollerith constants have no data type, but assume a numeric data
 type according to the context in which they are used.  They assume
 data types according to the following rules:

  o  When the constant is used with a binary operator, including the
     assignment operator, the data type of the constant is the data
     type of the other operand.

  o  When a specific data type is required, that type is assumed for
     the constant.

  o  When the constant is used as an actual argument, no data type
     is assumed.


 When the length of the constant is less than the length implied by
 the data type, blanks are appended to the constant on the right.

 When the length of the constant is greater than the length implied
 by the data type, the constant is truncated on the right.  If any
 characters other than blank characters are truncated, an error
 occurs.
4 Integer        
 An integer constant is a whole number with no decimal point.  It
 can have a leading sign and is interpreted as a decimal number.

 DIGITAL Fortran provides four kind type parameters for data of type
 integer:  INTEGER(KIND=1) (or INTEGER*1), INTEGER(KIND=2) (or
 INTEGER*2), INTEGER(KIND=4) (or INTEGER*4), and INTEGER(KIND=8) (or
 INTEGER*8).

 The type specifier for the integer type is INTEGER.

 If a kind type parameter is specified, the integer has the kind
 specified.  If a kind type parameter is not specified, integer
 constants are interpreted as follows:

  o  If the integer constant is within the default integer kind, the
     kind is default integer.

  o  If the integer constant is outside the default integer kind,
     the kind type of the integer constant is the smallest integer
     kind which holds the constant.


 Integer constants take the following form:

   [s]n[n...][_k]

   s   Is a sign; required if negative (-), optional if 
       positive (+).

   n   Is a decimal digit (0 through 9).  Any leading 
       zeros are ignored.

   k   Is an optional kind type parameter (1 for 
       INTEGER(KIND=1), 2 for INTEGER(KIND=2), 4 for 
       INTEGER(KIND=4), and 8 for INTEGER(KIND=8)). It 
       must be preceded by an underscore (_).

 An unsigned constant is assumed to be nonnegative.

 Integers are expressed in decimal values (base 10) by default.

 To specify a constant that is not in base 10, use the following
 syntax:

   [s][[base] #]nnn...

   s     Is a sign; required if negative (-), optional if 
         positive (+).

   base  Is any constant from 2 through 36. 

 If "base" is omitted but   is specified, the integer is interpreted
 in base 16.  If both "base" and   are omitted, the integer is
 interpreted in base 10.

 For bases 11 through 36, the letters A through Z represent numbers
 greater than 9.  For example, for base 36, A represents 10, B
 represents 11, C represents 12, and so on, through Z, which
 represents 35.  The case of the letters is not significant.

 For example, the following integers are all assigned a value equal
 to 3,994,575 decimal:

 I     = 2#1111001111001111001111
 K     = #3CF3CF
 n     = +17#2DE110
 index = 36#2DM8F

 You can use integer constants to assign values to data.  The
 integer data types have the following ranges:

   BYTE         Same range as INTEGER*1

   INTEGER*1    Signed integers: -128 to 127 (-2**7 to 2**7-1)
   (1 byte)     Unsigned integers: 0 to 255 (2**8-1)
   
   INTEGER*2    Signed integers: -32768 to 32767 
   (2 bytes)                     (-2**15 to 2**15-1)
                Unsigned integers: 0 to 65535 (2**16-1)

   INTEGER*4    Signed integers: -2147483648 to 2147483647 
   (4 bytes)                          (-2**31 to 2**31-1)
                Unsigned integers: 0 to 4294967295 (2**32-1)

   INTEGER*8    Signed integers: -9223372036854775808 to 
   (8 bytes)    9223372036854775807 (-2**63 to 2**63-1)

 NOTE1: The value of an integer constant must be within 
        INTEGER(KIND=8) range.

 NOTE2: The "unsigned" ranges above are allowed for assignment 
        to variables of these types, but the data type is 
        treated as signed in arithmetic operations.
4 Logical        
 A logical constant represents only the logical values true or
 false.  It takes one of these forms:

   .TRUE.[_k]
   .FALSE.[_k]

   k   Is an optional kind type parameter (1 for 
       LOGICAL(KIND=1), 2 for LOGICAL(KIND=2), 4 for 
       LOGICAL(KIND=4), and 8 for LOGICAL(KIND=8)).  
       It must be preceded by an underscore (_).

 The type specifier for the logical type is LOGICAL.

 If a kind type parameter is specified, the logical constant has the
 kind specified.  If no kind type parameter is specified, the kind
 type of the constant is default logical.

 Note that logical data type ranges correspond to their comparable
 integer data type ranges.  For example, the LOGICAL*2 range is the
 same as the INTEGER*2 range.
4 Octal              
 You can use this type of constant wherever numeric constants are
 allowed; it assumes a numeric data type according to its context.

 An octal constant has one of these forms:

   O'd[...d]'
   O"d[...d]"

   d   Is an octal (base 8) digit in the range 0 - 7.

 You can specify up to 128 bits in octal (43 octal digits)
 constants.  Leading zeros are ignored.
4 Real            
 A real constant approximates the value of a mathematical real
 number.  The value of the constant can be positive, zero, or
 negative.

 DIGITAL Fortran provides three kind type parameters for data of
 type real:  REAL(KIND=4) (or REAL*4), REAL(KIND=8) (or REAL*8), and
 REAL(KIND=16) (or REAL*16).  REAL(KIND=8) is DOUBLE PRECISION.  If
 DOUBLE PRECISION is used, a kind type parameter must not be
 specified for the constant.

 The type specifier for the real (single-precision) type is REAL;
 the type specifier for the double precision type is DOUBLE
 PRECISION.

 If a kind type parameter is specified, the real constant has the
 kind specified.  If a kind type parameter is not specified, the
 kind is default real.

 The following is the general form of a real constant with no
 exponent part:

   [s]n[n...][_k]

 A real constant with an exponent part has one of the following
 forms:

   [s]n[n...]E[s]nn...[_k]
   [s]n[n...]D[s]nn...
   [s]n[n...]Q[s]nn...

    s   Is a sign; required if negative (-), optional if 
        positive (+).

    n   Is a decimal digit (0 through 9). A decimal point 
        must appear if the real constant has no exponent part.

    k   Is the optional kind type parameter (4 for REAL(KIND=4), 
        8 for REAL(KIND=8), or 16 for REAL(KIND=16)).  It must 
        be preceded by an underscore (_).

 Leading zeros (zeros to the left of the first nonzero digit) are
 ignored in counting significant digits.  For example, in the
 constant 0.00001234567, all of the nonzero digits, and none of the
 zeros, are significant.  (See the following sections for the number
 of significant digits each kind type parameter typically has).

 The exponent represents a power of 10 by which the preceding real
 or integer constant is to be multiplied (for example, 1.0E6
 represents the value 1.0 * 10**6).

 A real constant with no exponent part is (by default) a
 single-precision (REAL(KIND=4)) constant.

 If the real constant has no exponent part, a decimal point must
 appear in the string (anywhere before the optional kind type
 parameter).  If there is an exponent part, a decimal point is
 optional in the string preceding the exponent part; the exponent
 part must not contain a decimal point.

 The exponent letter E denotes a single-precision real (REAL(KIND=4)
 or REAL*4) constant, unless the optional kind type parameter
 specifies otherwise.  For example, -9.E2_8 is a double-precision
 constant (which can also be written as -9.D2).

 The exponent letter D denotes a double-precision real (REAL(KIND=8)
 or REAL*8) constant.

 The exponent letter Q denotes a quad-precision real (REAL(KIND=16)
 or REAL*16) constant.  A minus sign must appear before a negative
 real constant; a plus sign is optional before a positive constant.
 Similarly, a minus sign must appear between the exponent letter (E,
 D, or Q) and a negative exponent, whereas a plus sign is optional
 between the exponent letter and a positive exponent.

 If the real constant includes an exponent letter, the exponent
 field cannot be omitted, but it can be zero.

 To specify a real constant using both an exponent letter and a kind
 type parameter, the exponent letter must be E, and the kind type
 parameter must follow the exponent part.
5 DOUBLE_PRECISION   
 See DATA CONSTANTS REAL REAL_8 in this Help file.
5 REAL_4           
 REAL(KIND=4) or REAL*4

 A single-precision REAL constant occupies four bytes of memory.
 The number of digits is unlimited, but typically only the leftmost
 seven digits are significant.

 On DIGITAL UNIX systems, IEEE S_floating format is used.  On
 OpenVMS systems, either DIGITAL VAX F_floating or IEEE S_floating
 format is used, depending on the compiler option specified.
5 REAL_8        
 DOUBLE PRECISION (REAL(KIND=8) or REAL*8)

 A DOUBLE PRECISION constant has more than twice the accuracy of a
 REAL number, and greater range.

 A DOUBLE PRECISION constant occupies eight bytes of memory.  The
 number of digits that precede the exponent is unlimited, but
 typically only the leftmost 15 digits are significant.

 On DIGITAL UNIX systems, IEEE T_floating format is used.  On
 OpenVMS systems, either DIGITAL VAX D_floating, G_floating, or IEEE
 T_floating format is used, depending on the compiler option
 specified.
5 REAL_16        
 REAL(KIND=16) or REAL*16

 A REAL(KIND=16) constant has more than four times the accuracy of a
 REAL number, and a greater range.

 A REAL(KIND=16) constant occupies 16 bytes of memory.  The number
 of digits that precede the exponent is unlimited, but typically
 only the leftmost 33 digits are significant.
4 Type_of_BOH_Constants        
 Binary, octal, and hexadecimal constants are "typeless" numeric
 constants.  They assume data types based on their usage, according
 to the following rules:

  o  When the constant is used with a binary operator, including the
     assignment operator, the data type of the constant is the data
     type of the other operand.

  o  When a specific data type is required, that type is assumed for
     the constant.

  o  When the constant is used as an actual argument, if the bit
     constant is greater than 4 bytes, INTEGER*8 is assumed;
     otherwise, INTEGER*4 is assumed.

  o  When the constant is used in any other context, an INTEGER*4
     data type is assumed (unless a compiler option indicating
     integer size specifies otherwise).


 These constants specify up to 16 bytes of data.  When the length of
 the constant is less than the length implied by the data type, the
 leftmost digits have a value of zero.

 When the length of the constant is greater than the length implied
 by the data type, the constant is truncated on the left.  An error
 results if any nonzero digits are truncated.
3 Derived_Types       
 Like intrinsic data types, a Fortran 90 derived data type has a
 name, a set of associated values, a way to denote the values, and
 operations to manipulate and interpret these values.

 The names of the intrinsic data types are predefined, while the
 names of derived types are defined in derived-type definitions.

 A derived-type definition specifies the name of the type and the
 types of its components.  A derived type can be resolved into
 "ultimate" components that are either of intrinsic type or are
 pointers.

 The set of values for a specific derived type consists of all
 possible sequences of component values permitted by the definition
 of that derived type.  Structure constructors are used to specify
 values of derived types.

 Nonintrinsic assignment for derived-type entities must be defined
 by a subroutine with an ASSIGNMENT interface.  Any operation on
 derived-type entities must be defined by a function with an
 OPERATOR interface.  Arguments and function values can be of any
 intrinsic or derived type.
4 Type_Definitions    
 A derived-type definition specifies the name of a user-defined type
 and the types of its components.  It takes the following form:

   TYPE [[, PRIVATE or PUBLIC] :: ] name
     [PRIVATE or SEQUENCE]...
     comp-def
     [comp-def]...
   END TYPE [name]
  
   name      Is the name of the derived type. It must not be
             the same as the name of any intrinsic type, or 
             the same as the name of a derived type that can be
             accessed from a module.

   comp-def  There must be at least one.  It takes the following 
             form:

      type [ [, attr-list] ::] comp [(a-spec)] [*char-len] [init_ex]

   type      Is a type specifier.  It can be an intrinsic type 
             or a previously defined derived type. (If the POINTER
             attribute follows this specifier, the type can also be
             any accessible derived type, including the type 
             being defined.)

   attr-list Is an optional list of component attributes POINTER 
             or DIMENSION.  You can specify one or both attributes.  
             If DIMENSION is specified, it can be followed by an 
             array specification.

   comp      Is the name of the component being defined.

   a-spec    Is an optional array specification, enclosed in 
             parentheses.  If POINTER is specified, the array is 
             deferred-shape; otherwise, it is explicit-shape.

             In an explicit-shape specification, each bound must 
             be a constant scalar integer expression. 

   char-len  Is an optional scalar integer literal constant; it 
             must be preceded by an asterisk (*).  This parameter 
             can only be specified if the component is of type 
             CHARACTER.

   init_ex   Is an initialization expression or, for pointer
             objects, =>NULL().

 If a name is specified following the END TYPE statement, it must be
 the same name that follows TYPE in the derived type statement.

 Within a scoping unit, a derived-type name can only be defined
 once.  If the same derived-type name appears in a derived-type
 definition in another scoping unit, it is treated independently.

 A component name has the scope of the derived-type definition only.
 Therefore, the same name can be used in another derived-type
 definition in the same scoping unit.

 Two entities can have the same derived type in the following cases:

  o  If they are both declared to be of the same derived type, and
     the derived-type definition can be accessed from the same
     module, the same scoping unit, or a host scoping unit.

  o  If they are both declared to be of the same derived type, and
     the derived-type definition can be accessed from the same
     scoping unit or a host scoping unit.

  o  If they are both declared in a derived-type definition
     specifying SEQUENCE (they both have sequence type).

     A sequence type can be defined in each scoping unit that needs
     to access the type.  Each derived-type definition must specify
     the same name, the keyword SEQUENCE, and have components that
     agree in order, name, and attributes.  (No private components
     are allowed in a sequence type.)


 The same PRIVATE or SEQUENCE statements can only appear once in a
 given derived-type definition.

 If SEQUENCE is present, all derived types specified in component
 definitions must be sequence types.

 The PUBLIC or PRIVATE keywords can only appear if the derived-type
 definition is in the specification part of a module.

 The POINTER or DIMENSION attribute can only appear once in a given
 comp-def.

 A component is an array if the component definition contains a
 DIMENSION attribute or an array specification.  If the component
 definition contains an array specification, the array bounds should
 be specified there; otherwise, they must be specified following the
 DIMENSION attribute.

 If an initialization expression ("init_ex") appears for a
 nonpointer component, the component (in any object of the type) is
 initially defined with the value determined from the initialization
 expression.  The initialization expression is evaluated in the
 scoping unit of the type definition.

 The initialization expression overrides any default initial value
 specified for the component.  Explicit initialization in a type
 declaration statement overrides default initialization.

 If POINTER appears in the comp-def, the component is a pointer.
 Pointers can have an association status of associated,
 disassociated, or undefined.  If no default initialization status
 is specified, the status of the pointer is undefined.  To specify
 disassociated status for a pointer component, use =>NULL().
4 Components            
 A reference to a component of a derived-type structure takes the
 following form:

   parent [%component [(s-list)]]... %component [(s-list)]

   parent    Is the name of a scalar or array of derived type.  
             The percent sign (%) is called a component selector.

   component Is the name of a component of the immediately 
             preceding parent or component. 

   s-list    Is a list of one or more subscripts. If the list 
             contains subscript triplets or vector subscripts, 
             the reference is to an array section.

             Each subscript must be a scalar numeric expression
             with a value that is within the bounds of its 
             dimension.

             The number of subscripts in any s-list must equal 
             the rank of the immediately preceding parent or 
             component.

 Each parent or component (except the rightmost) must be of derived
 type.

 The parent or one of the components can have nonzero rank (be an
 array).  Any component to the right of a parent or component of
 nonzero rank must not have the POINTER attribute.

 The rank of the structure component is the rank of the part (parent
 or component) with nonzero rank (if any); otherwise, the rank is
 zero.  The type and type parameters (if any) of a structure
 component are those of the rightmost part name.

 The structure component must not be referenced or defined before
 the declaration of the parent object.

 If the parent object has the INTENT, TARGET, or PARAMETER
 attribute, the structure component also has the attribute.
5 Examples
 The following example shows a derived-type definition with two
 components:

   TYPE EMPLOYEE
     INTEGER ID
     CHARACTER(LEN=40) NAME
   END TYPE EMPLOYEE

 The following shows how to declare a variable CONTRACT of type
 EMPLOYEE:

   TYPE(EMPLOYEE) :: CONTRACT

 Note that both examples started with the keyword TYPE.  The first
 (initial) statement of a derived-type definition is called a
 derived-type statement, while the statement that declares a
 derived-type object is called a TYPE statement.

 The following example shows how to reference component ID of parent
 structure CONTRACT:

   CONTRACT%ID

 The following example shows a derived type with a component that is
 a previously defined type:

   TYPE DOT
     REAL X, Y
   END TYPE DOT
   ....
   TYPE SCREEN
     TYPE(DOT) C, D
   END TYPE SCREEN

 The following declares a variable of type SCREEN:

   TYPE(SCREEN) M

 Variable M has components M%C and M%D (both of type DOT); M%C has
 components M%C%X and M%C%Y of type REAL.

 The following example shows a derived type with a component that is
 an array:

   TYPE CAR_INFO
     INTEGER YEAR
     CHARACTER(LEN=15), DIMENSION(10) :: MAKER
     CHARACTER(LEN=10) MODEL, BODY_TYPE*8
     REAL PRICE
   END TYPE
   ...
   TYPE(CAR_INFO) MY_CAR

 Note that MODEL has a character length of 10, but BODYTYPE has a
 character length of 8.  You can assign a value to a component of a
 structure; for example:

   MY_CAR%YEAR = 1985

 The following shows an array structure component:

   MY_CAR%MAKER

 In the preceding example, if a subscript list (or substring) was
 appended to MAKER, the reference would not be to an array structure
 component, but to an array element or section.

 Consider the following:

   TYPE CHARGE
     INTEGER PARTS(40)
     REAL LABOR
     REAL MILEAGE
   END TYPE CHARGE
   
   TYPE(CHARGE) MONTH
   TYPE(CHARGE) YEAR(12)

 Some valid array references for this type follow:

   MONTH%PARTS(I)           ! An array element
   MONTH%PARTS(I:K)         ! An array section
   YEAR(I)%PARTS            ! An array structure component 
                            !  (a whole array)

   YEAR(J)%PARTS(I)         ! An array element
   YEAR(J)%PARTS(I:K)       ! An array section
   YEAR(J:K)%PARTS(I)       ! An array section 
   YEAR%PARTS(I)            ! An array section

 The following example shows a derived type with a pointer component
 that is of the type being defined:

   TYPE NUMBER
     INTEGER NUM
     TYPE(NUMBER), POINTER :: BEFORE_NUM
     TYPE(NUMBER), POINTER :: AFTER_NUM
   END TYPE

 A type such as this can be used to construct linked lists of
 objects of type NUMBER.

 The following example shows a private type:

   TYPE, PRIVATE :: SYMBOL
     LOGICAL TEST
     CHARACTER(LEN=50) EXPLANATION
   END TYPE SYMBOL  

 This type is private to the module.  The module can be used by
 another scoping unit, but type SYMBOL is not available.

 The following example shows a derived-type definition that is
 public with components that are private:

   MODULE MATTER
     TYPE ELEMENTS
       PRIVATE
       INTEGER C, D
     END TYPE
   ...
   END MODULE MATTER

 In this case, components C and D are private to type ELEMENTS, but
 type ELEMENTS is not private to MODULE MATTER.  Any program unit
 that uses the module MATTER can declare variables of type ELEMENTS,
 and pass as arguments values of type ELEMENTS.

 This design allows you to change components of a type without
 affecting other program units that use the module.

 If a derived type is needed in more than one program unit, the
 definition should be placed in a module and accessed by a USE
 statement whenever it is needed, as follows:

   MODULE STUDENTS
     TYPE STUDENT_RECORD
     ...
     END TYPE
   CONTAINS
     SUBROUTINE COURSE_GRADE(...)
     TYPE(STUDENT_RECORD) NAME
     ...
     END SUBROUTINE
   END MODULE STUDENTS
   ...
   
   PROGRAM SENIOR_CLASS
     USE STUDENTS
     TYPE(STUDENT_RECORD) ID
     ...
   END PROGRAM

 Program SENIOR_CLASS has access to type STUDENT_RECORD, because it
 uses module STUDENTS.  Module procedure COURSE_GRADE also has
 access to type STUDENT_RECORD, because the derived-type definition
 appears in its host.
4 Constructors
 A structure constructor lets you specify scalar values of a derived
 type.  It takes the following form:

   d-name (expr-list)

   d-name    Is the name of the derived type.

   expr-list Is a list of expressions specifying component 
             values.  The values must agree in number and 
             order with the components of the derived type.
             
             If necessary, values are converted (according 
             to the rules of assignment), to agree with their 
             corresponding components in type and kind type 
             parameters.

 A structure constructor must not appear before its derived type is
 defined.

 If a component of the derived type is an array, the shape in the
 expression list must conform to the shape of the component array.

 If a component of the derived type is a pointer, the value in the
 expression list must evaluate to an object that would be a valid
 target in a pointer assignment statement.  (A constant is not a
 valid target in a pointer assignment statement.)

 If all the values in a structure constructor are constant
 expressions, the constructor is a derived-type constant expression.
5 Examples

 Consider the following derived-type definition:

   TYPE EMPLOYEE
     INTEGER ID
     CHARACTER(LEN=40) NAME
   END TYPE EMPLOYEE

 This can be used to produce the following structure constructor:

   EMPLOYEE(3472, "John Doe")

 The following example shows a type with a component of derived
 type:

   TYPE ITEM
     REAL COST
     CHARACTER(LEN=30) SUPPLIER
     CHARACTER(LEN=20) ITEM_NAME
   END TYPE ITEM
   
   TYPE PRODUCE
     REAL MARKUP
     TYPE(ITEM) FRUIT
   END TYPE PRODUCE

 In this case, you must use an embedded structure constructor to
 specify the values of that component; for example:

   PRODUCE(.70, ITEM (.25, "Daniels", "apple"))
3 Expressions          
 An expression represents either a data reference or a computation,
 and is formed from operators, operands, and parentheses.  The
 result of an expression is either a scalar value or an array of
 scalar values.

 If the value of an expression is of intrinsic type, it has a kind
 type parameter.  (If the value is of intrinsic type CHARACTER, it
 also has a length parameter.) If the value of an expression is of
 derived type, it has no kind type parameter.

 An operand is a scalar or array.  An operator can be either
 intrinsic or defined.  An intrinsic operator is known to the
 compiler and is always available to any program unit.  A defined
 operator is described explicitly by a user in a function subprogram
 and is available to each program unit that uses the subprogram.

 The simplest form of an expression (a primary) can be any of the
 following:

  o  A constant; for example, 4.2

  o  A subobject of a constant; for example, 'LMNOP'(2:4)

  o  A variable; for example, VAR1

  o  A structure constructor; for example, EMPLOYEE(3472, "JOHN
     DOE")

  o  An array constructor; for example, (/12.0,16.0/)

  o  A function reference; for example, COS(X)

  o  Another expression in parentheses; for example, (I+5)


 Any variable or function reference used as an operand in an
 expression must be defined at the time the reference is executed.
 If the operand is a pointer, it must be associated with a target
 object that is defined.  An integer operand must be defined with an
 integer value rather than a statement label value.  All of the
 characters in a character data object reference must be defined.

 When a reference to an array or an array section is made, all of
 the selected elements must be defined.  When a structure is
 referenced, all of the components must be defined.

 In an expression that has intrinsic operators with an array as an
 operand, the operation is performed on each element of the array.
 In expressions with more than one array operand, the arrays must be
 conformable (they must have the same shape).  The operation is
 applied to corresponding elements of the arrays, and the result is
 an array of the same shape (the same rank and extents) as the
 operands.

 In an expression that has intrinsic operators with a pointer as an
 operand, the operation is performed on the value of the target
 associated with the pointer.

 For defined operators, operations on arrays and pointers are
 determined by the procedure defining the operation.

 A scalar is conformable with any array.  If one operand of an
 expression is an array and another operand is a scalar, it is as if
 the value of the scalar were replicated to form an array of the
 same shape as the array operand.  The result is an array of the
 same shape as the array operand.

 The ranking assigned to each numeric intrinsic data type follows:

   Data Type                    Ranking
   ---------                    -------
   LOGICAL*1 and BYTE            lowest
   LOGICAL*2                       .
   LOGICAL*4                       .
   LOGICAL*8                       .
   INTEGER*1                       .
   INTEGER*2                       .
   INTEGER*4                       .
   INTEGER*8                       .
   REAL (REAL*4)                   .
   REAL*16                         .
   DOUBLE PRECISION (REAL*8)       .
   COMPLEX (COMPLEX*8)             .
   DOUBLE COMPLEX (COMPLEX*16)   highest
4 Numeric     
 Numeric (arithmetic) expressions are formed with numeric operands
 and numeric operators, and yield a single numeric value.

 The term numeric includes logical data, because logical data is
 treated as integer data when used in a numeric context.  (.TRUE.
 is -1; .FALSE.  is 0.)

 The numeric operators are as follows:

      Operator    Description
      -----------------------
         **       exponentiation (evaluated
                           right to left)
         *        multiplication
         /        division 
         +        addition
         -        subtraction        

 You can use parentheses to force an order of evaluation.
4 Character   
 Character expressions consist of character items and character
 operators.  Evaluation of a character expression yields a single
 value of character data type.

 A character expression has the form:

   character operand[//character operand]...

 The concatenation operator (//) is the only character operator.
 Concatenation is from left to right.
4 Defined_Operations
 A defined operation is unary or binary.  It is defined by a
 function subprogram containing a generic interface block with the
 specifier OPERATOR.  A defined operation is not an intrinsic
 operation.  However, you can use a defined operation to extend the
 meaning of an intrinsic operator.

 For defined unary operations, the function must contain one
 argument.  For defined binary operations, the function must contain
 two arguments.

 Interpretation of the operation is provided by the function that
 defines the operation.

 A Fortran 90 defined operator can contain up to 31 letters, and is
 enclosed in periods (.).  Its name cannot be the same name as any
 of the following:

   o The intrinsic operators  .NOT., .AND., .OR., .XOR., 
     .EQV., .NEQV., .EQ., .NE., .GT., .GE., .LT., and .LE.

   o The logical literal constants .TRUE. or .FALSE..

 No two intrinsic operators can follow one another, but an intrinsic
 or binary operator can be followed by a defined unary operator.

 The result of a defined operation can have any type.  The type of
 the result (and its value) must be specified by the defining
 function.

 The following examples show expressions containing defined
 operators:

   .COMPLEMENT. A

   X .PLUS. Y .PLUS. Z

   M * .MINUS. N

4 Initialization
 An initialization expression must evaluate at compile time to a
 constant.  It is used to specify an initial value for an entity.

 In an initialization expression, each operation is intrinsic and
 each operand is one of the following:

  o  A constant or subobject of a constant

  o  An array constructor where each element, and the bounds and
     strides of each implied-do are expressions whose primaries are
     initialization expressions

  o  A structure constructor whose components are initialization
     expressions

  o  An elemental intrinsic function reference of type integer or
     character, whose arguments are initialization expressions of
     type integer or character

  o  A reference to one of the following transformational functions
     (each argument must be an initialization expression):

         REPEAT       
         RESHAPE       
         SELECTED_INT_KIND       
         SELECTED_REAL_KIND
         TRANSFER
         TRIM

  o  A reference to one of the following inquiry functions:

         BIT_SIZE      MINEXPONENT
         DIGITS        PRECISION
         EPSILON       RADIX
         HUGE          RANGE
         ILEN          SHAPE
         KIND          SIZE
         LBOUND        TINY
         LEN           UBOUND
         MAXEXPONENT      

     Each function argument must be one of the following:

         - An initialization expression
         - A variable whose kind type parameter and bounds 
             are not assumed or defined by an ALLOCATE statement,
             pointer assignment, or an expression that is not an
             initialization expression

  o  A reference to the transformational function NULL

  o  An implied-do variable within an array constructor where the
     bounds and strides of the corresponding implied-do are
     initialization expressions

  o  Another initialization expression enclosed in parentheses


 Each subscript, section subscript, and substring starting and
 ending point must be an initialization expression.

 In an initialization expression, the exponential operator (**) must
 have a power of type integer.

 If an initialization expression invokes an inquiry function for a
 type parameter or an array bound of an object, the type parameter
 or array bound must be specified in a prior specification statement
 (or to the left of the inquiry function in the same statement).
4 Logical     
 Logical expressions can contain one or more logical operators and
 logical, integer, or relational operands.  The following are
 logical operators:

    Operator  Meaning
    ---------------------------
    .AND.     Logical conjunction: the expression A .AND. B
              is true if both A and B are true.

    .OR.      Logical disjunction (inclusive OR):  the ex-
              pression A .OR. B is true if either A, B, or 
              both, are true.

    .XOR.     Same as .NEQV.

    .NEQV.    Logical inequivalence (or exclusive OR): the
              expression A .NEQV. B is true if either A or 
              B is true, but false if both are true.

    .EQV.     Logical equivalence: the expression A .EQV. B
              is true if both A and B are true, or both are
              false.

    .NOT.     Logical negation: the expression .NOT. A is 
              true if A is false and false if A is true.
4 Operator_Precedence
 The following shows the precedence of all intrinsic and defined
 operators:

 Category    Operator                     Precedence
 ---------------------------------------------------
 N/A         Defined Unary Operators      Highest
 Numeric     **                              .
 Numeric     * or /                          .
 Numeric     Unary + or -                    .
 Numeric     Binary + or -                   .
 Character   //                              .
 Relational  .EQ.,.NE.,.LT.,.LE.,.GT.,.GE.   .
              ==,  /=,  <,   <=,  >,   >=    .
 Logical     .NOT.                           .
 Logical     .AND.                           .
 Logical     .OR.                            .
 Logical     .XOR., .EQV., .NEQV.            .
 N/A         Defined Binary Operators     Lowest
4 Relational  
 Relational expressions consist of two or more expressions whose
 values are compared to determine whether the relationship stated by
 the relational operator is satisfied.  The expression is reduced to
 a logical value (true or false).

 The following are relational operators:

       Operator         Meaning
       ------------------------------------------
        .LT. or <       Less than
        .LE. or <=      Less than or equal to
        .EQ. or ==      Equal to
        .NE. or /=      Not equal to
        .GT. or >       Greater than
        .GE. or >=      Greater than or equal to

 NOTE: Expressions of COMPLEX data type can use only 
       .EQ.  and .NE. operators.
4 Specification  
 A specification expression is a restricted expression that is of
 type integer and has a scalar value.  This type of expression
 appears only in the declaration of array bounds and character
 lengths.

 In a restricted expression, each operation is intrinsic and each
 operand is one of the following:

  o  A constant or subobject of a constant

  o  A variable that is one of the following:

         - A dummy argument that does not have the OPTIONAL or
             INTENT (OUT) attribute (or the subobject of such 
             a variable)
         - In a common block (or the subobject of such a variable)
         - Made accessible by use or host association (or the 
             subobject of such a variable)

  o  An array constructor where each element, and bounds and strides
     of each implied-do are expressions whose primaries are
     restricted expressions

  o  A structure constructor whose components are restricted
     expressions

  o  An implied-do variable within an array constructor where the
     bounds and strides of the corresponding implied-do are
     initialization expressions

  o  A reference to one of the following transformational functions
     (each argument must be a restricted expression of type integer
     or character):

         REPEAT 
         RESHAPE
         SELECTED_INT_KIND
         SELECTED_REAL_KIND
         TRANSFER
         TRIM

  o  A reference to one of the following inquiry functions:

         BIT_SIZE     NUMBER_OF_PROCESSORS
         DIGITS       NWORKERS
         EPSILON      PRECISION
         HUGE         PROCESSORS_SHAPE
         ILEN         RADIX
         KIND         RANGE
         LBOUND       SHAPE
         LEN          SIZE
         MAXEXPONENT  TINY
         MINEXPONENT  UBOUND

     Each function argument must be one of the following:

         - A restricted expression
         - A variable whose kind type parameter and bounds 
             are not assumed or defined by an ALLOCATE statement,
             pointer assignment, or an expression that is not a 
             restricted expression

  o  A reference to a specification function (see below) where each
     argument is a restricted expression

  o  A reference to the transformational function NULL

  o  Another restrcited expression enclosed in parentheses


 Each subscript, section subscript, and substring starting and
 ending point must be a restricted expression.

 Specification functions can be used in specification expressions to
 indicate the attributes of data objects.  A specification function
 is a pure function.  It cannot have a dummy procedure argument or
 be any of the following:

  o  An intrinsic function

  o  An internal function

  o  A statement function

  o  Defined as RECURSIVE


 A variable in a specification expression must have its type and
 type parameters (if any) specified in one of the following ways:

  o  By a previous declaration in the same scoping unit

  o  By the implicit typing rules currently in effect for the
     scoping unit

  o  By host or use association


 If a variable in a specification expression is typed by the
 implicit typing rules, its appearance in any subsequent type
 declaration statement must confirm the implied type and type
 parameters.

 If a specification expression invokes an inquiry function for a
 type parameter or an array bound of an object, the type parameter
 or array bound must be specified in a prior specification statement
 (or to the left of the inquiry function in the same statement).
3 Intrinsic_Types     
 DIGITAL Fortran provides the following intrinsic data types:

  o  INTEGER (4 kind type parameters) - a whole number

  o  REAL (3 kind type parameters) - a floating point number (a
     whole number, a decimal fraction, or a combination)

  o  DOUBLE PRECISION - a REAL kind type parameter that has more
     than twice the degree of accuracy in its representation, and
     greater range

  o  COMPLEX (2 kind type parameters) - a pair of REAL values
     representing a complex number (the first part of the number is
     the real part, the second is the imaginary part)

  o  DOUBLE COMPLEX - a COMPLEX kind type parameter with DOUBLE
     PRECISION real and imaginary parts

  o  LOGICAL (4 kind type parameters)- a logical value, .TRUE.  or
     .FALSE.

  o  CHARACTER - a sequence of characters

  o  BYTE - a one-byte value equivalent to INTEGER(KIND=1)

4 CHARACTER 
 A character string is a contiguous sequence of bytes in memory.  A
 character string is specified by two attributes:  the address of
 the first byte of the string and the length of the string in bytes.
 The length of the string must be in the range 1 through 65535.

 Hollerith constants are stored internally, one character per byte.
4 COMPLEX   
 Real and complex numbers are floating-point representations.

 COMPLEX(KIND=4) (or COMPLEX*8) data is eight contiguous bytes
 aligned on an arbitrary byte boundary.  The low-order four bytes
 contain REAL(KIND=4) (or REAL*4) data that represents the real part
 of the complex number.  The high-order four bytes contain REAL data
 that represents the imaginary part of the complex number.  For
 information on the ranges of REAL data, see REAL (within the DATA
 CONSTANTS section of online Help).

 DOUBLE COMPLEX (COMPLEX(KIND=8) or COMPLEX*16) data is 16
 contiguous bytes aligned on an arbitrary byte boundary.  The
 low-order bytes contain DOUBLE PRECISION data that represents the
 real part of the complex number.  The high-order eight bytes
 contain DOUBLE PRECISION data that represents the imaginary part of
 the complex data.  For information on the ranges of DOUBLE
 PRECISION data, see DOUBLE_PRECISION (within the DATA CONSTANTS
 section of online Help).
4 INTEGER   
 Integer numbers are whole numbers.  For information on the ranges
 of INTEGER data, see INTEGER (within the DATA CONSTANTS section of
 online Help).

 INTEGER*2, INTEGER*4, and INTEGER*8 values are stored in two's
 complement form.

 Note that logical data type ranges correspond to their comparable
 integer data type ranges.  For example, in LOGICAL*2 L, the range
 for L is the same as the range for INTEGER*2 integers.
4 LOGICAL   
 Logical values start on an arbitrary byte boundary and are stored
 in one, two, or four contiguous bytes.  The low-order bit (bit 0)
 determines the value.  If bit 0 is set, the value is .TRUE.; if bit
 0 is clear, the value is .FALSE.  The remaining bits are undefined.

 When a logical value is stored in memory, all of its bits are
 stored.  For example, consider the following:

    LOGICAL*4 L1, L2, L3
    L1 = L2 .AND. L3

 This example does a full 32-bit AND of L2 and L3, and stores all 32
 resulting bits in L1.
4 REAL      
 Real and complex numbers are floating-point representations.

 The exponent for REAL(KIND=4) (or REAL*4) (F_floating on OpenVMS;
 S_floating on DIGITAL UNIX) and DOUBLE PRECISION (REAL(KIND=8) or
 REAL*8) (D_floating on OpenVMS; T_floating on DIGITAL UNIX) formats
 is stored in binary excess 128 notation.  Binary exponents from
 -127 to 127 are represented by the binary equivalents of 1 through
 255.

 On OpenVMS systems, the exponent for the DOUBLE PRECISION
 G_floating format is stored in binary excess 1024 notation.  The
 exponent for the REAL*16 format is stored in binary excess 16384
 notation.  In DOUBLE PRECISION (G_floating) format, binary
 exponents from -1023 to 1023 are represented by the binary
 equivalents of 1 through 2047.  In REAL*16 format, binary exponents
 from -16383 to 16383 are represented by the binary equivalents of 1
 through 32767.

 For floating-point format, fractions are represented in
 sign-magnitude notation, with the binary radix point to the left of
 the most significant bit.  Fractions are assumed to be normalized,
 and therefore the most significant bit is not stored.  This bit is
 assumed to be 1 unless the exponent is 0.  in which case the value
 represented is either zero or is a reserved operand.

 REAL(KIND=4) (or REAL*4) numbers occupy four contiguous bytes and
 the precision is approximately one part in 2**23, that is,
 typically 7 decimal digits.

 DOUBLE PRECISION (D_floating on OpenVMS; T_floating on DIGITAL
 UNIX) numbers occupy eight contiguous bytes and the precision is
 approximately one part in 2**55, that is, typically 16 decimal
 digits.

 On OpenVMS systems, DOUBLE PRECISION G_floating numbers occupy
 eight contiguous bytes and the precision is approximately one part
 in 2**52, that is, typically 15 decimal digits.

 REAL*16 (H_floating) numbers occupy sixteen contiguous bytes and
 the precision is approximately 2**112, that is, typically 33
 decimal digits.

 For more information on real data type ranges, see DATA CONSTANTS
 REAL and DATA CONSTANTS DOUBLE_PRECISION in this Help file.
3 Substrings           
 A character substring is a contiguous segment of a character
 variable, character array element, or character field reference.
 It has one of the following forms:

    v([e1]:[e2])  
    a(s[,s]...)([e1]:[e2]) 

    v    Is a character variable name
    a    Is a character array name
    s    Is a subscript expression
    e1   Is a numeric expression specifying the leftmost
         character position of the substring
    e2   Is a numeric expression specifying the rightmost
         character position of the substring

 Both e1 and e2 must be within the range 1,2, ..., len, where len is
 the length of the parent character string.  If e1 exceeds e2, the
 substring has length zero.
3 Variables            
 A variable is a data object whose value can be changed at any point
 in a program.  It can be any of the following:

  o  A scalar name

     A scalar is a single object that has a single value; it can be
     of any intrinsic or user-defined type.

  o  An array name

     An array is a collection of scalar elements of any intrinsic or
     derived type.  All elements must be have the same type and kind
     type parameter.

  o  A subobject designator

     A subobject is part of an object.  The following are
     subobjects:

       An array element
       An array section
       A structure component
       A substring

     For example, B(3) is a subobject (array element) designator for
     array B.  A subobject cannot be a variable if its parent object
     is a constant.


 The name of a variable is associated with a single storage
 location.

 Variables are classified by data type, as constants are.  The data
 type of a variable indicates the type of data it contains,
 including its precision, and implies its storage requirements.
 When data of any type is assigned to a variable, it is converted to
 the data type of the variable (if necessary).

 A variable is usually defined in a type declaration statement or
 DATA statement.  But during program execution, events can occur to
 cause variables to be defined or redefined (such as assignment
 statements and READ statements), or undefined (such as an I/O
 error).

 Scalar variables are assigned data types explicitly in type
 declaration statements or IMPLICIT statements, or they can have
 implicit data types.
4 Implicit_Typing        
 By default, all variables with names beginning with I, J, K, L, M,
 or N are assumed to be integer variables.  Variables beginning with
 any other letter are assumed to be real variables.

 You can override the default data type implied in a name by
 specifying data type explicitly in either an IMPLICIT statement or
 a type declaration statement.

 Names beginning with an underscore character (_) must be explicitly
 typed in a type declaration statement, they cannot appear in an
 IMPLICIT statement.
4 Explicit_Typing       
 Type declaration statements explicitly specify the data type of
 scalar variables.  For example, the following statements associate
 VAR1 with an 8-byte complex storage location, and VAR2 with an
 8-byte double-precision storage location:

   COMPLEX VAR1
   DOUBLE PRECISION VAR2

 You can explicitly specify the data type of a scalar variable only
 once.

 An explicit data type specification takes precedence over the type
 specified by an IMPLICIT statement.  If no explicit data type
 specification appears, any variable with a name that begins with
 the letter in the range specified in the IMPLICIT statement becomes
 the data type of the variable.

 Character type declaration statements specify that given variables
 represent character values with the length specified.  For example,
 the following statements associate the variable names INLINE, NAME,
 and NUMBER with storage locations containing character data of
 lengths 72, 12, and 9, respectively:

   CHARACTER*72 INLINE
   CHARACTER NAME*12, NUMBER*9

 In single subprograms, assumed-length character arguments can be
 used to process character strings with different lengths.  The
 assumed-length character argument has its length specified with an
 asterisk, for example:

   CHARACTER*(*) CHARDUMMY

 The argument CHARDUMMY assumes the length of the actual argument.
2 Run_Time_Messages
 Errors that occur during execution of your program are reported by
 diagnostic messages from the Run-Time Library.  These messages can
 result from hardware conditions, file system errors, errors
 detected by RMS (OpenVMS systems) or the DIGITAL Fortran 77 I/O
 system (DIGITAL UNIX), errors that occur during transfer of data
 between the program and an internal record, computations that cause
 overflow or underflow, incorrect calls to the Run-Time Library,
 problems in array descriptions, and conditions detected by the
 operating system.

 Run-Time diagnostic messages have the following format:

   forrtl: severity: message_text

   forrtl:       Identifies the source as the DIGITAL Fortran 
                 Run-Time Library
   severity:     Possibilities: severe, error, warning, or 
                 informational
   message_text: Explains the event that caused the message
3 Severe_Messages
 Must be corrected.  The program's execution is terminated when the
 error is encountered, unless for I/O statements the program uses
 the END or ERR I/O statement specifiers to transfer control,
 perhaps to a routine that uses the IOSTAT specifier (see your user
 manual).

 The severe messages follow (in alphabetical order):

  o  MESSAGE:  Adjustable array dimension error

     NUMBER:  93

     EXPLANATION:  Upon entry to a subprogram, one of the following
     errors was detected during the evaluation of dimensioning
     information:

        - An upper-dimension bound was less than a 
          lower-dimension bound.
        - The dimensions implied an array that was larger 
          than addressable memory.

  o  MESSAGE:  Attempt to access non-existent record

     NUMBER:  36

     EXPLANATION:  A direct-access READ or FIND statement attempted
     to access beyond the end of a relative file (or a sequential
     file on disk with fixed-length records) or access a record that
     was previously deleted in a relative file.

  o  Array index out of bounds (SIGTRAP)

     NUMBER:  138

     EXPLANATION:  Break exception generated a SIGTRAP signal
     (described in signal(3)).  Core dump file created.

     The cause is an array subscript that is outside the dimensioned
     boundaries of that array.  Try recompiling using the -check
     bounds option (perhaps with the f77_dump_flag environment
     variable set) or examine the core dump file to determine the
     source code in error.

  o  MESSAGE:  Array index out of bounds for index n (SIGTRAP)

     NUMBER:  139

     EXPLANATION:  Break exception generated a SIGTRAP signal
     (described in signal(3)).  Core dump file created.

     The cause is an array subscript that is outside the dimensioned
     boundaries of the array index n.  Try recompiling using the
     -check bounds option (perhaps with the f77_dump_flag
     environment variable set) or examine the core dump file to
     determine the source code in error.

  o  MESSAGE:  BACKSPACE error

     NUMBER:  23

     EXPLANATION:  An error condition was detected during execution
     of a BACKSPACE statement.

  o  MESSAGE:  Cannot overwrite existing file

     NUMBER:  10

     EXPLANATION:  Specified file xxx already existed when OPEN
     statement specified STATUS='NEW' (create new file) using I/O
     unit x.  Make sure correct file name, directory path, unit, and
     so forth were specified in the source program.  Decide whether
     to:

        - Rename or remove the existing file before rerunning 
          the program.

        - Modify the source file to specify different file 
          specification, I/O unit, or OPEN file STATUS.

  o  MESSAGE:  Cannot stat file

     NUMBER:  108

     EXPLANATION:  Attempted stat operation on the indicated file
     failed.  Make sure correct file and unit were specified.

  o  MESSAGE:  CLOSE error

     NUMBER:  28

     EXPLANATION:  An error condition was detected by the DIGITAL
     Fortran RTL I/O system during execution of a CLOSE statement.

  o  MESSAGE:  DELETE error

     NUMBER:  55

     EXPLANATION:  An error condition was detected by the DIGITAL
     Fortran RTL I/O system during execution of a DELETE statement.

  o  MESSAGE:  Divide by zero check (SIGTRAP)

     NUMBER:  137

     EXPLANATION:  Break exception generated a SIGTRAP signal
     (described in signal(3)).  Core dump file created.

     Examine core dump file for possible cause.

  o  MESSAGE:  Duplicate file specifications

     NUMBER:  21

     EXPLANATION:  Multiple attempts were made to specify file
     attributes without an intervening close operation.  For
     example, a DEFINE FILE statement was followed by another DEFINE
     FILE statement or an OPEN statement.

  o  MESSAGE:  ENDFILE error

     NUMBER:  33

     EXPLANATION:  One of the following conditions occurred:

        - The file was not a sequential organization file with 
          variable-length records.

        - The file was not opened for sequential or append access.

        - An unformatted file did not contain segmented records.

        - The DIGITAL Fortran RTL I/O system detected an error during 
          execution of an ENDFILE statement. 

  o  MESSAGE:  End-of-file during read

     NUMBER:  24

     EXPLANATION:  One of the following conditions occurred:

        - A DIGITAL Fortran RTL I/O system end-of-file condition
          was encountered during execution of a READ statement 
          that did not contain an END, ERR, or IOSTAT specification. 

        - An end-of-file record written by the ENDFILE statement 
          was encountered during execution of a READ statement 
          that did not contain an END, ERR, or IOSTAT specification.

        - An attempt was made to read past the end of an internal 
          file character string or array during execution of a READ 
          statement that did not contain an END, ERR, or IOSTAT 
          specification.

  o  MESSAGE:  Error during read

     NUMBER:  39

     EXPLANATION:  The DIGITAL Fortran RTL I/O system detected an
     error condition during execution of a READ statement.

  o  MESSAGE:  Error during write

     NUMBER:  38

     EXPLANATION:  The DIGITAL Fortran RTL I/O system detected an
     error condition during execution of a WRITE statement.

  o  MESSAGE:  File name specification error

     NUMBER:  43

     EXPLANATION:  The file name was specified erroneously.

  o  MESSAGE:  File not found

     NUMBER:  29

     EXPLANATION:  A file with the specified name could not be found
     during an open operation.

  o  MESSAGE:  FIND error

     NUMBER:  57

     EXPLANATION:  The DIGITAL Fortran RTL I/O system detected an
     error condition during execution of a FIND statement.

  o  MESSAGE:  Floating inexact

     NUMBER:  140

     EXPLANATION:  A floating-point arithmetic or conversion
     operation gave a result that differs from the mathematically
     exact result.  This trap is reported if the rounded result of
     an IEEE operation is not exact.

  o  MESSAGE:  Floating overflow in math library

     NUMBER:  88

     EXPLANATION:  A floating-point overflow condition was detected
     during execution of a math library procedure.

  o  MESSAGE:  Floating underflow in math library

     NUMBER:  89

     EXPLANATION:  A floating-point underflow condition was detected
     during execution of a math library procedure.  The result
     returned was zero.

  o  MESSAGE:  Format/variable-type mismatch

     NUMBER:  61

     EXPLANATION:  An attempt was made either to read or write a
     real variable with an integer field descriptor (I, L, B, O, or
     Z), or to read or write an integer or logical variable with a
     real field descriptor (D, E, F, or G).

  o  MESSAGE:  Formatted I/O to unit open for unformatted transfers

     NUMBER:  257

     EXPLANATION:  Attempted formatted I/O (such as list-directed or
     namelist I/O) to a unit where the OPEN statement indicated the
     file was unformatted (FORM keyword).  Check that the correct
     unit (file) was specified.

     If the FORM keyword was not specified in the OPEN statement and
     the file should contain formatted data, specify
     FORM='FORMATTED' in the OPEN statement.  Otherwise, if
     appropriate, use unformatted I/O.

  o  MESSAGE:  Inconsistent file organization

     NUMBER:  51

     EXPLANATION:  The file organization specified in an OPEN
     statement did not match the organization of the existing file.

  o  MESSAGE:  Inconsistent OPEN/CLOSE parameters

     NUMBER:  46

     EXPLANATION:  Specifications in an OPEN or CLOSE statement were
     inconsistent.  Some invalid combinations follow:

        - READONLY with STATUS='NEW' or STATUS='SCRATCH'

        - ACCESS='APPEND' with READONLY, STATUS='NEW' or
          STATUS='SCRATCH'

        - DISPOSE='SAVE', 'PRINT', or 'SUBMIT' with
          STATUS='SCRATCH'

        - DISPOSE='DELETE' with READONLY

  o  MESSAGE:  Inconsistent record length

     NUMBER:  37

     EXPLANATION:  One of the following conditions occurred:

      o  An attempt was made to create a new relative or direct
         access file without specifying a record length.

      o  An existing file was opened in which the record length did
         not match the record size given in an OPEN or DEFINE FILE
         statement.

      o  An attempt was made to write to a relative or direct access
         file that was not correctly created or opened.


  o  MESSAGE:  Inconsistent record type

     NUMBER:  44

     EXPLANATION:  The RECORDTYPE value in an OPEN statement did not
     match the record type attribute of the existing file that was
     opened.

  o  MESSAGE:  Infinite format loop

     NUMBER:  60

     EXPLANATION:  The format associated with an I/O statement that
     included an I/O list had no field descriptors to use in
     transferring those values.

  o  MESSAGE:  Input conversion error

     NUMBER:  64

     EXPLANATION:  During a formatted input operation, an invalid
     character was detected in an input field, or the input value
     overflowed the range representable in the input variable.  The
     value of the variable was set to zero.

  o  MESSAGE:  Input record too long

     NUMBER:  22

     EXPLANATION:  A record was read that exceeded the explicit or
     default record length specified when the file was opened.  To
     read the file, use an OPEN statement with a RECL value (record
     length) of the appropriate size.  The RECL unit is bytes for
     formatted files and longwords for unformatted files.

  o  MESSAGE:  Input statement requires too much data

     NUMBER:  67

     EXPLANATION:  An unformatted READ statement attempted to read
     more data than existed in the record being read.

  o  MESSAGE:  Insufficient virtual memory

     NUMBER:  41

     EXPLANATION:  The DIGITAL Fortran RTL attempted to exceed its
     available virtual memory while dynamically allocating space.
     To overcome this problem, increase the per-process data limit
     by using the limit (C shell) or ulimit (Bourne and Korn shell)
     commands before you run this program again (see your user
     manual).

     Determine whether the maximum per-process data size is already
     allocated by checking the value of the maxdsiz parameter in the
     system configuration or sysconfigtab file.  If necessary,
     increase its value.  Changes do not take effect until the
     system has been rebooted.  (You do not need to rebuild the
     kernel if you modify sysconfigtab.)

     For more information about system configuration parameters, see
     the "DIGITAL UNIX System Tuning and Performance Management"
     guide.

     Before you try to run this program again, wait until the new
     system resources take effect.

  o  MESSAGE:  Integer overflow

     NUMBER:  70

     EXPLANATION:  During an arithmetic operation, an integer value
     exceeded byte, word, or longword range.  The result of the
     operation was the correct low-order part.  Consider specifying
     a larger integer data size.  (Modify the source program or, for
     an INTEGER declaration, possibly use the f77 flag -integer_size
     nn).

     For ranges of the various integer data types, see your user
     manual.

  o  MESSAGE:  Integer divide by zero

     NUMBER:  71

     EXPLANATION:  During an integer arithmetic operation, an
     attempt was made to divide by zero.  The result of the
     operation was set to the dividend, which is equivalent to
     division by 1.

  o  MESSAGE:  Internal consistency check failure

     NUMBER:  8

     EXPLANATION:  Internal error.  Please check that the program is
     correct.  Recompile if an error exists in the program.

     If this error persists, submit an SPR.

  o  MESSAGE:  Invalid argument to Fortran Run-Time Library

     NUMBER:  48

     EXPLANATION:  The compiler passed an invalid or improperly
     coded argument to the DIGITAL Fortran RTL.  This can occur if
     the compiler is newer than the RTL in use.

  o  MESSAGE:  Invalid argument to math library

     NUMBER:  81

     EXPLANATION:  One of the mathematical procedures detected an
     invalid argument value.

  o  MESSAGE:  Invalid logical unit number

     NUMBER:  32

     EXPLANATION:  A logical unit number greater than 2,147,483,647
     or less than zero was used in an I/O statement.

  o  MESSAGE:  Invalid reference to variable in NAMELIST input

     NUMBER:  19

     EXPLANATION:  One of the following conditions occurred:

        - The variable was not a member of the namelist group.

        - An attempt was made to subscript a scalar variable.

        - A subscript of the array variable was out-of-bounds.

        - An array variable was specified with too many or too 
          few subscripts for the variable. 

        - An attempt was made to specify a substring of a non-
          character variable or array name.

        - A substring specifier of the character variable was 
          out-of-bounds.

        - A subscript or substring specifier of the variable was 
          not an integer constant.

        - An attempt was made to specify a substring using an 
          unsubscripted array variable. 

  o  MESSAGE:  Kernel breakpoint (SIGTRAP)

     NUMBER:  131

     EXPLANATION:  Break exception generated a SIGTRAP signal
     (described in signal(3)).  Core dump file created.

     Examine core dump for possible cause.

  o  MESSAGE:  Keyword value error in OPEN statement

     NUMBER:  45

     EXPLANATION:  An improper value was specified for an OPEN or
     CLOSE statement keyword requiring a value.

  o  MESSAGE:  List-directed I/O syntax error

     NUMBER:  59

     EXPLANATION:  The data in a list-directed input record had an
     invalid format, or the type of the constant was incompatible
     with the corresponding variable.  The value of the variable was
     unchanged.

  o  MESSAGE:  Logarithm of zero or negative value

     NUMBER:  83

     EXPLANATION:  An attempt was made to take the logarithm of zero
     or a negative number.  The result returned was the reserved
     operand, -0.

  o  MESSAGE:  Mixed file access modes

     NUMBER:  31

     EXPLANATION:  An attempt was made to use any of the following
     combinations:

        - Formatted and unformatted operations on the same unit

        - An invalid combination of access modes on a unit, 
          such as direct and sequential

        - A DIGITAL Fortran RTL I/O statement on a logical unit that 
          was opened by a program coded in another language

  o  MESSAGE:  No current record

     NUMBER:  53

     EXPLANATION:  An attempt was made to REWRITE a record when the
     current record was undefined.  To define the current record,
     execute a successful READ statement.  You can optionally
     perform an INQUIRE statement on the logical unit after the READ
     statement and before the REWRITE statement.  No other
     operations on the logical unit can be performed between the
     READ and REWRITE statements.

  o  MESSAGE:  No such device

     NUMBER:  42

     EXPLANATION:  A pathname included an invalid or unknown device
     name when an OPEN operation was attempted.

  o  MESSAGE:  Not a Fortran-specific error

     NUMBER:  1

     EXPLANATION:  An error occurred in the user program or in the
     RTL that was not a DIGITAL Fortran-specific error and was not
     reportable through any other DIGITAL Fortran run-time messages.

  o  MESSAGE:  Not taken branch delay emulation (SIGTRAP)

     NUMBER:  134

     EXPLANATION:  Break exception generated a SIGTRAP signal
     (described in signal(3)).  Core dump file created.

     Examine core dump for possible cause.

  o  MESSAGE:  OPEN or DEFINE FILE required

     NUMBER:  26

     EXPLANATION:  A direct access READ, WRITE, or FIND, statement
     was attempted for a file when no DEFINE FILE or OPEN statement
     with ACCESS='DIRECT' was performed for that file.

  o  MESSAGE:  Open failure

     NUMBER:  30

     EXPLANATION:  An error was detected by the DIGITAL Fortran RTL
     I/O system while attempting to open a file in an OPEN, INQUIRE,
     or other I/O statement.  This message is issued when the error
     condition is not one of the more common conditions for which
     specific error messages are provided.  It can occur if an OPEN
     operation is attempted for one of the following files:

        - A segmented file that was not on a disk or a raw 
          magnetic tape.
        - A standard I/O file that had been closed.

  o  MESSAGE:  Operation requires seek ability

     NUMBER:  120

     EXPLANATION:  Attempted an operation on a file that requires
     the ability to perform seeks on that file.  Make sure the
     correct unit, directory path, and file were specified.

  o  MESSAGE:  Output statement overflows record

     NUMBER:  66

     EXPLANATION:  An output statement attempted to transfer more
     data than would fit in the maximum record size.

  o  MESSAGE:  Overflow check (SIGTRAP)

     NUMBER:  136

     EXPLANATION:  Break exception generated a SIGTRAP signal
     (described in signal(3)).  Core dump file created.

     The cause is an integer overflow.  Try recompiling using the
     -check overflow option (perhaps with the f77_dump_flag
     environment variable set) or examine the core dump file to
     determine the source code in error.

  o  MESSAGE:  Pathname error

     NUMBER:  43

     EXPLANATION:  A pathname (or file name) given to an OPEN or
     INQUIRE statement was not acceptable to the DIGITAL Fortran RTL
     I/O system.

  o  MESSAGE:  Permission to access file denied, unit x, file xxx

     NUMBER:  9

     EXPLANATION:  Check the mode (protection) of the specified
     file.  Make sure the correct file was being accessed.  Change
     the protection, specified file, or process used before
     rerunning program.

  o  MESSAGE:  Range error

     NUMBER:  150

     EXPLANATION:  An integer value appeared in a context where the
     value of the integer is outside the permissible range.

  o  MESSAGE:  Record number outside range

     NUMBER:  25

     EXPLANATION:  A direct access READ, WRITE, or FIND statement
     specified a record number outside the range specified when the
     file was opened.

  o  MESSAGE:  Recursive I/O operation

     NUMBER:  40

     EXPLANATION:  While processing an I/O statement for a logical
     unit, another I/O operation on the same logical unit was
     attempted, such as a function subprogram that performs I/O to
     the same logical unit was referenced in an expression in an I/O
     list or variable format expression.

  o  MESSAGE:  REWIND error

     NUMBER:  20

     EXPLANATION:  One of the following conditions occurred:

        - The file was not a sequential file.

        - The file was not opened for sequential or append access.

        - The DIGITAL Fortran RTL I/O system detected an error condition  
          during execution of a REWIND statement. 

  o  MESSAGE:  Segmented record format error

     NUMBER:  35

     EXPLANATION:  An invalid segmented record control data word was
     detected in an unformatted sequential file.  The file was
     probably either created with RECORDTYPE='FIXED' or 'VARIABLE'
     in effect, or was created by a program written in a language
     other than Fortran.

  o  MESSAGE:  Significance lost in math library

     NUMBER:  87

     EXPLANATION:  The magnitude of an argument or the magnitude of
     the ratio of the arguments to a math library function was so
     large that all significance in the result was lost.  The result
     returned was the reserved operand, -0.

  o  MESSAGE:  Square root of negative value

     NUMBER:  84

     EXPLANATION:  An argument required the evaluation of the square
     root of a negative value.  The result returned was the reserved
     operand, -0.

  o  MESSAGE:  String length error

     NUMBER:  148

     EXPLANATION:  During a string operation, an integer value
     appeared in a context where the value of the integer is outside
     the permissible string length range.  Try recompiling with the
     -check bounds flag (perhaps with the f77_dump_flag environment
     variable set) or examine the core file to determine the source
     code causing the error.

  o  MESSAGE:  Subscript out of range

     NUMBER:  77

     EXPLANATION:  An array reference was detected outside the
     declared array bounds.

  o  MESSAGE:  Substring error

     NUMBER:  149

     EXPLANATION:  An array subscript is outside the dimensioned
     boundaries of an array.  Try recompiling with the -check bounds
     flag (perhaps with the f77_dump_flag environment variable set)
     or examine the core file to determine the source code causing
     the error.

  o  MESSAGE:  Syntax error in format

     NUMBER:  62

     EXPLANATION:  A syntax error was encountered while the RTL was
     processing a format stored in an array or character variable.

  o  MESSAGE:  Syntax error in NAMELIST input

     NUMBER:  17

     EXPLANATION:  The syntax of input to a namelist READ statement
     was incorrect.

  o  MESSAGE:  Taken branch delay emulation (SIGTRAP)

     NUMBER:  133

     EXPLANATION:  Break exception generated a SIGTRAP signal
     (described in signal(3)).  Core dump file created.

     Examine core dump for possible cause.

  o  MESSAGE:  Too many records in I/O statement

     NUMBER:  27

     EXPLANATION:  An attempt was made to do one of the following:

        - Read or write more than one record with an ENCODE
          or DECODE statement.
        - Write more records than existed.

  o  MESSAGE:  Too many values for NAMELIST variable

     NUMBER:  18

     EXPLANATION:  An attempt was made to assign too many values to
     a variable during a namelist READ statement.

  o  MESSAGE:  Undefined exponentiation

     NUMBER:  82

     EXPLANATION:  An exponentiation that is mathematically
     undefined was attempted, for example, 0.**0.  The result
     returned for floating-point operations was the reserved
     operand, -0, and for integer operations, zero.

  o  MESSAGE:  Unformatted I/O to unit open for formatted transfers

     NUMBER:  256

     EXPLANATION:  Attempted unformatted I/O to a unit where the
     OPEN statement indicated the file was formatted (FORM keyword).
     Check that the correct unit (file) was specified.

     If the FORM keyword was not specified in the OPEN statement and
     the file should contain unformatted data, specify
     FORM='UNFORMATTED' in the OPEN statement.  Otherwise, if
     appropriate, use formatted I/O (such as list-directed or
     namelist I/O).

  o  MESSAGE:  Unit already open

     NUMBER:  34

     EXPLANATION:  A DEFINE FILE statement specified a logical unit
     that was already opened.

  o  MESSAGE:  User breakpoint (SIGTRAP)

     NUMBER:  130

     EXPLANATION:  Break exception generated a SIGTRAP signal
     (described in signal(3)).  Core dump file created.

     Examine core dump for possible cause.

  o  MESSAGE:  User single step (SIGTRAP)

     NUMBER:  135

     EXPLANATION:  Break exception generated a SIGTRAP signal
     (described in signal(3)).  Core dump file created.

     Examine core dump for possible cause.

  o  MESSAGE:  Variable format expression value error

     NUMBER:  68

     EXPLANATION:  The value of a variable format expression was not
     within the range acceptable for its intended use; for example,
     a field width was less than or equal to zero.  A value of 1 was
     assumed, except for a P edit descriptor, for which a value of
     zero was assumed.

  o  MESSAGE:  Write to READONLY file

     NUMBER:  47

     EXPLANATION:  A write operation was attempted to a file that
     was declared READONLY in the OPEN statement that is currently
     in effect.

  o  MESSAGE:  Wrong number of arguments

     NUMBER:  80

     EXPLANATION:  An improper number of arguments was used to call
     a math library procedure.

3 Error_Messages
 Should be corrected.  The program may continue execution, but the
 output from this execution may be incorrect.

 The error messages follow (in alphabetical order):

  o  MESSAGE:  Floating divide by zero

     NUMBER:  73

     EXPLANATION:  During a floating-point arithmetic operation, an
     attempt was made to divide by zero.

  o  MESSAGE:  Floating invalid

     NUMBER:  65

     EXPLANATION:  During an arithmetic operation, the
     floating-point values used in a calculation were invalid for
     the type of operation requested, or invalid exceptional values.
     For example, this occurs when requesting a log of the
     floating-point values 0.0 or a negative number.

     For certain arithmetic expressions, specifying the -check
     nopower option can suppress this message.  For information on
     allowing exceptional IEEE values, see your user manual.

  o  MESSAGE:  Floating overflow

     NUMBER:  72

     EXPLANATION:  During an arithmetic operation, a floating-point
     value exceeded the largest representable value for that data
     type.  For ranges of the various data types, see your user
     manual.

  o  MESSAGE:  Floating point exception

     NUMBER:  75

     EXPLANATION:  A floating-point exception occurred.  Core dump
     file created.  Possible causes include:

      o  Divide by zero

      o  Overflow

      o  An invalid operation, such as subtraction of infinite
         values, multiplication of zero by infinity (without signs),
         division of zero by zero or infinity by infinity

      o  Conversion of floating-point to fixed-point format when an
         overflow prevents conversion


  o  MESSAGE:  Floating underflow

     NUMBER:  74

     EXPLANATION:  During an arithmetic operation, a floating-point
     value became less than the smallest finite value for that data
     type.  On Alpha systems, the underflowed result is set to zero.
     For ranges of the various data types, see the Data
     Representation chapter in your user manual.

  o  MESSAGE:  Fortran abort routine called

     NUMBER:  266

     EXPLANATION:  The program called abort to terminate the
     program.

  o  MESSAGE:  IOT trap signal

     NUMBER:  76

     EXPLANATION:  Core dump file created.  Examine core dump for
     possible cause of this IOT signal.

  o  MESSAGE:  Output conversion error

     NUMBER:  63

     EXPLANATION:  During a formatted output operation, the value of
     a particular number could not be output in the specified field
     length without loss of significant digits.  When this situation
     is encountered, the field is filled with asterisks.

  o  MESSAGE:  Process interrupted (SIGINT)

     NUMBER:  69

     EXPLANATION:  The process received the signal SIGINT.
     Determine source of this interrupt signal (described in
     signal(3)).

  o  MESSAGE:  Process killed (SIGTERM)

     NUMBER:  78

     EXPLANATION:  The process received the signal SIGTERM.
     Determine source of this software termination signal (described
     in signal(3)).

  o  MESSAGE:  Process quit (SIGQUIT)

     NUMBER:  79

     EXPLANATION:  The process received the signal SIGQUIT.  Core
     dump file created.  Determine source of this quit signal
     (described in signal(3)).

3 Warning_Messages
 Should be investigated.  The program continues execution, but the
 output from this execution may be incorrect.

 The warning messages follow (in alphabetical order):

  o  MESSAGE:  Could not open message catalog:  formsg.cat

     NUMBER:  none

     EXPLANATION:  The DIGITAL Fortran message catalog file was not
     found on this system.  For more information, see your user
     manual or installation guide.

3 Informational_Messages
 For informational purposes only.  Unless it accompanies another
 message, the program continues.

 The informational messages follow (in alphabetical order):

  o  MESSAGE:  Check environment variable NLSPATH and protection of
     path-name/for_msg.dat

     NUMBER:  none

     EXPLANATION:  The DIGITAL Fortran message catalog file was not
     found on this system.  For more information, see your user
     manual or your installation guide.

  o  MESSAGE:  Check location/protection of NLS and
     /usr/lib/formsg.dat

     NUMBER:  none

     EXPLANATION:  The DIGITAL Fortran message file was not found on
     this system.  See your user manual for more information.

  o  MESSAGE:  nn floating divide-by-zero traps

     NUMBER:  299

     EXPLANATION:  The total number of floating-point divide-by-zero
     traps encountered during program execution was nn.  This
     summary message appears at program completion.

  o  MESSAGE:  nn floating invalid traps

     NUMBER:  297

     EXPLANATION:  The total number of floating-point invalid data
     traps encountered during program execution was nn.  This
     summary message appears at program completion.

  o  MESSAGE:  nn floating overflow traps

     NUMBER:  298

     EXPLANATION:  The total number of floating-point overflow traps
     encountered during program execution was nn.  This summary
     message appears at program completion.

  o  MESSAGE:  Floating-point conversion failed

     NUMBER:  95

     EXPLANATION:  The attempted unformatted read or write of
     non-native floating-point data failed.  One of the following
     conditions occurred for a non-native floating-point value:

      o  The value exceeded the allowable maximum value for the
         equivalent native format and was set equal to infinity
         (plus or minus).

      o  The value was infinity (plus or minus) and was set to
         infinity (plus or minus).

      o  The value was invalid and set to Not-a-Number (NaN).


     Make sure the correct file was specified.  Make sure the record
     layout matches the format DIGITAL Fortran is expecting.  Check
     that the correct non-native floating-point data format was
     specified, as described in your user manual.

  o  MESSAGE:  nn floating underflow traps

     NUMBER:  300

     EXPLANATION:  The total number of floating-point underflow
     traps encountered during program execution was nn.  This
     summary message appears at program completion.

  o  MESSAGE:  Format syntax error at or near xx

     NUMBER:  58

     EXPLANATION:  Check the statement containing xx, a character
     substring from the format string, for a format syntax error.
     For information about FORMAT statements, refer to the language
     reference manual.

  o  MESSAGE:  Fortran error message number is nnn

     NUMBER:  none

     EXPLANATION:  The DIGITAL Fortran message catalog file was not
     found on this system.  For information about the message
     catalog file location, see your user manual or installation
     guide.

  o  MESSAGE:  Unit not connected

     NUMBER:  11

     EXPLANATION:  The specified unit was not open at the time of
     the attempted I/O operation.  Check to see if the correct unit
     number was specified.  If appropriate, use an OPEN statement to
     explicitly open the file (associates the file with the unit
     number).

2 Format_Specifiers       
 A format appearing in an input or output (I/O) statement specifies
 the form of data being transferred and the data conversion
 (editing) required to achieve that form.  The format specified can
 be explicit or implicit.

 Explicit format is indicated in a format specification that appears
 in a FORMAT statement or a character expression (the expression
 must evaluate to a valid format specification).

 The format specification contains edit descriptors, which can be
 data edit descriptors, control edit descriptors, or string edit
 descriptors.

 Implicit format is determined by the processor and is specified
 using list-directed or namelist formatting.

 List-directed formatting is specified with an asterisk (*);
 namelist formatting is specified with a namelist group name.

 List-directed formatting can be specified for advancing, sequential
 files and internal files.  Namelist formatting can be specified
 only for advancing, sequential files.
3 Default_Data_Descriptors   

 The defaults for data edit descriptors follow:

 Field        
 Descriptor    List Element                       w      d    e
 --------------------------------------------------------------
 I,B,O,Z,G     BYTE,INTEGER*1,LOGICAL*1           7
 I,B,O,Z,G     INTEGER*2,LOGICAL*2                7
 I,B,O,Z,G     INTEGER*4,LOGICAL*4               12
 I,B,O,Z,G     INTEGER*8,LOGICAL*8               23
 O,Z           REAL*4                            12
 O,Z           REAL*8                            23
 O,Z           REAL*16                           44
 O,Z           CHARACTER*n                     MAX(7,3*n)
 L,G           LOGICAL*1,LOGICAL*2,               2
               LOGICAL*4,LOGICAL*8
 F,E,EN,ES,G,D REAL*4,COMPLEX*8                  15      7    2
 F,E,EN,ES,G,D REAL*8,COMPLEX*16                 25     16    2
 F,E,EN,ES,G,D REAL*16                           42     33    3
 A,G           LOGICAL*1                          1
 A,G           LOGICAL*2,INTEGER*2                2
 A,G           LOGICAL*4,INTEGER*4                4
 A,G           LOGICAL*8,INTEGER*8                8
 A,G           REAL*4,COMPLEX*8                   4
 A,G           REAL*8,COMPLEX*16                  8
 A,G           REAL*16                           16
 A,G           CHARACTER*n                        n
3 General_Form      
 The general form of a FORMAT statement follows:

    FORMAT (q1 f1s1 f2s2 ... fnsn qn)

    qn   Is zero or more slash (/) record terminators.

    fn   Is a data edit descriptor, a control edit descriptor, or
         a group of data or control edit descriptors enclosed
         in parentheses.

    sn   Is a field separator (a comma or slash).  A
         comma can be omitted in the following cases:

         o Between a P edit descriptor and an immediately 
           following F, E, EN, ES, D, or G edit descriptor.

         o Before a slash (/) record terminator (if there is
           no optional repeat specification)

         o After a slash (/) record terminator.

         o Before or after a colon (:) edit descriptor.

 In data transfer I/O statements, a format specifier ([FMT=]format)
 can be a character expression that is a character array, character
 array element, or character constant.  This type of format is also
 called a run-time format because it can be constructed or altered
 during program execution.

 The expression must evaluate to a character string whose leading
 part is a valid format specification (including the enclosing
 parentheses).  Variable format expressions must not appear in this
 kind of format specification.
4 Data_Edit_Format  
 A data edit descriptor takes one of the following forms:

    [r]c  [r]cw  [r]cw.m  [r]cw.d [r]cw.d[Ee]

    r    Is an optional repeat count.  (If you omit "r", 
         the repeat count is assumed to be 1.)

    c    Is a format code (I,B,O,Z,F,E,EN,ES,D,G,L, or A).

    w    Is the total number of digits in the field (the
         field width).

    m    Is the minimum number of digits that must appear 
         in the field (including leading zeros).

    d    Is the number of digits to the right of the decimal point.

    E    Identifies an exponent field.

    e    Is the number of digits in the exponent.

 The ranges for "r", "w", "m", "d", and "e" are as follows:

 Term      Range                 
 ----      __________                 
  r        1 to 2147483647 (2**31-1)  
  w        1 to 2147483647            
  m        0 to 32767 (2**15-1)       
  d        0 to 32767                 
  e        1 to 32767                 

 The terms must all be positive, unsigned, default integer constants
 or variable format expressions.

 You cannot use PARAMETER constants for "r", "w", "m", "d", or "e".
4 Control_Edit_Format  
 A control edit descriptor takes one of the following forms:

    c  nc  cn
   
    c     Is a format code (X, T, TL, TR, SP, SS, S, BN, BZ,
          P, /, '...', "...", Q, \, $, or :).

    n     Is the optional number of character positions.

 The term "n" must be a positive, unsigned, default integer constant
 or a variable format expression.

 For all format codes (except P), the value of "n" must be within
 the range 1 through 2147483647 (2**31-1); actual useful ranges may
 be constrained by record sizes (RECL) and the file system.

 The P edit descriptor is an exception to the general control edit
 descriptor syntax.  It is preceded by a scale factor, rather than a
 character position specifier.  The value of "n" for P must be
 within the range -128 to 127.

 Control edit descriptors can be grouped in parentheses and preceded
 by a group repeat specification.
4 Character_String_Format
 The character string edit descriptors are the character constant
 and H edit descriptor.

 The character constant edit descriptor ('string' or "string")
 causes string to be output to an external record.  (For more
 information on the H edit descriptor, see FORMAT H in online Help.)

 Although no string edit descriptor can be preceded by a repeat
 specification, a parenthesized group of string edit descriptors can
 be preceded by a repeat specification.
3 Format_Descriptors        
 A format descriptor can be one of the following:

  o  Data edit descriptor

     Causes the transfer or conversion of data to or from its
     internal representation.  The part of a record that is input or
     output and formatted with data edit descriptors a field.

     The data edit descriptors are:  I, B, O, Z, F, E, EN, ES, D, G,
     L, and A.

  o  Control edit descriptor

     Either directly determines how text is displayed or affects the
     conversions performed by subsequent data edit descriptors.

     The control edit descriptors are:  T, TL, TR, X, S, SP, SS, BN,
     BZ, P, :, /, $, and Q.

  o  String edit descriptor

     Controls the output of character strings.  The string edit
     descriptors are the character constant and H edit descriptor.


 Format descriptors are generally separated by commas, but you can
 also use the slash (/) edit descriptor to separate them.  A slash
 terminates input or output of the current record and initiates a
 new record; for example:

         WRITE (6,40) K,L,M,N,O,P
    40   FORMAT (3I6.6/I6,2F8.4)

 The preceding statements are equivalent to the following:

         WRITE (6,40) K,L,M
    40   FORMAT (3I6.6)
         WRITE (6,50) N,O,P
    50   FORMAT (I6,2F8.4)

 Multiple slashes cause the system to bypass input records or output
 blank records.  If "n" consecutive slashes appear between two field
 or edit descriptors, (n-1) records are skipped on input, or (n-1)
 blank records are output.  The first slash terminates the current
 record.  The second slash terminates the first skipped or blank
 record, and so on.

 However, "n" slashes at the beginning or end of a format
 specification result in "n" skipped or blank records.  This is
 because the opening and closing parentheses of the format
 specification are themselves a record initiator and terminator,
 respectively.
3 Nested_and_Group_Repeats               
 Format specifications can include nested format specifications
 enclosed in parentheses; for example:

   15   FORMAT (E7.2,I8,I2,(A5,I6))     

   35   FORMAT (A6,(L8(3I2)),A)

 A group repeat specification can precede a nested group of edit
 descriptors.  For example, the following statements are equivalent,
 and the second statement shows a group repeat specification:

   50   FORMAT (I8,I8,F8.3,E15.7,F8.3,E15.7,F8.3,E15.7,I5,I5)

   50   FORMAT (2I8,3(F8.3,E15.7),2I5)

 If a nested group does not show a repeat count, a default count of
 1 is assumed.

 Normally, the string edit descriptors and control edit descriptors
 cannot be repeated (except for slash), but any of these descriptors
 can be enclosed in parentheses and preceded by a group repeat
 specification.  For example, the following statements are valid:

   76   FORMAT ('MONTHLY',3('TOTAL'))

   100  FORMAT (I8,4(T7),A4)
3 Reversion                  
 When the last closing parenthesis of the format specification is
 reached, format control determines whether more I/O list elements
 are to be processed.  If not, format control terminates.  However,
 if additional list elements remain, part or all of the format
 specification is reused in a process called format reversion.

 In format reversion, the current record is terminated, a new one is
 initiated, and format control reverts to the group repeat
 specification whose opening parenthesis matches the next-to-last
 closing parenthesis of the format specification.  If the format
 does not contain a group repeat specification, format control
 returns to the initial opening parenthesis of the format
 specification.  Format control continues from that point.
3 Variable_Format_Expressions
 By enclosing an expression in angle brackets, you can use it in a
 FORMAT statement wherever you can use an integer (except as the
 specification of the number of characters in the H field).  For
 example:

    20 FORMAT (I<J+1>)

 When the format is scanned, the preceding statement performs an I
 (integer) data transfer with a field width of J+1.  The expression
 is reevaluated each time it is encountered in the normal format
 scan.

 The following rules apply to variable format expressions:

    - If the expression is not of integer data type, it is 
      converted to integer data type before being used.

    - The expression can be any valid Fortran expression, 
      including function calls and references to dummy arguments.

    - The value of a variable format expression must obey the
      restrictions on magnitude applying to its use in the 
      format, or an error occurs.

    - Variable format expressions are not permitted in run-time 
      formats.

 Variable format expressions are evaluated each time they are
 encountered in the scan of the format.  If the value of the
 variable used in the expression changes during the execution of the
 I/O statement, the new value is used the next time the format item
 containing the expression is processed.
3 Data_Edit                 
 The specific forms for data edit descriptors follow:

   +-----------------------------------+
   |      Function      |  Format      |
   +--------------------+--------------+
   | Integer            | Iw[.m]       |
   | Binary             | Bw[.m]       |
   | Octal              | Ow[.m]       |
   | Hexadecimal        | Zw[.m]       |
   | Real number        | Fw.d         |
   | Exponential form   | Ew.d[Ee]     |
   | D exponential form | Dw.d         |
   | G exponential form | Gw.d[Ee]     |
   | Scientific form    | ESw.d[Ee]    |
   | Engineering form   | ENw.d[Ee]    |
   | Logical            | Lw           |
   | Character          | A[w]         |
   +--------------------+--------------+

 NOTE:  Transfer complex numbers as two real (F, E, ES, 
        EN, D, or G) numbers.
3 Control_Edit              
 The specific forms for control edit descriptors follow:

   +--------------------------+--------------+
   |         Function         |    Format    |
   +--------------------------+--------------+
   | Scale factor             | kP           |
   | Blanks are null (input)  | BN           |
   | Blanks are zero (input)  | BZ           |
   | Characters in input      | Q            |
   | Plus sign (always)       | SP           |
   | Plus sign (never)        | SS           |
   | Default plus sign        | S            |
   | Skip spaces (same as TRn)| nX           |
   | Position (Tab)           | Tn           |
   | Relative left tab        | TLn          |
   | Relative right tab       | TRn          |
   | Carriage control         | $ or \       |
   | Terminate list           | :            |
   | Terminate record         | /            |
   +--------------------------+--------------+
3 String_Edit               
 The specific forms for string edit descriptors follow:

   +--------------------------+--------------+
   |         Function         |    Format    |
   +--------------------------+--------------+
   | Character constant       |  'string'    |
   |                          |      or      |
   |                          |  "string"    |
   | Hollerith                |  nHstring    |
   +--------------------------+--------------+
3 Carriage_Control          
 When the first character of a formatted record is transferred to an
 output file or printer, it can be interpreted as a carriage control
 character (and not printed) if the file is opened with
 CARRIAGECONTROL='FORTRAN' in effect.

 The I/O system recognizes the characters listed below as carriage
 control characters and does not print them.

    Character    Meaning
    ---------    -----------------------------------------
      '+'        Overprinting: Outputs the record (at the 
                 current position in the current line) and 
                 a carriage return.

      ' '        One line feed: Outputs the record (at the 
                 beginning of the following line) and a 
                 carriage return.

      '0'        Two line feeds: Outputs the record (after 
                 skipping a line) and a carriage return.

      '1'        Next page: Outputs the record (at the 
                 beginning of a new page) and a carriage return.

      '$'        Prompting: Outputs the record (at the 
                 beginning of the following line), but no 
                 carriage return.

    ASCII NULL   Overprinting with no advance: Outputs 
                 the record (at the current position in the 
                 current line), but no carriage return.
                 (ASCII NULL is specified as CHAR(0).)

 Any other character is interpreted as a blank and is deleted from
 the print line.  If you accidentally omit a carriage control
 character, the first character of the record is not printed.
3 $_or_\                          
 In a format specification, the dollar sign ($) and backslash (\)
 characters modify the carriage control specified by the first
 character of the record.  They only affect carriage control for
 formatted files, and have no effect on input.

 If the first character of the record is a blank or a plus sign (+)
 the dollar sign and backslash descriptors suppress carriage return
 (after printing the record).

 For terminal device I/O, when this trailing carriage return is
 suppressed, a response follows output on the same line.

 If the first character of the record is 0, 1, or ASCII NUL, the
 dollar sign and backslash descriptors have no effect.
3 :                          
 Terminates format control if no more items are in the I/O list.

 If I/O list items remain, the colon edit descriptor has no effect.
3 A                         
 A[w] (Character Editing)

 If the corresponding I/O list element has a character data type,
 character data is transmitted.  If it has any other data type,
 Hollerith data is transmitted.  The value of "w" must be less than
 or equal to 2**31-1.

 The G edit descriptor can be used to edit character data; it
 follows the same rules as Aw.

 On input, the A edit descriptor transfers "w" characters or
 Hollerith values from the external record and assigns them to the
 corresponding list element.  If the input value contains fewer
 characters than "w", it is padded on the right with blanks.  If the
 input value contains excessive characters, it is truncated on the
 left.

 If the variable is numeric, the ASCII value of each character is
 placed in each byte of the variable, starting at the low-order
 byte.

 On output, the A edit descriptor transfers the contents of the
 corresponding I/O list element to an external field "w" characters
 long.  If the output value contains fewer characters than "w", it
 is padded on the left with blanks.  If the output value contains
 excess characters, it is truncated on the right (for numbers, the
 high-order bytes are lost).

 If the output value is numeric or untyped, the ASCII value of each
 byte of the variable, starting at the low-order byte, is
 transferred to the record.

 The "w" can be omitted and defaults to the number of characters in
 the character variable or the number of bytes in the numeric
 variable.
3 BN                        
 (Blank Control Editing)

 Causes embedded and trailing blanks to be ignored within a numeric
 input field.  Leading blanks are always ignored, and an all blank
 field is always treated as zero.

 It affects all subsequent I, B, O, Z, F, E, EN, ES, D, and G
 editing (in the same FORMAT statement) until another blank editing
 descriptor occurs.

 The BN and BZ descriptors supersede the default interpretation of
 blanks during execution of a particular input data transfer
 statement.
3 BZ                         
 (Blank Control Editing)

 Causes embedded and trailing blanks to be treated as zeros within a
 numeric input field.  (Leading blanks are always ignored.) An
 all-blank field is treated as zero.

 It affects all subsequent I, B, O, Z, F, E, EN, ES, D, and G
 editing (in the same FORMAT statement) until another blank editing
 descriptor occurs.

 The BN and BZ descriptors supersede the default interpretation of
 blanks during execution of a particular input data transfer
 statement.
3 D                         
 Dw.d
 (Exponential Editing)

 On input, D performs the same as F format.

 On output, D performs the same as E format, except that the letter
 D replaces the letter E preceding the exponent and the size of the
 exponent is fixed at 2.
3 E                         
 Ew.d[Ee] (Exponential Editing)

 On input, E performs the same as F format.

 On output, E transfers the value of the corresponding I/O list
 element, rounded to "d" decimal digits and right-justified to an
 external field "w" characters long.  "d" specifies the size of the
 fraction and "e" specifies the size of the exponent.  If the value
 does not fill the field, leading spaces are inserted; if the value
 is too large for the field, the entire field is filled with
 asterisks.

 The term "w" must be large enough to include all of the following:
 a minus sign (when necessary) or a plus sign (if SP editing is in
 effect), a zero, a decimal point, "d" digits, and an exponent.

 Therefore, to accommodate all possible components of the standard
 form, the term "w" must be greater than or equal to "d"+7; if "e"
 is present, "w" must be greater than or equal to "d"+"e"+5.

 However, "w" can be as small as "d"+5 or "d"+"e"+3 and still allow
 formatting of the value without error, if optional fields are
 omitted.  In this case, the sign is omitted (if the value is
 positive and SP editing is not in effect) and the zero to the left
 of the decimal point is also omitted, if necessary.
3 EN                         
 ENw.d[Ee] (Exponential Editing:  Engineering form)

 On input, EN performs the same as F format.

 On output, EN transfers the value of the corresponding I/O list
 element, rounded to "d" decimal digits and right-justified to an
 external field "w" characters long.  The real value is output in
 engineering notation, where the decimal exponent is divisible by 3
 and the absolute value of the significand is greater than or equal
 to 1 and less than 1000 (unless the output value is zero).

 "d" specifies the size of the fraction and "e" specifies the size
 of the exponent.  If the value does not fill the field, leading
 spaces are inserted; if the value is too large for the field, the
 entire field is filled with asterisks.

 The term "w" must be large enough to include all of the following:
 a minus sign (when necessary) or a plus sign (if SP editing is in
 effect), one to three digits, zero, a decimal point, "d" digits,
 and an exponent.

 Therefore, to accommodate all possible components of the standard
 form, the term "w" must be greater than or equal to "d"+9.

 The exponent field width ("e") is optional; if omitted, the default
 is value is 2.  If "e" is specified, the "w" should be greater than
 or equal to "d"+"e"+5.
3 ES                         
 ESw.d[Ee] (Exponential Editing:  Scientific form)

 On input, ES performs the same as F format.

 On output, E transfers the value of the corresponding I/O list
 element, rounded to "d" decimal digits and right-justified to an
 external field "w" characters long.  The real value is output in
 scientific notation, where the absolute value of the significand is
 greater than or equal to 1 and less than 10 (unless the output
 value is zero).

 "d" specifies the size of the fraction and "e" specifies the size
 of the exponent.  If the value does not fill the field, leading
 spaces are inserted; if the value is too large for the field, the
 entire field is filled with asterisks.

 The term "w" must be large enough to include all of the following:
 a minus sign (when necessary) or a plus sign (if SP editing is in
 effect), one digit, a decimal point, "d" digits, and an exponent.

 Therefore, to accommodate all possible components of the standard
 form, the term "w" must be greater than or equal to "d"+7; if "e"
 is present, "w" must be greater than or equal to "d"+"e"+5.

 The exponent field width ("e") is optional; if omitted, the default
 is value is 2.  If "e" is specified, the "w" should be greater than
 or equal to "d"+"e"+5.
3 F                         
 Fw.d (Fixed Floating Editing)

 On input, F transfers "w" characters from the external field and
 assigns them, as a real value, to the corresponding I/O list
 element (which must be real data type).  If the first nonblank
 character of the external field is a minus sign, the field is
 treated as a negative value.  If the first nonblank character is a
 plus sign or if no sign appears in the field, the field is treated
 as a positive value.

 If the field contains neither a decimal point nor an exponent, it
 is treated as a real number of "w" digits, in which the rightmost
 "d" digits are to the right of the decimal point, with leading
 zeros assumed if necessary.  If the field contains an explicit
 decimal point, the location of the decimal point overrides the
 location specified by the field descriptor.  If the field contains
 an exponent, that exponent is used to establish the magnitude of
 the value before it is assigned to the list element.

 On output, F transfers the value of the corresponding I/O list
 element, rounded to "d" decimal positions and right-justified, to
 an external field that is "w" characters long.  If the value does
 not fill the field, leading spaces are inserted; if the value is
 too large for the field, the entire field is filled with asterisks.

 The term "w" must be large enough to include all of the following:
 a minus sign (when necessary) or a plus sign (if SP editing is in
 effect), at least one digit to the left of the decimal point, a
 decimal point, and "d" digits to the right of the decimal.

 Therefore, "w" must be greater than or equal to "d"+3.
3 G                         
 Gw.d[Ee] (General Floating Editing)

 On input, G performs the same as F format.

 On output, G transfers the value of the corresponding I/O list
 element, rounded to "d" decimal positions, and right-justified, to
 an external field that is "w" characters long.  The form in which
 the value is written is a function of the magnitude of the value,
 as given below:

   Data Magnitude                                    Equivalent Conversion
   --------------                                    --------------------
   0 < m < 0.1 - 0.5x10**-d-1                        Ew.d[Ee]
   m = 0                                             F(w-n).(d-1),n('b')
   0.1 - 0.5x10**-d-1 <= m < 1 - 0.5x10**-d          F(w-n).d, n('b')
   1 - 0.5x10**-d <= m < 10 - 0.5x10**-d+1           F(w-n).(d-1), n('b')
   10 - 0.5x10**-d+1 <= n < 100 - 0.5x10**-d+2       F(w-n).(d-2), n('b')
         .                                               .
         .                                               .
         .                                               .
   10**d-2 - 0.5x10**-2 <= m < 10**d-1 - 0.5x10**-1  F(w-n).1, n('b')
   10**d-1 - 0.5x10**-1 <= m < 10**d - 0.5           F(w-n).0, n('b')
   m >= 10**d - 0.5                                  Ew.d[Ee]

 The 'b' is a blank following the numeric data representation.  For
 Gw.d, n('b') is 4 blanks.  For Gw.dEe, n('b') is "e"+2 blanks.

 The term "w" must be greater than or equal to d+7 to allow for the
 following:  a sign (optional if the value is positive and
 descriptor SP is not in effect), one digit to the left of the
 decimal point, a decimal point, "d" digits to the right of the
 decimal point, and either a 4-digit or an "e"+2-digit exponent.

 If "e" is specified, "w" must be greater than or equal to
 "d"+"e"+5.
3 H                         
 nHc1c2c2...cn (Hollerith Editing)

 On input, transfers "n" characters from the external record to the
 field descriptor itself.  The first character appears immediately
 after the H.  Any characters in the field descriptor prior to the
 input operation are replaced by the input characters.

 On output, transfers "n" characters following the letter H from the
 field descriptor to the external field.


                                NOTE

         This edit descriptor is an obsolescent  feature  in
         Fortran   90,  which  is  deleted  in  Fortran  95.
         DIGITAL  Fortran  flags  deleted  and   obsolescent
         features, but fully supports them.

3 I                         
 Iw[.m] (Integer Editing)

 On input, I transfers "w" characters from the external field and
 assigns them, as an integer value, to the corresponding I/O list
 element (which must be integer or logical data type).  The external
 data must have the form of an integer constant; it cannot contain a
 decimal point or exponent field.

 If the first nonblank character of the external field is a minus
 sign, the field is treated as a negative value.  If the first
 nonblank character is a plus sign or if no sign appears in the
 field, the field is treated as a positive value.

 On output, I transfers the value of the corresponding I/O list
 element, right-justified, to an external field that is "w"
 characters long.  If the value does not fill the field, leading
 spaces are inserted; if the value is too large for the field, the
 entire field is filled with asterisks.  "w" must be large enough to
 include a possible minus sign.  If "m" is present, the external
 field consists of at least "m" digits and, if necessary, is zero
 filled on the left.
3 L                         
 Lw (Logical Editing)

 On input, L transfers "w" characters from the external field and
 assigns a logical value to the corresponding I/O list element
 (which must be integer or logical data type).  If the first
 nonblank characters of the field are T, t, .T, or .t, the value
 .TRUE. is assigned to the corresponding I/O list element; if the
 first nonblank characters are F, f, .F, or .f, the value .FALSE. is
 assigned.  An all blank field is assigned the value .FALSE.  Any
 other value in the external field produces an error.  The logical
 constants .TRUE. and .FALSE. are acceptable input forms.

 On output, L transfers either the letter T (if the value of the
 corresponding I/O list element is .TRUE.) or the letter F (if the
 value is .FALSE.) to an external field that is "w" characters long.
 The letter T or F is in the rightmost position of the field,
 preceded by w-1 spaces.
3 O                         
 Ow[.m] (Octal Editing)

 On input, O transfers "w" characters from the external field and
 assigns them, as an octal value, to the corresponding I/O list
 element (which can be any data type).  The external field can
 contain only the numerals 0 though 7; it cannot contain a sign, a
 decimal point, or exponent field.  An all blank field is treated as
 a value of zero.  If the value of the external field exceeds the
 range of the corresponding list element, an error occurs.

 On output, O transfers the octal value of the corresponding I/O
 list element, right-justified, to an external field that is "w"
 characters long.  No signs are transmitted; a negative value is
 transmitted in internal form.  If the value does not fill the
 field, leading spaces are inserted; if the value is too large for
 the field, the entire field is filled with asterisks.  If "m" is
 present, the external field consists of at least "m" digits and, if
 necessary, is zero filled on the left.

 "w" must be large enough to include a possible minus sign.  If "m"
 is present, the external field consists of at least "m" digits and,
 if necessary, is zero filled on the left.
3 P                         
 nP (Scale Factor Editing)

 The scale factor lets you alter, during input or output, the
 location of the decimal point both in real values and in the two
 parts of complex values.

 The "n" is a signed or unsigned integer constant, in the range -128
 to 127, that specifies the number of positions to the left or right
 that the decimal point is to move.

 A scale factor can appear anywhere in a format specification, but
 must precede the first F, E, D, EN, ES, or G field descriptor that
 is to be associated with it and affects all subsequent real field
 descriptors in the same FORMAT statement (unless another scale
 factor appears).

 On input the scale factor of any of the F, E, D, EN, ES, and G
 field descriptors multiplies the data by 10**-n and assigns it to
 the corresponding I/O list element.  For example a 2P scale factor
 multiplies an input value by .01; a -2P multiplies an input value
 by 100.  However, if the external field contains an explicit
 exponent, the scale factor has no effect.

 E, D, EN, ES, and G field descriptors alter the form in which data
 is transferred.  On input a positive scale factor moves the decimal
 point to the left and a negative scale factor moves the decimal
 point to the right; on output, the effect is the reverse.
4 F_editing
 nPFw.d

 On output, the value of the I/O list element is multiplied by 10**n
 before transfer to the external record.  Thus, a positive scale
 factor moves the decimal point to the right; a negative scale
 factor moves the decimal point to the left.  Thus, the F descriptor
 alters the magnitude of the data.
4 E_editing
 nPEw.d

 On output, the basic real constant part of the I/O list element is
 multiplied by 10**n, and "n" is subtracted from the exponent.  For
 a positive scale factor, "n" must be less than d+2 or an output
 conversion error occurs.  Thus, a positive scale factor moves the
 decimal point to the right and decreases the exponent; a negative
 scale factor moves the decimal point to the left and increases the
 exponent.
4 D_editing
 nPDw.d

 On output, the basic real constant part of the I/O list element is
 multiplied by 10**n, and "n" is subtracted from the exponent.  For
 a positive scale factor, "n" must be less than d+2 or an output
 conversion error occurs.  Thus, a positive scale factor moves the
 decimal point to the right and decreases the exponent; a negative
 scale factor moves the decimal point to the left and increases the
 exponent.
4 EN_editing
 On output, the scale factor has no effect on EN editing.
4 ES_editing
 On output, the scale factor has no effect on ES editing.
4 G_editing
 nPGw.d

 On output, the effect for the G field descriptor is suspended if
 the magnitude of the data to be output is within the effective
 range of the descriptor (because the G field descriptor supplies
 its own scaling function).  It functions as an E field descriptor
 if the magnitude of the data is outside its range.  In this case,
 the scale factor has the same effect as for the E field descriptor.
3 Q                         
 (Query Remaining Character Count)

 On input, Q obtains the number of characters remaining in the input
 record to be transferred during a read operation.  The following
 example uses the Q descriptor to determine the size of the input
 record:

    READ(5,'(Q,A)') LEN, REC(1:LEN)

 On output, the Q descriptor has no effect, except that the
 corresponding I/O item is skipped.
3 S                         
 (Normal Signing)

 Restores the option of producing plus characters (+) in numeric
 output fields.  The S descriptor counters the action of either the
 SP or SS descriptor by restoring to the processor the discretion of
 producing plus characters on an optional basis.

 This descriptor affects fields all that follow it, until an SP or
 SS is encountered.  The S descriptor affects all subsequent I, F,
 E, D, and G editing (in the same FORMAT statement) during the
 execution of an output statement.
3 SP                        
 (Always + Signs)

 Causes the processor to produce a leading plus character (+) in any
 position where this character would otherwise be optional.

 This descriptor affects all (suppress + signs) fields that follow
 it, until an S or SS is encountered.  The SP descriptor affects all
 subsequent I, F, E, D, and G editing (in the same FORMAT statement)
 during the execution of an output statement.
3 SS                        
 (Suppress Sign)

 Causes the processor to suppress a leading plus character from any
 position where this character would otherwise be optional.  It has
 the opposite effect of the SP field descriptor.

 The SS descriptor affects all subsequent I, F, E, D, and G editing
 (in the same FORMAT statement) during the execution of an output
 statement.  This descriptor affects all fields that follow it,
 until an S or SS is encountered.
3 Slash                          
 [r]/

 Terminates data transfer for the current record and starts data
 transfer for a new record.  The "r" is an optional repeat
 specification.

 Multiple slashes cause the system to skip input records or to
 output blank records, as follows:

  o  When "n" consecutive slashes appear between two edit
     descriptors, "n"-1 records are skipped on input, or "n"-1 blank
     records are output.  The first slash terminates the current
     record.  The second slash terminates the first skipped or blank
     record, and so on.

  o  When "n" consecutive slashes appear at the beginning or end of
     a format specification, "n" records are skipped or "n" blank
     records are output, because the opening and closing parentheses
     of the format specification are themselves a record initiator
     and terminator, respectively.

3 T                         
 Tn (Tab to Position n)

 On input, starts the next read operation at the character position
 (within the record) indicated by position n.  For example, if an
 input statement reads a record containing:

    ABC   XYZ

 and this record is under the control of the FORMAT statement:

    10 FORMAT (T7,A3,T1,A3)

 On execution, the input statement would first read the characters
 XYZ and then read the characters ABC.

 On output, starts the next write operation at the character
 position n in the external record.

 The position specified must be an integer in the range 1 through
 the size of the record.
3 TL                        
 TLn (Tab Left n Positions)

 Indicates that the next character to be transferred to or from a
 record is the "n"th character to the left of the current character.

 The value of "n" must be greater than or equal to 1.

 If the value of "n" is greater than or equal to the current
 character position, the first character in the record is specified.
3 TR                        
 TRn (Tab Right n Positions)

 Indicates that the next character to be transferred to or from a
 record is the "n"th character to the right of the current
 character.

 The value of "n" must be greater than or equal to 1.
3 X                         
 nX (Skip Right n Positions)

 The X field descriptor functions the same as the TR field
 descriptor.

 On input, X starts the next read operation after skipping "n"
 character positions.  If X is the last format item, it will have no
 effect.

 On output, X starts the next write operation after skipping the "n"
 character positions.  Intervening characters are not written over.
 If X is the last format code executed, it will have no effect.

 The position specified must be in integer in the range 1 through
 the size of the record.
3 Z                         
 Zw[.m] (Hexadecimal Editing)

 On input, Z transfers "w" characters from the external field and
 assigns them, as a hexadecimal value, to the corresponding I/O list
 element (which can be any data type).  The input value must be in
 the form of a hexadecimal constant.  Each input character
 corresponds to four bits in the variable, high order to low order.
 If the input value contains more characters than specified by "w",
 an error occurs.  If the input value contains fewer characters, it
 is padded with zeros on the left before being converted.

 On output, Z transfers the number of hexadecimal characters
 specified by "w" from a variable or constant to the record.  The
 rightmost characters represent the low-order bits.  If the variable
 or constant contains more characters than "w" specifies, the value
 is set to all asterisks (an error occurs).  If the variable or
 constant contains fewer characters, the value is padded on the left
 with spaces.  "m" specifies the minimum number of characters (with
 zero padding) that the value can contain.  "m" must be an integer
 in the range 1 through 255.  "w" must be large enough to include a
 possible minus sign.  If "m" is present, the external field
 consists of at least "m" digits and, if necessary, is zero filled
 on the left.
2 Intrinsic_Procedures
3 ABS     
 ABS (number)

 Class:  Elemental function

 Returns the absolute value of the argument.  The absolute value of
 a complex number, (X,Y), is the real value:

     (X**2 + Y**2)**(1/2).

 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  1   |  ABS    |  --      | INTEGER*1  | INTEGER*1   |
 |      |         | IIABS    | INTEGER*2  | INTEGER*2   |
 |      |see note | IABS     | INTEGER*4  | INTEGER*4   |
 |      |         | KIABS    | INTEGER*8  | INTEGER*8   |
 |      |         | ABS      | REAL*4     | REAL*4      |
 |      |         | DABS     | REAL*8     | REAL*8      |
 |      |         | QABS     | REAL*16    | REAL*16     |
 |      |         | CABS     | COMPLEX*8  | REAL*4      |
 |      |         | CDABS    | COMPLEX*16 | REAL*8      |
 |      |         | ZABS     | COMPLEX*16 | REAL*8      |
 +------+---------+----------+------------+-------------+

 Note: Or JIABS.  For compatibility with older versions 
       of Fortran, IABS can also be specified as a generic
       function.
3 ACHAR   
 ACHAR (integer-number)

 Class:  Elemental function

 Returns the character in a specified position of the ASCII
 character set.  It is the inverse of the IACHAR function.

 The result type is character of length 1 with the kind type
 parameter value of KIND ('A').

 If I has a value within the range 0 to 127, the result is the
 character in position I of the ASCII character set.
3 ACOS    
 ACOS (real-number)

 Class:  Elemental function

 Returns the arc cosine of the argument in radians.  The absolute
 value of the argument must be less than or equal to 1.

 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  1   | ACOS    | ACOS     | REAL*4     | REAL*4      |
 |      |         | DACOS    | REAL*8     | REAL*8      |
 |      |         | QACOS    | REAL*16    | REAL*16     |
 +------+---------+----------+------------+-------------+
3 ACOSD   
 ACOSD (real-number)

 Class:  Elemental function

 Returns the arccosine of the argument in degrees.  The value of the
 argument must be between 0 (exclusive) and 1 (inclusive).

 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  1   |  ACOSD  |  ACOSD   | REAL*4     | REAL*4      |
 |      |         |  DACOSD  | REAL*8     | REAL*8      |
 |      |         |  QACOSD  | REAL*16    | REAL*16     |
 +------+---------+----------+------------+-------------+
3 ADJUSTL 
 ADJUSTL (string)

 Class:  Elemental function

 Adjusts a character string to the left, removing leading blanks and
 inserting trailing blanks.

 The result type is character with the same length and kind type
 parameter as "string".
3 ADJUSTR 
 ADJUSTR (string)

 Class:  Elemental function

 Adjusts a character string to the right, removing trailing blanks
 and inserting leading blanks.

 The result type is character with the same length and kind type
 parameter as "string".
3 AIMAG   
 AIMAG (complex-number)

 Class:  Elemental function

 Returns the imaginary part of a complex number.  If Z has the value
 (x, y), the result has the value "y".  This function can also be
 specified as IMAG.

 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  1   | AIMAG   | AIMAG    | COMPLEX*8  | REAL*4      |
 |      |         | DIMAG    | COMPLEX*16 | REAL*8      |
 +------+---------+----------+------------+-------------+

 The setting of real size compiler options can affect this function.
3 AINT    
 AINT (real-number[,kind])

 Class:  Elemental function

 Returns the largest integer whose absolute value does not exceed
 the absolute value of the argument and has the same sign as the
 argument.

 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  1   |  AINT   | AINT     | REAL*4     | REAL*4      |
 |      |         | DINT     | REAL*8     | REAL*8      |
 |      |         | QINT     | REAL*16    | REAL*16     |
 +------+---------+----------+------------+-------------+
3 ALL     
 ALL (mask [,dim])

 Class:  Transformational function

 Determines if all values are true in an entire array or in a
 specified dimension of an array.

 The "mask" must be a logical array.  The "dim" must be a scalar
 integer with a value in the range 1 to n, where "n" is the rank of
 "mask".

 The result is a logical array with the same kind type parameter as
 "mask".  The result is scalar if "dim" is absent or "mask" has rank
 one.  Otherwise, the result is an array with rank that is one less
 than "mask", and shape (d1, d2,..., d"dim"-1, d"dim"+1,..., dn),
 where (d1, d2,..., dn) is the shape of "mask".

 The result of ALL (mask) has the value true if all elements of
 "mask" are true or "mask" has size zero.  The result has the value
 false if any element of "mask" is false.

 If "mask" has rank one, ALL (mask, dim) has the same value as ALL
 (mask).  Otherwise, the value of element (s1, s2,..., s"dim"-1,
 s"dim"+1,..., sn) of ALL (mask, dim) is equal to ALL (mask (s1,
 s2,..., s"dim"-1, :, s"dim"+1, ..., sn).

 Examples:

 ALL ((/.TRUE., .FALSE., .TRUE./)) has the value false.

 ALL ((/.TRUE., .TRUE., .TRUE./)) has the value true.

 Consider the following arrays:

   Array A       Array B

   |1 5 7|       |0 5 7|
   |3 6 8|       |2 6 9|

 ALL (A .NE.  B, DIM=1) has the value (true, false, false).

 ALL (A .NE.  B, DIM=2) has the value (false, false).
3 ALLOCATED
 ALLOCATED (array)

 Class:  Inquiry function

 Indicates whether an allocatable array is currently allocated.

 The "array" must be an allocatable array.

 The result has the value true if ARRAY is currently allocated,
 false if ARRAY is not currently allocated, or undefined if its
 allocation status is undefined.

 The setting of integer size compiler options can affect this
 function.

 Example:

 REAL, ALLOCATABLE, DIMENSION (:,:,:) :: E 
 PRINT *, ALLOCATED (E)       ! Returns the value false
 ALLOCATE (E (12, 15, 20))
 PRINT *, ALLOCATED (E)       ! Returns the value true
3 AMAX0   
 See the MAX intrinsic function.
3 AMIN0   
 See the MIN intrinsic function.
3 ANINT   
 ANINT (real-number [,kind])

 Class:  Elemental function

 Returns the value of the integer nearest to the value of the
 argument.

 If real number x is greater than zero, ANINT (x) has the value AINT
 (x + 0.5).  If x is less than or equal to zero, ANINT (x) has the
 value AINT (x - 0.5).

 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  1   | ANINT   | ANINT    | REAL*4     | REAL*4      |
 |      |         | DNINT    | REAL*8     | REAL*8      |
 |      |         | QNINT    | REAL*16    | REAL*16     |
 +------+---------+----------+------------+-------------+

 See also the NINT intrinsic function.
3 ANY     
 ANY (mask [,dim])

 Class:  Transformational function

 Determines if any value is true in an entire array or in a
 specified dimension of an array.

 The "mask" must be a logical array.  The "dim" must be a scalar
 integer with a value in the range 1 to n, where "n" is the rank of
 "mask".

 The result is a logical array with the same kind type parameter as
 "mask".  The result is scalar if "dim" is absent or "mask" has rank
 one.  Otherwise, the result is an array with rank that is one less
 than "mask", and shape (d1, d2,..., d"dim"-1, d"dim"+1,..., dn),
 where (d1, d2,..., dn) is the shape of "mask".

 The result of ANY (mask) has the value true if any elements of
 "mask" are true.  The result has the value false if no element of
 "mask" is true or "mask" has size zero.

 If "mask" has rank one, ANY (mask, dim) has the same value as ANY
 (mask).  Otherwise, the value of element (s1, s2,..., s"dim"-1,
 s"dim"+1,..., sn) of ANY (mask, dim) is equal to ANY (mask (s1,
 s2,..., s"dim"-1, :, s"dim"+1, ..., sn).

 Examples:

 ANY ((/.FALSE., .FALSE., .TRUE./)) has the value true.

 Consider the following arrays:

   Array A       Array B

   |1 5 7|       |0 5 7|
   |3 6 8|       |2 6 9|

 ANY (A .NE.  B, DIM=1) has the value (true, false, true).

 ANY (A .NE.  B, DIM=2) has the value (true, true).
3 ASIN    
 ASIN (real-number)

 Class:  Elemental function

 Returns the arcsine of the argument in radians.  The absolute value
 of the argument must be less than or equal to 1.

 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  1   |  ASIN   | ASIN     | REAL*4     | REAL*4      |
 |      |         | DASIN    | REAL*8     | REAL*8      |
 |      |         | QASIN    | REAL*16    | REAL*16     |
 +------+---------+----------+------------+-------------+
3 ASIND   
 ASIND (real-number)

 Class:  Elemental function

 Returns the arc sine of the argument in degrees.  The value of the
 argument must be between 0 (exclusive) and 1 (inclusive).

 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |   1  |  ASIND  | ASIND    | REAL*4     | REAL*4      |
 |      |         | DASIND   | REAL*8     | REAL*8      |
 |      |         | QASIND   | REAL*16    | REAL*16     |
 +------+---------+----------+------------+-------------+
3 ASM     
 ASM (character [, any-type-arg])

 Class:  Nonelemental function

 Lets you use assembler instructions in an executable program.

 The first argument is a character constant or a concatenation of
 character constants containing the assembler instructions.  The
 optional second argument can be of any type.  It can be a source or
 destination argument for the instruction, for example.

 Arguments are passed by value.  If you want to pass an argument by
 reference (for example, a whole array, a character string, or a
 record structure), you can use the %REF built-in function.

 Labels are allowed, but all references must be from within the same
 ASM function.  This lets you set up looping constructs, for
 example.  Cross-jumping between ASM functions is not permitted.

 In general, an ASM function can appear anywhere that an intrinsic
 function can be used.  Since the supplied assembly code, assembly
 directives, or assembly data is integrated into the code stream,
 the compiler may choose to use different registers, better code
 sequences, and so on, just as if the code were written in Fortran.

 You do not have absolute control over instruction sequences and
 registers, and the compiler may intersperse other code together
 with the ASM code for better performance.  Better code sequences
 may be substituted by the optimizer if it chooses to do so.

 Only register names beginning with a dollar sign ($) or percent
 sign (%) are permitted.  For more information on register name
 conventions, see your operating system documentation set.

   +---------+-------------------+-------------+
   | Generic | Specific          | Result Type |
   +---------+-------------------+-------------+
   |  ASM    | ASM (see Note1)   | INTEGER*8   |
   |         | FASM (see Note2)  | REAL*4      |
   |         | DASM (see Note2)  | REAL*8      |
   +---------+-------------------+-------------+

 Note1: The value must be stored in register $0 by the user code.
 Note2: The value must be stored in register $F0 by the user code.

 Example:

 Consider the following:

  ! Concatenation is recommended for clarity.
  ! Notice that ";" separates instructions.
  !
  nine=9

  type *, asm('addq %0, $17, $0;'//  ! Adds the first two arguments
   1    'ldq $22, %6;'//             !   and puts the answer in
   1    'ldq $23, %7;'//             !   register $0
   1    'ldq $24, %8;'//             !
   1    'mov $0, %fp;'//             ! Comments are not allowed in the
   1    'addq $18, %fp, $0;'//       !   constant, but are allowed here
   1     'addq $19, $0, $0;'//
   1     'addq $20, $0, $0;'//
   1     'addq $21, $0, $0;'//
   1     'addq $22, $0, $0;'//
   1     'addq $23, $0, $0;'//
   1    'addq $24, $0, $0;',
   1 1,2,3,4,5,6,7,8,nine)           ! The actual arguments to the
                                     !   ASM (usually by value)
  end

 This example shows an integer ASM function that adds up 9 values
 and returns the sum as its result.  Note that the user stores the
 function result in register $0.

 All arguments are passed by value.  The arguments not passed in
 registers can be named %6, %7, and %8, which correspond to the
 actual arguments 7, 8, and 9 (since %0 is the first argument).
 Notice that you can reference reserved registers like %fp.

 The compiler creates the appropriate argument list.  So, in this
 example, the first argument value (1) will be available in register
 $16, and the eighth argument value (8) will be available in %7,
 which is actually 8($30).
3 ASSOCIATED
 ASSOCIATED (pointer [,target])

 Class:  Inquiry function

 Returns the association status of its pointer argument or indicates
 whether the pointer is associated with the target.  The pointer
 must not have an undefined association status.

 The "target" can be a pointer or target.

 If only POINTER appears, the result is true if it is currently
 associated with a target; otherwise, the result is false.

 If TARGET also appears and is a target, the result is true if
 POINTER is currently associated with TARGET; otherwise, the result
 is false.

 If TARGET is a pointer, the result is true if both POINTER and
 TARGET are currently associated with the same target; otherwise,
 the result is false.  (If either POINTER or TARGET is
 disassociated, the result is false.)

 The setting of integer size compiler options can affect this
 function.

 Examples:

 Consider the following:

    REAL, TARGET, DIMENSION (0:50) :: TAR 
    REAL, POINTER, DIMENSION (:) :: PTR 
    PTR => TAR
    ASSOCIATED (PTR, TAR)          ! Returns the value true

 The subscript range for PTR is 0:50.  Consider the following
 pointer assignment statements:

    (1) PTR => TAR (:)
    (2) PTR => TAR (0:50)
    (3) PTR => TAR (0:49)

 For statements 1 and 2, ASSOCIATED (PTR, TAR) is true because TAR
 has not changed (the subscript range for PTR in both cases is 1:51,
 following the rules for deferred-shape arrays).  For statement 3,
 ASSOCIATED (PTR, TAR) is false because the upper bound of TAR has
 changed.

 Consider the following:

    REAL, POINTER, DIMENSION (:) :: PTR2, PTR3 
    ALLOCATE (PTR2 (0:15))
    PTR3 => PTR2
    ASSOCIATED (PTR2, PTR3)          ! Returns the value true
    ...
    NULLIFY (PTR2)
    NULLIFY (PTR3)
    ASSOCIATED (PTR2, PTR3)          ! Returns the value false
3 ATAN    
 ATAN (real-number)

 Class:  Elemental function

 Returns the arc tangent of the argument in radians.

 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  1   |   ATAN  | ATAN     | REAL*4     | REAL*4      |
 |      |         | DATAN    | REAL*8     | REAL*8      |
 |      |         | QATAN    | REAL*16    | REAL*16     |
 +------+---------+----------+------------+-------------+
3 ATAND   
 ATAND (real-number)

 Class:  Elemental function

 Returns the arc tangent of the argument in degrees.  The value of
 the argument must be greater than 0.

 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |   1  |  ATAND  | ATAND    | REAL*4     | REAL*4      |
 |      |         | DATAND   | REAL*8     | REAL*8      |
 |      |         | QATAND   | REAL*16    | REAL*16     |
 +------+---------+----------+------------+-------------+
3 ATAN2   
 ATAN2 (real-number, real-number)

 Class:  Elemental function

 Returns the arc tangent of the quotient of the two arguments in
 radians.  If both arguments are zero, the result is undefined.  If
 the first argument is positive, the result is positive.  If the
 first argument is negative, the result is negative.  If the first
 argument is zero, the result is zero.  If the second argument is
 zero, the absolute value of the result is pi/2.

 The range of the result is -pi < result <= pi.

 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  2   |  ATAN2  | ATAN2    | REAL*4     | REAL*4      |
 |      |         | DATAN2   | REAL*8     | REAL*8      |
 |      |         | QATAN2   | REAL*16    | REAL*16     |
 +------+---------+----------+------------+-------------+
3 ATAN2D  
 ATAN2D (real-number, real-number)

 Class:  Elemental function

 Returns the arc tangent of the quotient of the two arguments in
 degrees.

 If both arguments are zero, the result is undefined.  If the first
 argument is positive, the result is positive.  If the first
 argument is negative, the result is negative.  If the first
 argument is zero, the result is zero.  If the second argument is
 zero, the absolute value of the result is 90 degrees.  The value of
 the argument must be greater than zero.

 The range of the result is -180 degrees < result <= 180 degrees.

 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |   2  | ATAN2D  | ATAN2D   | REAL*4     | REAL*4      |
 |      |         | DATAN2D  | REAL*8     | REAL*8      |
 |      |         | QATAN2D  | REAL*16    | REAL*16     |
 +------+---------+----------+------------+-------------+
3 BIT_SIZE
 BIT_SIZE (integer)

 Class:  Inquiry function

 Returns the number of bits in an integer type.

 The result value is the number of bits ("s") defined by the bit
 model for integers with the kind type parameter of the argument.
 For information on the bit model, see your language reference
 manual.

 Example:

 BIT_SIZE (1_2) has the value 16 because the INTEGER*2 type contains
 16 bits.
3 BTEST   
 BTEST (integer, position)

 Class:  Elemental function

 Returns a logical value of true if the bit within the integer
 specified by position is set to 1 (bit test).  The low-order bit is
 position 0.

 +------+---------+----------------+------------+-------------+        
 | Args | Generic | Specific       |  Argument  | Result Type |
 +------+---------+----------------+------------+-------------+
 |   2  |         |   --           | INTEGER*1  | LOGICAL*4   |
 |      |         | BITEST         | INTEGER*2  | LOGICAL*2   |
 |      |  BTEST  | BTEST(see note)| INTEGER*4  | LOGICAL*4   |
 |      |         | BKTEST         | INTEGER*8  | LOGICAL*8   |
 +------+---------+----------------+------------+-------------+

 NOTE: Or BJTEST
3 CEILING 
 CEILING (real-number [,KIND])

 Class:  Elemental function

 Returns the smallest integer greater than or equal to its argument.

 The result type is default integer (unless KIND specifies a
 different integer KIND).  The value of the result is equal to the
 smallest integer greater than or equal to the real-number.  The
 result is undefined if the value cannot be represented in the
 default integer range.
3 CHAR    
 CHAR (integer [,kind])

 Class:  Elemental function

 Returns the character that has the numeric value specified by the
 argument.  The input value must be in the range 0 to 255.

 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  1   |   --    |  --      | INTEGER*1  | CHARACTER   |
 |      |         |  --      | INTEGER*2  | CHARACTER   |
 |      |         |  CHAR    | INTEGER*4  | CHARACTER   |
 |      |         |  --      | INTEGER*8  | CHARACTER   |
 +------+---------+----------+------------+-------------+
3 CMPLX   
 CMPLX (number [,number] [,kind])

 Class:  Elemental function

 Converts the argument(s) into a COMPLEX*8 value.

 If one argument is specified, the argument is converted into the
 real part of the complex value and the imaginary part becomes zero.
 If two arguments are specified, the first argument is converted
 into the real part of the complex value and the second argument is
 converted into the imaginary part of the complex value.  If two
 arguments are specified, they must have the same data type.

 The setting of real size compiler options can affect this function.

 +-------+---------+----------+------------+-------------+       
 | Args  | Generic | Specific |  Argument  | Result Type |
 +-------+---------+----------+------------+-------------+
 | 1,2   |  CMPLX  | CMPLX    | INTEGER*2  | COMPLEX*8   |
 | 1,2   |         | CMPLX    | INTEGER*4  | COMPLEX*8   |
 | 1,2   |         | CMPLX    | REAL*4     | COMPLEX*8   |
 | 1,2   |         | CMPLX    | REAL*8     | COMPLEX*8   |
 | 1,2   |         | CMPLX    | REAL*16    | COMPLEX*8   |
 |  1    |         | CMPLX    | COMPLEX*8  | COMPLEX*8   |
 |  1    |         | CMPLX    | COMPLEX*16 | COMPLEX*8   |
 +-------+---------+----------+------------+-------------+
3 CONJG   
 CONJG (complex-number)

 Class:  Elemental function

 Returns the complex conjugate of the argument.  If the argument is
 (X,Y), its complex conjugate is (X,-Y).

 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |   1  |  CONJG  | CONJG    | COMPLEX*8  | COMPLEX*8   |
 |      |         | DCONJG   | COMPLEX*16 | COMPLEX*16  |
 +------+---------+----------+------------+-------------+
3 COS     
 COS (number)

 Class:  Elemental function

 Returns the cosine of the argument.  The argument must be in
 radians; it is treated modulo 2*pi.

 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |   1  |  COS    | COS      | REAL*4     | REAL*4      |
 |      |         | DCOS     | REAL*8     | REAL*8      |
 |      |         | QCOS     | REAL*16    | REAL*16     |
 |      |         | CCOS     | COMPLEX*8  | COMPLEX*8   |
 |      |         | CDCOS    | COMPLEX*16 | COMPLEX*16  |
 |      |         | ZCOS     | COMPLEX*16 | COMPLEX*16  |
 +------+---------+----------+------------+-------------+
3 COSD    
 COSD (number)

 Class:  Elemental function

 Returns the cosine of the argument.  The argument must be in
 degrees; it is treated modulo 360.

 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  1   |   COSD  | COSD     | REAL*4     | REAL*4      |
 |      |         | DCOSD    | REAL*8     | REAL*8      |
 |      |         | QCOSD    | REAL*16    | REAL*16     |
 +------+---------+----------+------------+-------------+
3 COSH    
 COSH (real-number)

 Class:  Elemental function

 Returns the hyperbolic cosine of the argument.

 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |   1  | COSH    | COSH     | REAL*4     | REAL*4      |
 |      |         | DCOSH    | REAL*8     | REAL*8      |
 |      |         | QCOSH    | REAL*16    | REAL*16     |
 +------+---------+----------+------------+-------------+
3 COTAN   
 COTAN (real-number)

 Class:  Elemental function

 Returns a cotangent (with the result in radians).

 The argument cannot be zero.  It must be in radians and is treated
 as modulo 2*pi.

 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |   1  | COTAN   | COTAN    | REAL*4     | REAL*4      |
 |      |         |          | REAL*8     | REAL*8      |
 |      |         | DCOTAN   | REAL*8     | REAL*8      |
 +------+---------+----------+------------+-------------+
3 COUNT   
 COUNT (mask [,dim])

 Class:  Transformational function

 Counts the number of true elements in an entire array or in a
 specified dimension of an array.

 The "mask" must be a logical array.  The "dim" must be a scalar
 integer with a value in the range 1 to n, where "n" is the rank of
 "mask".

 The result is default integer.  The result is scalar if "dim" is
 absent or "mask" has rank one.  Otherwise, the result is an array
 with rank that is one less than "mask", and shape (d1, d2,...,
 d"dim"-1, d"dim"+1,..., dn), where (d1, d2,..., dn) is the shape of
 "mask".

 The result of COUNT (mask) is a value equal to the number of true
 elements of "mask".  If mask has size zero, the result is zero.

 If "mask" has rank one, COUNT (mask, dim) has the same value as
 COUNT (mask).  Otherwise, the value of element (s1, s2,...,
 s"dim"-1, s"dim"+1,..., sn) of COUNT (mask, dim) is equal to COUNT
 (mask (s1, s2,..., s"dim"-1, :, s"dim"+1, ...,sn).

 Examples:

 COUNT ((/.TRUE., .FALSE., .TRUE./)) has the value 2.

 COUNT ((/.TRUE., .TRUE., .TRUE./)) has the value 3.

 Consider the following arrays:

   Array A       Array B

   |1 5 7|       |0 5 7|
   |3 6 8|       |2 6 9|

 COUNT (A .NE.  B, DIM=1) has the value (2, 0, 1).

 COUNT (A .NE.  B, DIM=2) has the value (1, 2).
3 CPU_TIME
 CPU_TIME (time)

 Class:  Subroutine

 Returns a processor-dependent approximation of the processor time
 (in seconds).

 Argument "time" must be scalar and of real type.  It is an
 INTENT(OUT) argument.

 If a meaningful time cannot be returned, a processor-dependent
 negative value is returned.

 Example:

   REAL time_begin, time_end
   ...
   CALL CPU_TIME(time_begin)
   ...                         !some operation coding
   CALL CPU_TIME(time_end)
   PRINT (*,*) 'Time of operation was ', time_begin - time_end, ' seconds'
3 CSHIFT  
 CSHIFT (array, shift [,dim])

 Class:  Transformational function

 Performs a circular shift on a rank-one array, or performs circular
 shifts on all the complete rank-one sections along a given
 dimension of an array of rank two or greater.

 Elements shifted off one end are inserted at the other end.
 Different sections can be shifted by different amounts and in
 different directions.

 The "shift" can be a scalar integer or array with rank one less
 than "array".  The "dim" must be a scalar integer with a value in
 the range 1 to n, where "n" is the rank of "array".  If "dim" is
 omitted, it is assumed to be 1.

 The result is an array with the same type, type parameters, and
 shape as "array".

 If "array" has rank one, element i of the result is array (1 +
 MODULO (i + "shift" - 1, SIZE (array))).

 If "array" has rank greater than 1, section (s1, s2, ...s"dim"-1,
 :, s"dim"+1, ..., sn) of the result has a value equal to CSHIFT
 (array(s1, s2, ..., s"dim"-1, :, s"dim"+1, ..., sn), sh, 1), where
 "sh" is "shift" or shift(s1, s2, ..., s"dim"-1, s"dim"+1,..., sn).

 The value of "shift" determines the amount and direction of the
 circular shift.  A positive integer causes a shift to the left (in
 rows) or up (in columns).  A negative integer causes a shift to the
 right (in rows) or down (in columns).

 Examples:

 V is the array (1, 2, 3, 4, 5, 6).

 CSHIFT (V, SHIFT=2) shifts V circularly to the left by 2 positions,
 producing the value (3, 4, 5, 6, 1, 2).

 CSHIFT (V, SHIFT= -2) shifts V circularly to the right by 2
 positions, producing the value (5, 6, 1, 2, 3, 4).

 M is the array Consider the following array:

   Array M

   |1 2 3|
   |4 5 6|
   |7 8 9|

 CSHIFT (M, SHIFT = 1, DIM = 2) produces the result:

   |2 3 1|
   |5 6 4|
   |8 9 7|

 CSHIFT (M, SHIFT = -1, DIM = 1) produces the result

   |7 8 9|
   |1 2 3|
   |4 5 6|

 CSHIFT (M, SHIFT = (/1, -1, 0/), DIM = 2) produces the result

   |2 3 1|
   |6 4 5|
   |7 8 9|
3 DATE    
 DATE (buf)

 Class:  Subroutine

 Returns the current date as set within the system.  The date is
 returned as a 9-byte ASCII character string as follows:

   dd-mmm-yy

 The "buf" is a 9-byte variable, array, array element, or character
 substring.  If "buf" is numeric type and smaller than 9 bytes, data
 corruption can occur.

 If "buf" is character type, its associated length is passed to the
 subroutine.  If "buf" is smaller than 9 bytes, the subroutine
 truncates the date to fit in the specified length.  If a CHARACTER
 array is passed, the subroutine stores the date in the first array
 element, using the element length, not the length of the entire
 array.  For example, consider the following:

 CHARACTER*1 DAY(9)
 ...
 CALL DATE(DAY)

 The length of the first array element in CHARACTER array DAY is
 passed to the DATE subroutine.  The subroutine then truncates the
 date to fit into the one-character element, producing an incorrect
 result.
3 DATE_AND_TIME
 DATE_AND_TIME ([date] [,time] [,zone] [,values])

 Class:  Subroutine

 Returns character data on the real-time clock and date in a form
 compatible with the representations defined in Standard ISO
 8601:1988.

 Optional arguments (all are INTENT(OUT)):

  o  The "date" must be scalar and of type default character; its
     length must be at least 8 to contain the complete value.  Its
     leftmost 8 characters are set to a value of the form CCYYMMDD,
     where:

       CC is the century
       YY is the year within the century
       MM is the month within the year
       DD is the day within the month

  o  The "time" must be scalar and of type default character; its
     length must be at least 10 to contain the complete value.  Its
     leftmost 10 characters are set to a value of the form
     hhmmss.sss, where:

       hh is the hour of the day
       mm is the minutes of the hour
       ss.sss is the seconds and milliseconds of the minute

  o  The "zone" must be scalar and of type default character; its
     length must be at least 5 to contain the complete value.  Its
     leftmost 5 characters are set to a value of the form + or -
     hhmm, where "hh" and "mm" are the time difference with respect
     to Coordinated Universal Time (UTC) in hours and parts of an
     hour expressed in minutes, respectively.

  o  The "values" must be of type default integer and of rank one.
     Its size must be at least 8.  The values returned in "values"
     are as follows:

       values (1) is the 4-digit year
       values (2) is the month of the year
       values (3) is the day of the year
       values (4) is the time difference with respect to 
                  Coordinated Universal Time (UTC) in minutes
       values (5) is the hour of the day (range 0 to 23)
       values (6) is the minutes of the hour (range 0 to 59).
       values (7) is the seconds of the minute (range 0 to 59).
       values (8) is the milliseconds of the second (range 0 to 999).


 Example:

 Consider the following example executed on 1993 April 23 at
 13:23:30.5:

 INTEGER DATE_TIME (8)
 CHARACTER (LEN = 12) REAL_CLOCK (3)
 CALL DATE_AND_TIME (REAL_CLOCK (1), REAL_CLOCK (2), &
                     REAL_CLOCK (3), DATE_TIME)

 This assigns the value "19930423" to REAL_CLOCK (1), the value
 "132330.500" to REAL_CLOCK (2), and the value "+0100" to REAL_CLOCK
 (3).  The following values are assigned to DATE_TIME:  1993, 4, 23,
 60, 13, 23, 30, and 500.
3 DBLE    
 DBLE (number)

 Class:  Elemental function

 Converts a number into a REAL*8 value.

 +------+-----------+----------+------------+-------------+        
 | Args | Generic   | Specific |  Argument  | Result Type |
 +------+-----------+----------+------------+-------------+
 |  1   |  DBLE     |   --     | INTEGER*1  | REAL*8      |
 |      |           |   --     | INTEGER*2  | REAL*8      |
 |      |           |   --     | INTEGER*4  | REAL*8      |
 |      |           |   --     | INTEGER*8  | REAL*8      |         
 |      |           |  DBLE    | REAL*4     | REAL*8      |
 |      |           |   --     | REAL*8     | REAL*8      |
 |      |           |  DBLEQ   | REAL*16    | REAL*8      |
 |      |           |   --     | COMPLEX*8  | REAL*8      |
 |      |           |   --     | COMPLEX*16 | REAL*8      |
 +------+-----------+----------+------------+-------------+
3 DCMPLX  
 DCMPLX (number [,number])

 Class:  Elemental function

 Converts the argument(s) into a COMPLEX*16 value.

 If one argument is specified, the argument is converted into the
 real part of the complex value and the imaginary part becomes zero.
 If two arguments are specified, the first argument is converted
 into the real part of the complex value and the second argument is
 converted into the imaginary part of the complex value.  If two
 arguments are specified, they must have the same data type.

 +-------+----------+----------+------------+-------------+       
 | Args  | Generic  | Specific |  Argument  | Result Type |
 +-------+----------+----------+------------+-------------+
 | 1,2   | DCMPLX   |   --     | INTEGER*1  | COMPLEX*16  |
 | 1,2   |          |   --     | INTEGER*2  | COMPLEX*16  |
 | 1,2   |          |   --     | INTEGER*4  | COMPLEX*16  |
 | 1,2   |          |   --     | INTEGER*8  | COMPLEX*16  |
 | 1,2   |          |   --     | REAL*4     | COMPLEX*16  |
 | 1,2   |          |   --     | REAL*8     | COMPLEX*16  |
 | 1,2   |          |   --     | REAL*16    | COMPLEX*16  |
 |  1    |          |   --     | COMPLEX*8  | COMPLEX*16  |
 |  1    |          |   --     | COMPLEX*16 | COMPLEX*16  |
 +-------+----------+----------+------------+-------------+
3 DFLOAT  
 DFLOAT (integer)

 Class:  Elemental function

 Converts an integer into a REAL*8 value.

 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  1   |  DFLOAT |   --     | INTEGER*1  | REAL*8      |
 |      |         | DFLOTI   | INTEGER*2  | REAL*8      |
 |      |         | DFLOTJ   | INTEGER*4  | REAL*8      |
 |      |         | DFLOTK   | INTEGER*8  | REAL*8      |
 +------+---------+----------+------------+-------------+
3 DIGITS  
 DIGITS (number)

 Returns the number of significant digits for numbers of the same
 type and kind type parameter as the argument.  The argument can be
 an integer or real number (scalar or array valued).

 The result is type default integer.

 The models for integer and real numbers are described in your
 language reference manual.

 Example:

 If X is of type REAL*4, DIGITS (X) has the value 24.
3 DIM     
 DIM (number, number)

 Class:  Elemental function

 Returns the value of the first argument minus the minimum (MIN) of
 the two arguments.

 +------+----------+----------+------------+-------------+        
 | Args | Generic  | Specific |  Argument  | Result Type |
 +------+----------+----------+------------+-------------+
 |   2  |          |   --     | INTEGER*1  | INTEGER*1   |
 |      |          | IIDIM    | INTEGER*2  | INTEGER*2   |
 |      |see note  | IDIM     | INTEGER*4  | INTEGER*4   |
 |      |          | KIDIM    | INTEGER*8  | INTEGER*8   |
 |      |          | DIM      | REAL*4     | REAL*4      |
 |      |          | DDIM     | REAL*8     | REAL*8      |
 |      |          | QDIM     | REAL*16    | REAL*16     |
 +------+----------+----------+------------+-------------+

 NOTE: Or JIDIM
3 DIMAG   
 See the AIMAG function.
3 DOT_PRODUCT
 DOT_PRODUCT (vector-a, vector-b)

 Class:  Transformational function

 The "vector"s are rank-one arrays of integer, real, complex, or
 logical type.

 The result is a scalar; its type depends on "vector"s.

 If "vector-a" is of type integer or real, the result value is SUM
 (vector-a * vector-b).

 If "vector-a" is of type complex, the result value is SUM (CONJ
 (vector-a) * vector-b).

 If "vector-a" is of type logical, the result has the value ANY
 (vector-a .AND.  vector-b).

 If either rank-one array has size zero, the result is zero if the
 array is of numeric type, and false if the array is of logical
 type.

 Examples:

 DOT_PRODUCT ((/1, 2, 3/), (/3, 4, 5/)) has the value 26 (calculated
 as follows:

   ((1 x 3) + (2 x 4) + (3 x 5)) = 26)

 DOT_PRODUCT ((/ (1.0, 2.0), (2.0, 3.0) /), (/ (1.0, 1.0), ((1.0,
 4.0) /))) has the value (17.0, 4.0).

 DOT_PRODUCT ((/ .TRUE., .FALSE.  /), (/ .FALSE., .TRUE.  /)) has
 the value false.
3 DPROD   
 DPROD (real4-number, real4-number)

 Class:  Elemental function

 Returns the product of two REAL*4 values as a REAL*8 value.
3 DREAL   
 DREAL (dbl-complex-number)

 Class:  Elemental function

 A function that returns the real part of a complex number.  The
 argument must be a COMPLEX*16 data type.  The result is a REAL*8
 data type.
3 EOF     
 EOF (integer)

 Class:  Inquiry function

 Checks whether a file is at or beyond the end-of-file record.

 The argument represents a unit specifier corresponding to an open
 file.  It cannot be zero unless you have reconnected unit zero to a
 unit other than the screen or keyboard.

 The value of the result is .TRUE.  if the file connected to A is at
 or beyond the end-of-file record; otherwise, .FALSE..

 Examples:

 Consider the following:

 !  Creates a file of random numbers, reads them back
       REAL x, total
       INTEGER count
       OPEN (1, FILE = 'TEST.DAT')
       DO I = 1, 20
         CALL RANDOM_NUMBER(x)
         WRITE (1, '(F6.3)') x * 100.0
       END DO 
       CLOSE(1)
       OPEN (1, FILE = 'TEST.DAT')
       DO WHILE (.NOT. EOF(1))
         count = count + 1
         READ (1, *) value
         total = total + value
       END DO
 100   IF ( count .GT. 0) THEN
         WRITE (*,*) 'Average is: ', total / count
       ELSE
         WRITE (*,*) 'Input file is empty '
       END IF
        STOP
       END
3 EOSHIFT 
 EOSHIFT (array, shift [,boundary] [,dim])

 Class:  Transformational function

 Performs an end-off shift on a rank-one array, or performs end-off
 shifts on all the complete rank-one sections along a given
 dimension of an array of rank two or greater.

 Elements are shifted off at one end of a section and copies of a
 boundary value are filled in at the other end.  Different sections
 can have different boundary values and can be shifted by different
 amounts and in different directions.

 The "array" can be of any type.

 The "shift" can be a scalar integer or an array with a rank that is
 one less than "array", and shape (d1, d2,..., d"dim"-1,
 d"dim"+1,..., dn), where (d1, d2,..., dn) is the shape of "array".

 The "boundary" must be of the same type and kind type parameter as
 "array".  It can be a scalar or an array with a shape that is one
 less than that of "array" and shape (d1, d2,..., d"dim"-1,
 d"dim"+1,..., dn).  If "boundary is omitted, it is assumed to have
 the following values:

   "array" type       "boundary" value
   ------------       ----------------
    integer            0
    real               0.0
    complex            (0.0, 0.0)
    logical            false
    character (len)    "len" blanks

 The "dim" must be a scalar integer with a value in the range 1 to
 n, where "n" is the rank of "array".  If omitted, it is assumed to
 be 1.

 The result is an array with the same type, kind type parameter, and
 shape as "array"

 The value of "shift" determines the amount and direction of the
 end-off shift.  A positive integer causes a shift to the left (in
 rows) or up (in columns).  If an element is shifted off the
 beginning of a vector, the "boundary" value is placed at the end of
 the vector.

 A negative integer causes a shift to the right (in rows) or down
 (in columns).  If an element is shifted off the end of a vector,
 the "boundary" value is placed at the beginning of the vector.

 Examples:

 Consider that V is the array (1, 2, 3, 4, 5, 6).

 EOSHIFT (V, SHIFT=2) shifts the array to the left by 2 positions,
 producing the value (3, 4, 5, 6, 0, 0).

 EOSHIFT (V, SHIFT= -3, BOUNDARY= 99) shifts the array to the right
 by 3 positions, and uses the boundary value of 99, producing the
 value (99, 99, 99, 1, 2, 3).

 Consider that M is the following array:

  |1 2 3|
  |4 5 6|
  |7 8 9|

 EOSHIFT (M, SHIFT = 1, BOUNDARY = '*', DIM=2) produces the result:

  |2 3 *|
  |5 6 *|
  |8 9 *|

 EOSHIFT (M, SHIFT = -1, DIM = 1) produces the result:

  |0 0 0|
  |1 2 3|
  |4 5 6|

 EOSHIFT (M, SHIFT = (/1, -1, 0/), BOUNDARY = (/ '*', '?', '/' /),
 DIM=2) produces the result:

  |2 3 *|
  |? 4 5|
  |7 8 9|
3 EPSILON 
 EPSILON (real)

 Class:  Inquiry function

 Returns a positive model number that is almost negligible compared
 to unity in the model representing real numbers.  The argument can
 be scalar or array valued.

 The model for real numbers is described in your language reference
 manual.

 Example:

 If X is REAL*4 type, EPSILON (X) has the value 2**-23.
3 ERRSNS  
 ERRSNS ([io-err] [,sys-err] [,stat] [,unit] [,cond])

 Class:  Subroutine

 Returns information about the last Fortran error that occurred.
 The arguments are all return values and must be defined as integer
 variables or array elements:

    io-err    Stores the most recent Fortran error number 
              that occurred during program execution.
              The value is zero if no error has occurred.
              
    sys-err   Stores the most recent RMS STS status code.
  
    stat      Stores the most recent RMS STV status value. 
              This status value provides additional status 
              information.

    unit      Stores the logical unit number (if the last
              the last error was an I/O error).

    cond      Stores the actual processor value.  This
              value is always zero.

 If you specify INTEGER*2 arguments, only the low-order 16 bits of
 information are returned or adjacent data can be overwritten.
 Because of this, it is best to use INTEGER*4 arguments.

 The saved error information is set to zero after each call to
 ERRSNS.
3 EXIT    
 EXIT ([exit-status])

 Class:  Subroutine

 Terminates the program, closes all files, and returns control to
 the operating system.  The optional argument specifies the
 exit-status value of the program.
3 EXP     
 EXP (exponent)

 Class:  Elemental function

 Returns e**X, where X is the value of the argument.

 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  1   |  EXP    | EXP      | REAL*4     | REAL*4      |
 |      |         | DEXP     | REAL*8     | REAL*8      |
 |      |         | QEXP     | REAL*16    | REAL*16     |
 |      |         | CEXP     | COMPLEX*8  | COMPLEX*8   |
 |      |         | CDEXP    | COMPLEX*16 | COMPLEX*16  |
 |      |         | ZEXP     | COMPLEX*16 | COMPLEX*16  |
 +------+---------+----------+------------+-------------+
3 EXPONENT
 EXPONENT (real-number)

 Class:  Elemental function

 Returns the exponent part of the argument when represented as a
 model number.

 The result type is default integer.  If the argument is not equal
 to zero, the result value is the exponent part of the argument.
 The exponent must be within default integer range; otherwise, the
 result is undefined.

 If the argument is zero, the exponent of the argument is zero.  For
 more information on the exponent part in the real model, see your
 language reference manual.

 Examples:

 EXPONENT (2.0) has the value 2.

 If 4.1 is a REAL*4 value, EXPONENT (4.1) has the value 3.
3 FLOAT   
 See the REAL function.
3 FLOOR   
 FLOOR (real-number [,KIND])

 Class:  Elemental function

 Returns the greatest integer less than or equal to its argument.

 The result type is default integer (unless KIND specifies a
 different integer KIND).  The result value is equal to the greatest
 integer less than or equal to the argument.  The result is
 undefined if the value cannot be represented in the default integer
 range.

 Examples:

 FLOOR (4.8) has the value 4.

 FLOOR (-5.6) has the value -6.
3 FP_CLASS
 FP_CLASS (real-number)

 Class:  Elemental function

 Returns the class of an IEEE real (S_floating, T_floating, or
 X_floating) argument.

 The result type is default integer.

 The return values are defined in file "fordef.f".  For information
 on the location of this file, see your user manual.

 Example:

 FP_CLASS (4.0_8) has the value 4.
3 FRACTION
 FRACTION (real-number)

 Class:  Elemental function

 Returns the fractional part of the model representation of the
 argument value.

 The result type is the same as the argument.  The real model is
 described in your language reference manual.

 Example:

 If 3.0 is a REAL*4 value, FRACTION (3.0) has the value 0.75.
3 FREE    
 FREE (integer)

 Class:  Intrinsic subroutine

 Frees a block of memory that is currently allocated.

 The argument must be of type INTEGER*8.  This value is the starting
 address of the memory to be freed, previously allocated by the
 MALLOC intrinsic function.

 If the freed address was not previously allocated by MALLOC, or if
 an address is freed more than once, results are unpredictable.

 Examples:

 Consider the following:

 INTEGER(4) ADDR, SIZE
 SIZE = 1024                 ! Size in bytes
 ADDR = MALLOC(SIZE)         ! Allocate the memory
 CALL FREE(ADDR)             ! Free it
 END
3 HUGE    
 HUGE (number)

 Class:  Inquiry function

 Returns the largest number in the model representing the same type
 and kind type parameter as the argument.

 The argument can be integer or real; it can be scalar or array
 valued.  The result type is scalar of the same type and kind type
 parameter as the argument.  The integer and real models are
 described in your language reference manual.

 Example:

 If X is REAL*4 type, HUGE (X) has the value (1 - 2**-24) x 2**128.
3 IABS    
 See the ABS function.
3 IACHAR  
 IACHAR (character)

 Class:  Elemental function

 Returns the position of a character in the ASCII collating
 sequence.  The argument must have a length of 1.  The result type
 is default integer.
3 IAND    
 IAND (integer, integer)

 Class:  Elemental function

 Performs a logical AND of the arguments on a bit by bit basis
 (bitwise AND).  This function can also be specified as AND.

 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  2   |  IAND   |  --      | INTEGER*1  | INTEGER*1   |
 |      |         | IIAND    | INTEGER*2  | INTEGER*2   |
 |      |         | JIAND    | INTEGER*4  | INTEGER*4   |
 |      |         | KIAND    | INTEGER*8  | INTEGER*8   |
 +------+---------+----------+------------+-------------+
3 IARGCOUNT
 IARGCOUNT ()

 Class:  Inquiry function

 Returns the count of actual arguments passed to the current
 routine.  The result type is default integer.  Functions with a
 type of CHARACTER, COMPLEX(KIND=8), or REAL(KIND=16) have an extra
 argument added that is used to return the function value.

 Formal (dummy) arguments which can be omitted must be declared
 VOLATILE.

 The following example shows the IARGCOUNT intrinsic:

    CALL SUB (A,B)
    ...
    SUBROUTINE SUB (X,Y,Z)
    VOLATILE Z
    TYPE *, IARGCOUNT()       ! Displays the value 2
3 IARGPTR
 IARGPTR ()

 Class:  Inquiry function

 Returns a pointer to the actual argument list for the current
 routine.  IARGPTR takes no arguments and returns an INTEGER*8
 address of the calling-standard defined "argument block".

 The first element in the array contains the argument count;
 subsequent elements contain the INTEGER(KIND=8) address of the
 actual arguments.

 Formal (dummy) arguments which can be omitted must be declared
 VOLATILE.

 The following example shows the IARGPTR intrinsic:

 C      Test IARGPTR intrinsic function.
        EXTERNAL TEST_ARGPTR
        INTEGER*4 X,Y,Z,FOO
        X = 10
        Y = 20
        Z = 100
        FOO = 4
  
        PRINT 80, %LOC(X), %LOC(Y), %LOC(Z), %LOC(FOO)
 80     FORMAT (' Argument addresses: ',4(1X, Z16))
        CALL TEST_ARGPTR (4, X, Y, Z, FOO)
        END

        OPTIONS /EXTEND_SOURCE
        SUBROUTINE TEST_ARGPTR (N_ARGS)
        POINTER (II, I_ARGN)
        INTEGER*8 I_ARGN
        POINTER (I_PTR, I_VAL)
        INTEGER I_VAL
               
        II = IARGPTR()             ! Get address of arg block
        II = II + SIZEOF (II)      ! Get address of address of first arg

        DO I = 1, N_ARGS+1
         I_PTR = I_ARGN            ! Get address of actual from homed
                                   !   arg list
         print 90, I, I_PTR, I_VAL
 90      format ( ' Argument ',I2, ' address = ',Z16, ', contents = ',Z16)
         II = II + SIZEOF (II)  ! Get address of address of next arg
        END DO
        RETURN
        END
3 IBCHNG  
 IBCHNG (integer, position)

 Class:  Elemental function

 Returns the reverse of the value of a specified bit in an integer.
 The low-order bit is position 0.

 Examples:

 Consider the following:

   INTEGER J, K
   J = IBCHNG(10, 2)         ! returns 14 = 1110
   K = IBCHNG(10, 1)         ! returns  8 = 1000
3 IBCLR   
 IBCLR (integer, position)

 Class:  Elemental function

 Returns the value of the first argument with the specified bit set
 to 0 (bit clear).  The low-order bit is position 0.

 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  2   |  IBCLR  |   --     | INTEGER*1  | INTEGER*1   |
 |      |         | IIBCLR   | INTEGER*2  | INTEGER*4   |
 |      |         | JIBCLR   | INTEGER*4  | INTEGER*4   |
 |      |         | KIBCLR   | INTEGER*8  | INTEGER*8   |
 +------+---------+----------+------------+-------------+
3 IBITS   
 IBITS (integer, start-position, length)

 Class:  Elemental function

 Returns the value of the bits of the first argument specified by
 start-position and number of bits.  The low-order bit is position
 0.

 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  3   |  IBITS  |   --     | INTEGER*1  | INTEGER*1   |
 |      |         | IIBITS   | INTEGER*2  | INTEGER*2   |
 |      |         | JIBITS   | INTEGER*4  | INTEGER*4   |
 |      |         | KIBITS   | INTEGER*8  | INTEGER*8   |
 +------+---------+----------+------------+-------------+
3 IBSET   
 IBSET (integer, position)

 Class:  Elemental function

 Returns the value of the first argument with the specified bit set
 to 1 (bit set).  The low-order bit is position 0.

 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  2   |  IBSET  |   --     | INTEGER*1  | INTEGER*1   |
 |      |         | IIBSET   | INTEGER*2  | INTEGER*2   |
 |      |         | JIBSET   | INTEGER*4  | INTEGER*4   |
 |      |         | KIBSET   | INTEGER*8  | INTEGER*8   |
 +------+---------+----------+------------+-------------+
3 ICHAR   
 ICHAR (character)

 Class:  Elemental function

 Returns the ASCII value of the argument.  The argument must have a
 length of 1.

 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  1   |   --    |  --      | CHARACTER  | INTEGER*2   |
 |      |         | ICHAR    | CHARACTER  | INTEGER*4   |
 |      |         |  --      | CHARACTER  | INTEGER*8   |
 +------+---------+----------+------------+-------------+
3 IDATE   
 IDATE (month, day, year)

 Class:  Subroutine

 Returns three integer values representing the current date.  The
 month is represented as the number of the month (1 - 12).  The day
 is represented as the day of the month.  The year is represented as
 the last two digits of the year.
3 IDIM    
 See the DIM function.
3 IDINT   
 See the INT function.
3 IDNINT  
 See the NINT function
3 IEOR    
 IEOR (integer, integer)

 Class:  Elemental function

 Performs an exclusive OR of the arguments on a bit by bit basis
 (bit exclusive OR).  This function can also be specified as XOR.

 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  2   | IEOR    |   --     | INTEGER*1  | INTEGER*1   |
 |      |         | IIEOR    | INTEGER*2  | INTEGER*2   |
 |      |         | JIEOR    | INTEGER*4  | INTEGER*4   |
 |      |         | KIEOR    | INTEGER*8  | INTEGER*8   |
 +------+---------+----------+------------+-------------+
3 IFIX    
 See the INT function.
3 ILEN    
 ILEN (integer)

 Class:  Elemental function

 Returns the length (in bits) of the two's complement representation
 of an integer.

 The result type is the same as the argument.

 Examples:

 ILEN (4) has the value 3.

 ILEN (-4) has the value 2.
3 IMAG    
 IMAG (complex-number)

 See the AIMAG intrinsic function.
3 INDEX   
 INDEX (string, substring [,back])

 Class:  Elemental function

 Returns the starting position of the substring as an INTEGER*4 or
 INTEGER*8 value.

 Examples:

 INDEX ('FORTRAN', 'O', BACK = .TRUE.) has the value 2.

 INDEX ('XXXX', " ", BACK = .TRUE.) has the value 0.

 INDEX ('XXXX', "", BACK = .TRUE.) has the value 5.
3 INT     
 INT (number [,kind])

 Class:  Elemental function

 Returns the largest integer whose absolute value does not exceed
 the absolute value of the argument and has the same sign as the
 argument.
 +------+-----------+----------+------------+-------------+        
 | Args | Generic   | Specific |  Argument  | Result Type |
 +------+-----------+----------+------------+-------------+
 |  1   |  INT      |  --      | INTEGER*1  | INTEGER*2   |
 |      |           |  --      | INTEGER*1  | INTEGER*4   |
 |      |           |  --      | INTEGER*1  | INTEGER*8   |
 |      |           |  --      | INTEGER*2  | INTEGER*4   |
 |      |           |  --      | INTEGER*2  | INTEGER*8   |
 |      |           |  --      | INTEGER*4  | INTEGER*4   |
 |      |           |  --      | INTEGER*4  | INTEGER*8   |
 |      |           |  --      | INTEGER*8  | INTEGER*8   |
 |      |see note1  | IIFIX    | REAL*4     | INTEGER*2   |
 |      |           | IINT     | REAL*4     | INTEGER*2   |
 |      |see note2  | IFIX     | REAL*4     | INTEGER*4   |
 |      |           | JFIX     | INTEGER*1  | INTEGER*4   |
 |      |           |          | INTEGER*2  | INTEGER*4   |
 |      |           |          | INTEGER*4  | INTEGER*4   |
 |      |           |          | REAL*4     | INTEGER*4   |
 |      |           |          | REAL*8     | INTEGER*4   |
 |      |           |          | COMPLEX*4  | INTEGER*4   |
 |      |           |          | COMPLEX*8  | INTEGER*4   |
 |      |see note3  | INT      | REAL*4     | INTEGER*4   |
 |      |           | KIFIX    | REAL*4     | INTEGER*8   |
 |      |           | KINT     | REAL*4     | INTEGER*8   |
 |      |           | IIDINT   | REAL*8     | INTEGER*2   |
 |      |see note4  | IDINT    | REAL*8     | INTEGER*4   |
 |      |           | KIDINT   | REAL*4     | INTEGER*8   |
 |      |           | IIQINT   | REAL*16    | INTEGER*2   |
 |      |see note5  | IQINT    | REAL*16    | INTEGER*4   |
 |      |           | KIQINT   | REAL*16    | INTEGER*8   |
 |      |           |  --      | COMPLEX*8  | INTEGER*2   |
 |      |           |  --      | COMPLEX*8  | INTEGER*4   |
 |      |           |  --      | COMPLEX*8  | INTEGER*8   |
 |      |           |  --      | COMPLEX*16 | INTEGER*2   |
 |      |           |  --      | COMPLEX*16 | INTEGER*4   |
 |      |           |  --      | COMPLEX*16 | INTEGER*8   |
 |      |           | INT1     | INTEGER*1  | INTEGER*1   |
 |      |           |          | INTEGER*2  | INTEGER*1   |
 |      |           |          | INTEGER*4  | INTEGER*1   |
 |      |           |          | REAL*4     | INTEGER*1   |
 |      |           |          | REAL*8     | INTEGER*1   |
 |      |           |          | COMPLEX*4  | INTEGER*1   |
 |      |           |          | COMPLEX*8  | INTEGER*1   |
 |      |           | INT2     | INTEGER*1  | INTEGER*2   |
 |      |           |          | INTEGER*2  | INTEGER*2   |
 |      |           |          | INTEGER*4  | INTEGER*2   |
 |      |           |          | REAL*4     | INTEGER*2   |
 |      |           |          | REAL*8     | INTEGER*2   |
 |      |           |          | COMPLEX*4  | INTEGER*2   |
 |      |           |          | COMPLEX*8  | INTEGER*2   |
 |      |           | INT4     | INTEGER*1  | INTEGER*4   |
 |      |           |          | INTEGER*2  | INTEGER*4   |
 |      |           |          | INTEGER*4  | INTEGER*4   |
 |      |           |          | REAL*4     | INTEGER*4   |
 |      |           |          | REAL*8     | INTEGER*4   |
 |      |           |          | COMPLEX*4  | INTEGER*4   |
 |      |           |          | COMPLEX*8  | INTEGER*4   |
 +------+-----------+----------+------------+-------------+

 Note1: This function can also be specified as HFIX.
 Note2: For compatibility with older versions of 
        Fortran, IFIX can also be specified as a generic 
        function.
 Note3: Or JINT.
 Note4: Or JIDINT.  For compatibility with older versions of 
        Fortran, IDINT can also be specified as a generic 
        function.
 Note5: Or JIQINT.  For compatibility with older versions of 
        Fortran, IQINT can also be specified as a generic 
        function.

 These functions cannot be passed as actual arguments.

 The setting of integer size compiler options can affect this
 function.
3 IOR     
 IOR (integer, integer)

 Class:  Elemental function

 Performs a logical OR of the arguments on a bit by bit basis
 (bitwise inclusive OR).  This function can also be specified as OR.
 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  2   |  IOR    |  --      | INTEGER*1  | INTEGER*1   |
 |      |         | IIOR     | INTEGER*2  | INTEGER*2   |
 |      |         | JIOR     | INTEGER*4  | INTEGER*4   |
 |      |         | KIOR     | INTEGER*8  | INTEGER*8   |
 +------+---------+----------+------------+-------------+
3 IQINT   
 See the INT function.
3 IQNINT  
 See the NINT function.
3 ISHA    
 ISHA (integer, shift)

 Class:  Elemental function

 Arithmetically shifts an integer left or right by a specified
 number of bits.

 The "shift" is of type integer; it is the direction and distance of
 shift.

 If "shift" is positive, the shift is to the left; if "shift" is
 negative, the shift is to the right.  If "shift" is zero, no shift
 is performed.

 Bits shifted out from the left or from the right, as appropriate,
 are lost.  Zeros are shifted in from the opposite end.

 The kind of integer is important in arithmetic shifting because
 sign varies among integer representations (see the following
 example).  If you want to shift a one-byte or two-byte argument,
 you must declare it as INTEGER(1) or INTEGER(2).

 Examples:

 Consider the following:

   INTEGER(1) i, res1
   INTEGER(2) j, res2
   i = -128             ! equal to  10000000
   j = -32768           ! equal to  10000000 00000000
   res1  = ISHA (i, -4) ! returns 11111000 = -8
   res2  = ISHA (j, -4) ! returns 11111000 00000000 = -2048
3 ISHC    
 ISHC (integer, shift)

 Class:  Elemental function

 Rotates an integer left or right by specified number of bits.  Bits
 shifted out one end are shifted in the other end.  No bits are
 lost.

 The "shift" is of type integer; it is the direction and distance of
 rotation.

 If "shift" is positive, "integer" is rotated left "shift" bits.  If
 "shift" is negative, "integer" is rotated right "shift" bits.  Bits
 shifted out one end are shifted in the other.  No bits are lost.

 The kind of integer is important in circular shifting.  With an
 INTEGER(4) argument, all 32 bits are shifted.  If you want to
 rotate a one-byte or two-byte argument, you must declare it as
 INTEGER(1) or INTEGER(2).

 Examples:

 Consider the following:

   INTEGER(1) i, res1
   INTEGER(2) j, res2
   i = 10                 ! equal to  00001010
   j = 10                 ! equal to  00000000 00001010
   res1  = ISHC (i, -3)   ! returns 01000001 =  65
   res2  = ISHC (j, -3)   ! returns 01000000 00000001 = 16385
3 ISHFT   
 ISHFT (integer, shift)

 Class:  Elemental function

 Performs a bitwise logical shift - the "shift" is the
 no-of-positions.

 The integer is shifted left (if "shift" is positive) or right (if
 "shift" is negative) by ABS(shift) bits.  If ABS(shift) is greater
 than or equal to the length in bits of the integer argument, the
 result is zero.
 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  2   |  ISHFT  |   --     | INTEGER*1  | INTEGER*1   |
 |      |         | IISHFT   | INTEGER*2  | INTEGER*2   |
 |      |         | JISHFT   | INTEGER*4  | INTEGER*4   |
 |      |         | KISHFT   | INTEGER*8  | INTEGER*8   |
 +------+---------+----------+------------+-------------+
3 ISHFTC  
 ISHFTC (integer, shift [,size])

 Class:  Elemental function

 Performs a bitwise circular shift - "shift" is the no-of-positions
 and "size" is the no-of-bits.

 The rightmost "size" bits of the integer argument are circularly
 shifted by "shift" places; bits in the integer argument beyond the
 value specified by "size" are unaffected.

 If "shift is positive, the shift is to the left; if negative, the
 shift is to the right.  If "size" is omitted, it is assumed to have
 the value BIT_SIZE (integer).
 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  3   | ISHFTC  | IISHFTC  | INTEGER*2  | INTEGER*4   |
 |      |         | JISHFTC  | INTEGER*4  | INTEGER*4   |
 |      |         | KISHFTC  | INTEGER*8  | INTEGER*8   |
 +------+---------+----------+------------+-------------+
3 ISHL    
 ISHL (integer, shift)

 Class:  Elemental function

 Logically shifts an integer left or right by the specified bits.
 Zeros are shifted in from the opposite end.

 The "shift" is of type integer; it is the direction and distance of
 shift.

 Unlike circular or arithmetic shifts, which can shift ones into the
 number being shifted, logical shifts shift in zeros only,
 regardless of the direction or size of the shift.  The integer
 kind, however, still determines the end that bits are shifted out
 of, which can make a difference in the result (see the following
 example).

 Examples:

 Consider the following:

   INTEGER(1) i, res1
   INTEGER(2) j, res2
   i = 10                ! equal to  00001010
   j = 10                ! equal to  00000000 00001010
   res1  = ISHL (i, 5)   ! returns 01000000 = 64
   res2  = ISHL (j, 5)   ! returns 00000001 01000000 = 320
3 ISIGN   
 See the SIGN function.
3 ISNAN   
 ISNAN (real-number)

 Class:  Elemental function

 Tests whether IEEE REAL*4 (S_floating) and REAL*8 (T_floating)
 numbers are Not-a-Number (NaN) values.  To use this function,
 compiler option /IEEE_FLOAT must be set.

 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  1   |  ISNAN  |   --     | REAL*4     | LOGICAL*4   |
 |      |         |          | REAL*8     | LOGICAL*4   |
 +------+---------+----------+------------+-------------+
3 KIND    
 KIND (number)

 Class:  Inquiry function

 Returns the value of the kind type parameter of the argument.  For
 more information on kind type parameters, see your language
 reference manual.

 The argument can be of any intrinsic type.  The result is a scalar
 of type default integer.

 Examples:

 KIND (0.0) has the kind type value of default real type.

 KIND (12) has the kind type value of default integer type.
3 LBOUND  
 LBOUND (array, [,dim])

 Class:  Inquiry function

 Returns the lower bounds for all dimensions of an array, or the
 lower bound for a specified dimension.

 The "array" cannot be an allocatable array that is not allocated,
 or a disassociated pointer.  The "dim" is a scalar integer with a
 value in the range 1 to n, where "n" is the rank of "array".

 The result type is default integer.  If "dim" is present, the
 result is a scalar.  Otherwise, the result is a rank-one array with
 one element for each dimension of "array".  Each element in the
 result corresponds to a dimension of "array".

 If "array" is an array section or an array expression that is not a
 whole array or array structure component, each element of the
 result has the value 1.

 Examples

 Consider the following:

 REAL ARRAY_A (1:3, 5:8)
 REAL ARRAY_B (2:8, -3:20)

 LBOUND (ARRAY_A) is (1, 5).  LBOUND (ARRAY_A, DIM=2) is 5.

 LBOUND (ARRAY_B) is (2, -3).  LBOUND (ARRAY_B (5:8, :)) is (1,1)
 because the arguments are array sections.
3 LEADZ   
 LEADZ (integer)

 Class:  Elemental function

 Returns the number of leading zeros in the binary representation of
 the integer argument.  The result type is the same as the argument.

 Example:

 Consider the following:

   INTEGER*8 J, TWO
   PARAMETER (TWO=2)
   DO J= -1, 40
     TYPE *, LEADZ(TWO**J)  ! Prints 64 down to 23 (leading zeros)
   ENDDO
   END
3 LEN     
 LEN (string)

 Class:  Inquiry function

 Returns the number of characters in the argument.  The argument
 must be a character expression.  The result is an INTEGER*4 or
 INTEGER*8 value.
3 LEN_TRIM
 LEN_TRIM (string)

 Class:  Elemental function

 Returns the length of the character argument without counting
 trailing blank characters.

 The "string" must be of type character.  The result type is default
 integer.

 Examples:

 LEN_TRIM ('   C  D   ') has the value 7.

 LEN_TRIM ('   ') has the value 0.
3 LGE     
 LGE (string-a, string-b)

 Class:  Elemental function

 Returns a value of true if the first character string is greater
 than or equal to the second character string.  The ASCII collating
 sequence determines the relationship between the arguments.

 The arguments must be character expressions.  The result is a
 LOGICAL*4 value.
3 LGT     
 LGT (string-a, string-b)

 Class:  Elemental function

 Returns a value of true if the first character string is greater
 than the second character string.  The ASCII collating sequence
 determines the relationship between the arguments.

 The arguments must be character expressions.  The result is a
 LOGICAL*4 value.
3 LLE     
 LLE (string-a, string-b)

 Class:  Elemental function

 Returns a value of true if the first character string is less than
 or equal to the second character string.  The ASCII collating
 sequence determines the relationship between the arguments.

 The arguments must be character expressions.  The result is a
 LOGICAL*4 value.
3 LLT     
 LLT (string-a, string-b)

 Class:  Elemental function

 Returns a value of true if the first character string is less than
 the second character string.  The ASCII collating sequence
 determines the relationship between the arguments.

 The arguments must be character expressions.  The result is a
 LOGICAL*4 value.
3 LOC     
 LOC (arg)

 Class:  Inquiry function

 Returns the internal address of a storage item.

 The argument can be a variable, an array or record field reference,
 a procedure, or a constant; it can be of any data type.  It must
 not be the name of an internal procedure or statement function.  If
 it is a pointer, it must be defined and associated with a target.

 The result type is INTEGER*8.  The value of the result represents
 the address of the data object or, in the case of pointers, the
 address of its associated target.  If the argument is not valid,
 the result is undefined.

 On Open VMS systems, in the case of global symbolic constants, LOC
 returns the value of the constant rather than an address.

 The LOC intrinsic serves the same purpose as the %LOC built-in
 function.
3 LOG     
 LOG (number)

 Class:  Elemental function

 Returns the natural log (base e) of a real or complex argument.
 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  1   |  LOG    | ALOG     | REAL*4     | REAL*4      |
 |      |         | DLOG     | REAL*8     | REAL*8      |
 |      |         | QLOG     | REAL*16    | REAL*16     |
 |      |         | CLOG     | COMPLEX*8  | COMPLEX*8   |
 |      |         | CDLOG    | COMPLEX*16 | COMPLEX*16  |
 |      |         | ZLOG     | COMPLEX*16 | COMPLEX*16  |
 +------+---------+----------+------------+-------------+

 The argument must be greater than zero.  The argument for CLOG,
 CDLOG, or ZLOG must not be (0.,0.).
3 LOG10   
 LOG10 (real-number)

 Class:  Elemental function

 Returns the common log (base 10) of the argument.  The argument
 must be greater than zero.
 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  1   |  LOG10  | ALOG10   | REAL*4     | REAL*4      |
 |      |         | DLOG10   | REAL*8     | REAL*8      |
 |      |         | QLOG10   | REAL*16    | REAL*16     |
 +------+---------+----------+------------+-------------+

 The argument must be greater than zero.
3 LOGICAL 
 LOGICAL (logical-exp, [,kind])

 Class:  Elemental function

 Converts the logical value of the argument to a logical of
 different kind type parameters.

 The setting of integer size compiler options can affect this
 function.

 Examples:

 LOGICAL (L .OR.  .NOT.  L) has the value true and is of type
 default logical regardless of the kind type parameter of logical
 variable L.

 LOGICAL (.FALSE., 2) has the value false, with the kind type
 parameter of default integer.
3 MALLOC  
 MALLOC (integer)

 Class:  Elemental function

 Allocates a block of memory.

 The argument must be of type INTEGER*4.  This value is the size in
 bytes of memory to be allocated.

 The result type is INTEGER*8.  The result is the starting address
 of the allocated memory.  The memory allocated can be freed by
 using the FREE intrinsic function.

 Examples:

 Consider the following:

 INTEGER(4) ADDR, SIZE
 SIZE = 1024                 ! Size in bytes
 ADDR = MALLOC(SIZE)         ! Allocate the memory
 CALL FREE(ADDR)             ! Free it
 END
3 MATMUL  
 MATMUL (matrix-a, matrix-b)

 Class:  Transformational function

 Performs matrix multiplication of numeric or logical matrices.

 The "matrix"s can be arrays of rank one or two.  At least one
 argument must be rank two.  The size of the first (or only)
 dimension of "matrix-b" must equal the last (or only) dimension of
 "matrix-a".

 The type of the resulting array depends on the data types of the
 arguments.  The rank and shape of the result follows:

  o  If "matrix-a" has shape (n,m) and "matrix-b" has shape (m,k),
     the result is a rank-two array with shape (n,k).

  o  If "matrix-a" has shape (m) and "matrix-b" has shape (m,k), the
     result is a rank-one array with shape (k).

  o  If "matrix-a" has shape (n,m) and "matrix-b" has shape (m), the
     result is a rank-one array with shape (n).


 Examples:

 Consider the following:

 A is the matrix |2 3 4|, B is the matrix |2 3|, 
                 |3 4 5|                  |3 4|
                                          |4 5|

 X is vector (1, 2), and Y is vector (1, 2, 3).

 The result of MATMUL (A, B) is the matrix-matrix product AB with
 the value

   |29 38|
   |38 50|

 The result of MATMUL (X, A) is the vector-matrix product XA with
 the value (8, 11, 14).

 The result of MATMUL (A, Y) is the matrix-vector product AY with
 the value (20, 26).
3 MAX     
 MAX (number, number [, ...])

 Class:  Elemental function

 Returns the greatest of the values specified in the argument list.
 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  n   |  MAX    |   --     | INTEGER*1  | INTEGER*1   |
 |      |         |   --     | INTEGER*1  | REAL*4      |
 |      |         | IMAX0    | INTEGER*2  | INTEGER*2   |
 |      |         | AIMAX0   | INTEGER*2  | REAL*4      |
 |      |see note1| MAX0     | INTEGER*4  | INTEGER*4   |
 |      |see note2| AMAX0    | INTEGER*4  | REAL*4      |
 |      |         | KMAX0    | INTEGER*8  | INTEGER*8   |
 |      |         | AKMAX0   | INTEGER*8  | REAL*4      |
 |      |         | IMAX1    | REAL*4     | INTEGER*2   |
 |      |see note3| MAX1     | REAL*4     | INTEGER*4   |
 |      |         | KMAX1    | REAL*4     | INTEGER*8   |
 |      |         | AMAX1    | REAL*4     | REAL*4      |
 |      |         | DMAX1    | REAL*8     | REAL*8      |
 |      |         | QMAX1    | REAL*16    | REAL*16     |
 +------+---------+----------+------------+-------------+

 Note1: Or JMAX0.
 Note2: Or AJMAX0.  AMAX0 is the same as REAL(MAX). For 
        compatibility with older versions of Fortran, AMAX0
        can also be specified as a generic function.
 Note3: Or JMAX1.  MAX1 is the same as INT(MAX). For 
        compatibility with older versions of Fortran, MAX1 
        can also be specified as a generic function. The 
        setting of integer size compiler options can affect MAX1.

 These functions cannot be passed as actual arguments.
3 MAX0    
 See the MAX function.
3 MAX1    
 See the MAX function.
3 MAXEXPONENT
 MAXEXPONENT (real-arg)

 Class:  Inquiry function

 Returns the maximum exponent in the model representing the same
 type and kind type parameter as the argument.  The argument can be
 scalar or array valued.

 The model for real numbers is described in your language reference
 manual.

 Example:

 If X is REAL*4 type, MAXEXPONENT (X) has the value 128.
3 MAXLOC  
 MAXLOC (array [,dim] [,mask])

 Class:  Transformational function

 Returns the location of the maximum value of all elements in an
 array, a set of elements in an array, or elements in a specified
 dimension of an array.

 The array can be of type integer or real.  The "dim" must be a
 scalar integer with a value in the range 1 to n, where "n" is the
 rank of "array".  The "mask" must be a logical array conformable
 with "array".

 The result type is default integer.  If "dim" is absent, the result
 is an array with rank that is one less than "array", and shape (d1,
 d2,..., d"dim"-1, d"dim"+1,..., dn), where (d1, d2,..., dn) is the
 shape of "array".

 The result of MAXLOC (array) is a rank-one array whose elements
 form the subscript of the location of the element with the maximum
 value in "array".

 The result of MAXLOC (array, mask=mask) is a rank-one array whose
 elements form the subscript of the location of the element with the
 maximum value corresponding to the condition specified by "mask".

 If more than one element has maximum value, the element whose
 subscripts are returned is the first such element, taken in array
 element order.  If "array" has size zero, the value of the result
 is undefined.

 Examples:

 The value of MAXLOC ((/3, 7, 4, 7/)) is 2.

 Consider that A is the array

  | 4  0 -3  2|
  | 3  1 -2  6|
  |-1 -4  5 -5|

 MAXLOC (A, MASK=A .LT.  5) has the value (1, 1).  This is true even
 if A has a declared bound other than 1.

 MAXLOC (A, DIM=1) has the value (1, 2, 3, 2).

 MAXLOC (A, DIM=2) has the value (1, 4, 3).
3 MAXVAL  
 MAXVAL (array [,dim] [,mask]

 Class:  Transformational function

 Returns the maximum value of all elements in an array, a set of
 elements in an array, or elements in a specified dimension of an
 array.

 The array can be of type integer or real.  The "dim" must be a
 scalar integer with a value in the range 1 to n, where "n" is the
 rank of "array".  The "mask" must be a logical array conformable
 with "array".

 The result is the same data type as "array".  The result is a
 logical array with the same kind type parameter as "array".  The
 result is scalar if "dim" is absent or "array" has rank one.
 Otherwise, the result is an array with rank that is one less than
 "array", and shape (d1, d2,..., d"dim"-1, d"dim"+1,..., dn), where
 (d1, d2,..., dn) is the shape of "array".

 The result of MAXVAL (array) has a value equal to the maximum value
 of all the elements in "array".

 The result of MAXVAL (array, mask=mask) has a value equal to the
 maximum value of the elements in "array" corresponding to the
 condition specified by "mask".

 If "array" has size zero or if there are no true elements in
 "mask," the result has the value of the negative number of the
 largest magnitude supported by the processor for numbers of the
 type and kind type parameter of "array".

 Examples:

 The value of MAXVAL ((/2, 3, 4/)) is 4.

 The value of MAXVAL (B, MASK=B .LT.  0.0) finds the maximum of the
 negative elements of B.

 Consider that C is the array

  |2 3 4|
  |5 6 7|

 MAXVAL (C, DIM=1) has the value (5, 6, 7).

 MAXVAL (C, DIM=2) has the value (4, 7).
3 MERGE   
 MERGE (tsource, fsource, mask)

 Class:  Elemental function

 Selects between two values or between corresponding elements in two
 arrays, according to the condition specified by a logical mask.

 The "tsource" and "fsource" can be scalars or arrays; they must
 have the same type and type parameters.  The "mask" is a logical
 array.

 The result type is the same as "tsource".  The value of "mask"
 determines whether the result value is taken from "tsource" (if
 "mask" is true) or "fsource" (if "mask" is false).

 Examples:

 For MERGE (1.0, 0.0, R < 0), R = -3 has the value 1.0, and R = 7
 has the value 0.0.

 Consider that TSOURCE is the array |1 3 5|, FSOURCE is the
                                    |2 4 6|

 array |8 9 0|, and MASK is the array |F T T|.
       |1 2 3|                        |T T F|

 MERGE (TSOURCE, FSOURCE, MASK) produces the result: |8 3 5|.
                                                     |2 4 3|
3 MIN     
 MIN (number, number [, ...])

 Class:  Elemental function

 Returns the lowest of the values specified in the argument list.
 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  n   |  MIN    |   --     | INTEGER*1  | INTEGER*1   |
 |      |         |   --     | INTEGER*1  | REAL*4      |
 |      |         | IMIN0    | INTEGER*2  | INTEGER*2   |
 |      |         | AIMIN0   | INTEGER*2  | REAL*4      |
 |      |see note1| MIN0     | INTEGER*4  | INTEGER*4   |
 |      |see note2| AMIN0    | INTEGER*4  | REAL*4      |
 |      |         | KMIN0    | INTEGER*8  | INTEGER*8   |
 |      |         | AKMIN0   | INTEGER*8  | REAL*4      |
 |      |         | IMIN1    | REAL*4     | INTEGER*2   |
 |      |see note3| MIN1     | REAL*4     | INTEGER*4   |
 |      |         | KMIN1    | REAL*4     | INTEGER*8   |
 |      |         | AMIN1    | REAL*4     | REAL*4      |
 |      |         | DMIN1    | REAL*8     | REAL*8      |
 |      |         | QMIN1    | REAL*16    | REAL*16     |
 +------+---------+----------+------------+-------------+

 Note1: Or JMIN0.
 Note2: Or AJMIN0.  AMIN0 is the same as REAL(MIN). For 
        compatibility with older versions of Fortran, AMIN0 
        can also be specified as a generic function.
 Note3: Or JMIN1.  MIN1 is the same as INT(MIN). For 
        compatibility with older versions of Fortran, MIN1
        can also be specified as a generic function. The setting 
        of integer size compiler options can affect MIN1.

 These functions cannot be passed as actual arguments.
3 MIN0    
 See the MIN function.
3 MIN1    
 See the MIN function.
3 MINEXPONENT
 MINEXPONENT (real-arg)

 Class:  Inquiry function

 Returns the minimum exponent in the model representing the same
 type and kind type parameter as the argument.  The argument can be
 scalar or array valued.

 The model for real numbers is described in your language reference
 manual.

 Example:

 If X is REAL*4 type, MINEXPONENT (X) has the value -125.
3 MINLOC  
 MINLOC (array [,dim] [,mask])

 Class:  Transformational function

 Returns the location of the minimum value of all elements in an
 array, a set of elements in an array, or elements in a specified
 dimension of an array.

 The array can be of type integer or real.  The "dim" must be a
 scalar integer with a value in the range 1 to n, where "n" is the
 rank of "array".  The "mask" must be a logical array conformable
 with "array".

 The result type is default integer.  If "dim" is absent, the result
 is an array with rank that is one less than "array", and shape (d1,
 d2,..., d"dim"-1, d"dim"+1,..., dn), where (d1, d2,..., dn) is the
 shape of "array".

 The result of MINLOC (array) is a rank-one array whose elements
 form the subscript of the location of the element with the minimum
 value in "array".

 The result of MINLOC (array, mask=mask) is a rank-one array whose
 elements form the subscript of the location of the element with the
 minimum value corresponding to the condition specified by "mask".

 If more than one element has minimum value, the element whose
 subscripts are returned is the first such element, taken in array
 element order.  If "array" has size zero, the value of the result
 is undefined.

 Examples:

 The value of MINLOC ((/3, 1, 4, 1/)) is 2.

 Consider that A is the array

  | 4  0 -3  2|
  | 3  1 -2  6|
  |-1 -4  5 -5|

 MINLOC (A, MASK=A .GT.  -5) has the value (3, 2).  This is true
 even if A has a declared bound other than 1.

 MAXLOC (A, DIM=1) has the value (3, 3, 1, 3).

 MAXLOC (A, DIM=2) has the value (3, 3, 4).
3 MINVAL  
 MINVAL (array [,dim] [,mask]

 Class:  Transformational function

 Returns the minimum value of all elements in an array, a set of
 elements in an array, or elements in a specified dimension of an
 array.

 The array can be of type integer or real.  The "dim" must be a
 scalar integer with a value in the range 1 to n, where "n" is the
 rank of "array".  The "mask" must be a logical array conformable
 with "array".

 The result is the same data type as "array".  The result is a
 logical array with the same kind type parameter as "array".  The
 result is scalar if "dim" is absent or "array" has rank one.
 Otherwise, the result is an array with rank that is one less than
 "array", and shape (d1, d2,..., d"dim"-1, d"dim"+1,..., dn), where
 (d1, d2,..., dn) is the shape of "array".

 The result of MINVAL (array) has a value equal to the minimum value
 of all the elements in "array".

 The result of MINVAL (array, mask=mask) has a value equal to the
 minimum value of the elements in "array" corresponding to the
 condition specified by "mask".

 If "array" has size zero or if there are no true elements in
 "mask," the result has the value of the positive number of the
 largest magnitude supported by the processor for numbers of the
 type and kind type parameter of "array".

 Examples:

 The value of MINVAL ((/2, 3, 4/)) is 2.

 The value of MINVAL (B, MASK=B .GT.  0.0) finds the minimum of the
 positive elements of B.

 Consider that C is the array

  |2 3 4|
  |5 6 7|

 MINVAL (C, DIM=1) has the value (2, 3, 4).

 MINVAL (C, DIM=2) has the value (2, 5).
3 MOD     
 MOD (dividend, divisor)

 Class:  Elemental function

 Divides the first argument by the second and returns the remainder.
 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  2   |  MOD    |  --      | INTEGER*1  | INTEGER*1   |
 |      |         | IMOD     | INTEGER*2  | INTEGER*2   |
 |      |see note | MOD      | INTEGER*4  | INTEGER*4   |
 |      |         | KMOD     | INTEGER*8  | INTEGER*8   |
 |      |         | AMOD     | REAL*4     | REAL*4      |
 |      |         | DMOD     | REAL*8     | REAL*8      |
 |      |         | QMOD     | REAL*16    | REAL*16     |
 +------+---------+----------+------------+-------------+

 NOTE: Or JMOD.
3 MODULO  
 MODULO (number-a, number-b)

 Class:  Elemental function

 Returns the modulo of the arguments.  The arguments can be integer
 or real type.  They must both be the same type and kind type
 parameter.

 The result is the same type as the arguments.

 If "number-a" is of type integer and "number-b" is not equal to
 zero, the value of the result is "number-a" -
 FLOOR(REAL("number-a")/REAL("number-b")) * "number-b".  If
 "number-a" is of type real and "number-b" is not equal to zero, the
 value of the result is "number-a" - FLOOR("number-a"/"number-b").
 If "number-b" is equal to zero, the result is undefined.

 Examples:

 MODULO (7, 3) has the value 1.

 MODULO (9, -6) has the value -3.

 MODULO (-9, 6) has the value 3.
3 MULT_HIGH
 MULT_HIGH (integer*8, integer*8)

 Class:  Elemental function

 A function that multiplies two 64-bit unsigned integers.  The
 result type is also INTEGER*8.  The result value is the upper
 (leftmost) 64 bits of the 128-bit unsigned result.

 Consider the following:

         INTEGER(8) I,J,K
         I=2_8**53
         J=2_8**51
         K = MULT_HIGH (I,J)
         PRINT *,I,J,K
         WRITE (6,1000)I,J,K
 1000    FORMAT (' ', 3(Z,1X))
         END

 This example prints the following:

   9007199254740992      2251799813685248         1099511627776
       20000000000000           8000000000000             10000000000
3 MVBITS  
 MVBITS (from, frompos, len, to, topos)

 Class:  Elemental subroutine

 Moves bits from one location to another.  The following arguments
 can be of any integer data type:

    from     Is an integer variable or array element that 
             contains the bits to be transferred.

    frompos  Is an integer expression that identifies the 
             position of the first bit within "from" 
             to be transferred.

    len      Is an integer expression that specifies the 
             number of bits to be transferred.

    to       Is an integer variable or array element that 
             identifies the location to which the bits are 
             being transferred.

    topos    Is an integer expression that identifies the 
             starting position within "to" for the bits 
             being transferred.

 The low-order bit in either integer is position 0.  The values of
 frompos + len must be < 32, and topos + len must be <= 32.

 You can also specify the following specific subroutines:

   IMVBITS   All arguments must be INTEGER*2.
   JMVBITS   Arguments can be INTEGER*2 or INTEGER*4; at least 
             one must be INTEGER*4.
   KMVBITS   Arguments can be INTEGER*2, INTEGER*4, or INTEGER*8; 
             at least one must be INTEGER*8.
3 NEAREST 
 NEAREST (real-number-a, real-number-b)

 Class:  Elemental function

 Returns the nearest different number (representable on the
 processor) in a given direction.

 The result type is the same as "real-number-a"; it has the same
 sign as "real-number-b".

 Example:

 If 3.0 and 2.0 are REAL*4 values, NEAREST (3.0, 2.0) has the value
 3 + 2**-22, which equals approximately 3.0000002.  For more
 information on the REAL*4 model, see your language reference
 manual.
3 NINT    
 NINT (real-number [,kind])

 Class:  Elemental function

 Returns the value of the integer nearest to the value of the
 argument.
 +------+-----------+----------+------------+-------------+        
 | Args | Generic   | Specific |  Argument  | Result Type |
 +------+-----------+----------+------------+-------------+
 |   1  |           | ININT    | REAL*4     | INTEGER*2   |
 |      |see note1  | NINT     | REAL*4     | INTEGER*4   |
 |      |           | KNINT    | REAL*4     | INTEGER*8   |
 |      |           | IIDNNT   | REAL*8     | INTEGER*2   |
 |      |see note2  | IDNINT   | REAL*8     | INTEGER*4   |
 |      |           | KIDNNT   | REAL*8     | INTEGER*8   |
 |      |           | IIQNNT   | REAL*16    | INTEGER*2   |
 |      |see note3  | IQNINT   | REAL*16    | INTEGER*4   |
 |      |           | KIQNNT   | REAL*16    | INTEGER*8   |
 +------+-----------+----------+------------+-------------+

 Note1: Or JNINT.
 Note2: Or JIDNNT.  For compatibility with older versions 
        of Fortran, IDNINT can also be specified as a generic 
        function.
 Note3: Or JIQNNT. For compatibility with older versions 
        of Fortran,  IQNINT can also be specified as a generic 
        function.

 The setting of integer size compiler options can affect this
 function.
3 NOT     
 NOT (integer)

 Class:  Elemental function

 Complements each bit of the argument (bitwise complement).
 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  1   |  NOT    |  --      | INTEGER*1  | INTEGER*1   |
 |      |         | INOT     | INTEGER*2  | INTEGER*2   |
 |      |         | JNOT     | INTEGER*4  | INTEGER*4   |
 |      |         | KNOT     | INTEGER*8  | INTEGER*8   |
 +------+---------+----------+------------+-------------+
3 NULL    
 NULL ([mold])

 Class:  Transformational function

 Returns a disassociated pointer.

 Argument "mold" must be a pointer; it can be of any type.

 The status of the pointer can be associated, disassociated, or
 undefined.  If the pointer's status is associated, the target does
 not have to be defined with a value.

 The result type is the same as "mold", if present.  Otherwise, the
 type (and rank) is determined by the pointer that becomes
 associated with the result:


 If NULL () Appears...         Type is Determined From...
 ------------------------      -----------------------------------
 Right side of pointer         The pointer on the left side
   assignment

 Initialization for an         The object
   object in a declaration

 Default initialization        The component
   for a component

 In a structure constructor    The corresponding component

 As an actual argument         The corresponding dummy argument

 In a DATA statement           The corresponding pointer object

 Example:

   INTEGER, POINTER :: POINT1 => NULL()

 This statement defines the initial association status of POINT1 to
 be disassociated.
3 NUMBER_OF_PROCESSORS
 NUMBER_OF_PROCESSORS ([dim])

 Class:  Inquiry function

 Returns the total number of processors (nodes) available to the
 program along an optional dimension of the processor array.

 The "dim" is not allowed for single-processor workstations.

 The result type is default integer.  On single-processor
 workstations, the result is always 1.
3 NWORKERS
 NWORKERS ()

 Class:  Elemental function

 Returns an INTEGER*4 value that represents the total number of
 processes executing an application.  However, since DIGITAL Fortran
 only does serial processing, NWORKERS always returns 1.

 NWORKERS is provided for compatibility with DIGITAL Fortran for
 OpenVMS VAX systems.
3 PACK    
 PACK (array, mask [,vector])

 Class:  Transformational function

 Takes elements from an array and packs them into a rank-one array
 under the control of a mask.

 The "mask" must be of logical type and conformable with "array".
 The "vector" must be a rank-one array with the same type and type
 parameters as "array".  Its size must be at least t, where "t" is
 the number of true elements in "mask".  If "mask" is a scalar with
 value true, "vector" must have at least as many elements as there
 are in "array".

 Elements in "vector" are used to fill out the result array if there
 are not enough elements selected by "mask."

 The result is a rank-one array with the same type and type
 parameters as "array".  If "vector" is present, the size of the
 result is that of "vector".  Otherwise, the size of the result is
 the number of true elements in "mask", or the number of elements in
 "array" (if "mask" is a scalar with value true).

 Elements in "array" are processed in array element order to form
 the result array.  Element i of the result is the element of
 "array" that corresponds to the ith true element of "mask".

 If "vector" is present and has more elements than there are true
 values in "mask", any result elements that are empty (because they
 were not true according to "mask") are set to the corresponding
 values in "vector".

 Examples:

 Consider that N is the array |0 8 0|.
                              |0 0 0|
                              |7 0 0|

 PACK (N, MASK=N .NE.  0, VECTOR= (/1, 3, 5, 9, 11, 13/) produces
 the result (7, 8, 5, 9, 11, 13).

 PACK (N, MASK=N .NE.  0) produces the result (7, 8).
3 POPCNT  
 POPCNT (integer)

 Class:  Elemental function

 A function that returns the number of 1 bits in the binary
 representation of the integer argument.  The result type is the
 same as the argument.

 Example:

 If the value of I is B'0...00011010110', the value of POPCNT(I) is
 5.
3 POPPAR  
 POPPAR (integer*8)

 Class:  Elemental function

 A function that returns parity of an integer.  The result value is
 one if there are an odd number of 1 bits in the binary
 representation of the integer argument and zero if there are an
 even number.  The result type is the same as the argument.

 Example:

 If the value of I is B'0...00011010110', the value of POPPAR(I) is
 1.
3 PRECISION
 PRECISION (number)

 Class:  Inquiry function

 Returns the decimal precision in the model representing real
 numbers with the same kind type parameter as the argument.

 The "number" can be of real or complex type; it can be scalar or
 array valued.

 The result is a scalar of type default integer.  The result has the
 value INT((DIGITS("number") - 1) * LOG10(RADIX("number"))).  If
 RADIX("number") is an integral power of 10, 1 is added to the
 result.

 Example:

 If X is a REAL*4 value, PRECISION (X) has the value 6.  The value 6
 is derived from INT ((24-1) * LOG10 (2.)) = INT (6.92...).  For
 more information on the model for REAL*4, see your language
 reference manual.
3 PRESENT 
 PRESENT (opt-argument)

 Class:  Inquiry function

 Returns whether or not an optional dummy argument is present (has
 an associated actual argument).

 Example:

 Consider the following:

 SUBROUTINE CHECK (X, Y)
   REAL X, Z
   REAL, OPTIONAL :: Y
   ...
   IF (PRESENT (Y)) THEN
     Z = Y
   ELSE
      Z = X * 2
   END IF
 END         
 ...
 CALL CHECK (15.0, 12.0)      ! Causes B to be set to 12.0
 CALL CHECK (15.0)            ! Causes B to be set to 30.0
3 PROCESSORS_SHAPE
 PROCESSORS_SHAPE ()

 Class:  Inquiry function

 Returns the shape of an implementation-dependent processor array.

 The result is a rank-one array of type default integer, whose size
 is equal to the rank of the implementation-dependent processor
 array.  The result value is the shape of that array.

 On single-processor workstations, the result value is always a
 rank-one array of size zero.
3 PRODUCT 
 PRODUCT (array, [,dim] [,mask])

 Class:  Transformational function

 Returns the product of all the elements in an entire array or in a
 specified dimension of an array.

 The "array" can be of integer or real type.  The "dim" must be a
 scalar integer with a value in the range 1 to n, where "n" is the
 rank of "array".  The "mask" must be a logical array that is
 conformable with "array".

 The result is the same data type as "array".  The result is scalar
 if "dim" is absent or "array" has rank one.  Otherwise, the result
 is an array with rank that is one less than "array", and shape (d1,
 d2,..., d"dim"-1, d"dim"+1,..., dn), where (d1, d2,..., dn) is the
 shape of "array".

 If only "array" appears, the result is the product of all elements
 of "array".  If "array" has size zero, the result is 1.

 If "array" and "mask" both appear, the result is the product of all
 elements of "array" corresponding to true elements of "mask".  If
 there are no true elements, the result is 1.

 If "dim" also appears and "array" has rank one, the value is the
 same as PRODUCT (array [,mask=mask]).  Otherwise, the value of
 element (s1, s2,..., s"dim"-1, s"dim"+1,..., sn) of PRODUCT (array,
 dim, [,mask]) is equal to PRODUCT (array (s1, s2,..., s"dim"-1, :,
 s"dim"+1, ..., sn)) [mask=mask (s1, s2, ..., s"dim"-1, :, s "dim"+1
 ..., sn)].

 Examples:

 PRODUCT ((/2, 3, 4/)) and PRODUCT ((/2, 3, 4/), DIM=1) returns the
 value 24.

 PRODUCT (C, MASK=C .LT.  0.0) returns the product of the negative
 elements of C.

 Consider that A is the array |1 4 7|.
                              |2 3 5|

 PRODUCT (A, DIM=1) returns the value (2, 12, 35).

 PRODUCT (A, DIM=2) returns the value (28, 30).
3 QEXT    
 QEXT (number)

 Class:  Elemental function

 Converts the argument to a REAL*16 value.
 +------+---------+----------+------------+-------------+      
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  1   |  QEXT   |  --      | INTEGER*2  | REAL*16     |
 |      |         |  --      | INTEGER*4  | REAL*16     |
 |      |         | QEXT     | REAL*4     | REAL*16     |
 |      |         | QEXTD    | REAL*8     | REAL*16     |
 |      |         |  --      | REAL*16    | REAL*16     |
 |      |         |  --      | COMPLEX*8  | REAL*16     |
 |      |         |  --      | COMPLEX*16 | REAL*16     |
 +------+---------+----------+------------+-------------+
3 QFLOAT  
 QFLOAT (integer)

 Class:  Elemental function

 Converts an integer value to a REAL*16 value.
 +------+---------+----------+------------+-------------+      
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  1   | QFLOAT  |  --      | INTEGER*2  | REAL*16     |
 |      |         |  --      | INTEGER*4  | REAL*16     |
 +------+---------+----------+------------+-------------+
3 RADIX   
 RADIX (number)

 Class:  Inquiry function

 Returns the base of the model representing numbers of the same type
 and kind type parameter as the argument.

 The "number" can be of integer or real type; it can be scalar or
 array valued.

 The result is a scalar of type default integer.  For an integer
 argument, the result has the value "r" as defined in the integer
 model.  For a real argument, the result has the value "b" as
 defined in the real model.

 For information on integer and real models, see your language
 reference manual.

 Examples:

 If X is a REAL*4 value, RADIX (X) has the value 2.
3 RAN     
 RAN (seed)

 Class:  Function

 Generates a general random number of the multiplicative
 congruential type.  This function returns a different REAL*4 number
 between 0.0 (inclusive) and 1.0 (exclusive) each time it is
 invoked.  The argument must be an INTEGER*4 variable or array
 element.

 For best results, you should initialize the argument to a large,
 odd value before invoking RAN the first time.  To generate
 different sets of random values, initialize the seed to a different
 value on each run.  Do not modify the seed during a run.
3 RANDOM_NUMBER
 RANDOM_NUMBER (real-number)

 Class:  Subroutine

 Returns one pseudorandom number (or an array of such numbers).  The
 argument is set to contain pseudorandom numbers from the uniform
 distribution within the range 0 <= x < 1.

 Examples:

 Consider the following:

 REAL Y, Z (5, 5)   
 ! Initialize Y with a pseudorandom number
 CALL RANDOM_NUMBER (HARVEST = Y)
 CALL RANDOM_NUMBER (Z)

 Y and Z contain uniformly distributed random numbers.
3 RANDOM_SEED
 RANDOM_SEED ([size] [, put] [, get])

 Class:  Subroutine

 Changes or queries the seed (starting point) for the pseudorandom
 number generator used by RANDOM_NUMBER.  No more than one argument
 can be specified.  If an argument is specified, it must be of
 default integer type.

 The "size" must be scalar; it is set to the number of integers (N)
 that the processor uses to hold the value of the seed.

 The "put" must be an array of rank 1 and size >= N; it is used to
 reset the value of the seed.

 The "get" must be an array of rank 1 and size >= N; it is set to
 the current value of the seed.

 If no argument is specified, a random number based on the date and
 time is assigned to the seed.

 Example:

 Consider the following:

 CALL RANDOM_SEED ( )                   ! Processor reinitializes the
                                        !  seed randomly from the date
                                        !  and time
 CALL RANDOM_SEED (SIZE = M)            ! Sets M to N
 CALL RANDOM_SEED (PUT = SEED (1 : M))  ! Sets user seed
 CALL RANDOM_SEED (GET = OLD  (1 : M))  ! Reads current seed
3 RANDU   
 RANDU (integer-1, integer-2, store)

 Class:  Subroutine

 Computes a pseudorandom number as a single-precision value.

 The integer arguments must be INTEGER(KIND=2) variables or array
 elements that contain the seed for computing the random number.
 The new seed for computing the next random number is stored into
 these integer arguments.  The "store" is a REAL(KIND=4) variable or
 array element where the computed random number is returned.

 The result is returned in "store", which must be of type
 REAL(KIND=4).  The result value is a pseudorandom number in the
 range 0.0 to 1.0.  The algorithm for computing the random number
 value is based on the values for "integer-1" and "integer-2".

 Example:

 Consider the following:

 REAL X
 INTEGER(2) I, J
 ...
 CALL RANDU (I, J, X)

 If I and J are values 4 and 6, X stores the value 5.4932479E-04.
3 RANGE   
 RANGE (number)

 Class:  Inquiry function

 Returns the decimal exponent range in the model representing
 numbers with the same kind type parameter as the argument.

 The argument can be of type integer, real, or complex.  It can be
 scalar or array valued.

 The result is a scalar of type default integer.  For an integer
 argument, the result has the value INT (LOG10 ( HUGE("number") )).
 For a real or complex argument, the result has the value INT(MIN
 (LOG10( HUGE("number") ), -LOG10( TINY("number") ))).

 For information on the integer and real models, see your language
 reference manual.

 Example:

 If X is a REAL*4 value, RANGE (X) has the value 37.  (HUGE(X) = (1
 - 2**-24) x 2**128 and TINY(X) = 2**-126.)
3 REAL    
 REAL (number [,kind])

 Class:  Elemental function

 Converts the argument to a real value.

 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  1   |  REAL   |  --      | INTEGER*1  | REAL*4      |
 |      |         | FLOATI   | INTEGER*2  | REAL*4      |
 |      |see note1| FLOAT    | INTEGER*4  | REAL*4      |
 |      |         | REAL     | INTEGER*4  | REAL*4      |
 |      |         | FLOATK   | INTEGER*8  | REAL*4      |
 |      |         |  --      | REAL*4     | REAL*4      |
 |      |see note2| SNGL     | REAL*8     | REAL*4      |
 |      |         | SNGLQ    | REAL*16    | REAL*4      |
 |      |         |  --      | COMPLEX*8  | REAL*4      |
 |      |         |  --      | COMPLEX*16 | REAL*4      |
 +------+---------+----------+------------+-------------+

 Note1: Or FLOATJ. For compatibility with older versions of 
        Fortran, FLOAT can also be specified as a generic 
        function.
 Note2: For compatibility with older versions of 
        Fortran, SNGL can also be specified as a generic 
        function. The generic SNGL includes specific
        function REAL, which takes a REAL*4 argument and 
        produces a REAL*4 result.

 These functions cannot be passed as actual arguments.

 REAL is also a specific name for a function that returns the real
 part of a complex number.  The argument must be a COMPLEX*8 data
 type.  The result is a REAL*4 data type.

 The setting of real size compiler options can affect this function.
3 REPEAT  
 REPEAT (string, ncopies)

 Class:  Transformational function

 Concatenates several copies of a string.  The kind type parameter
 is the same as "string".  The value of the result is the
 concatenation of "ncopies" copies of "string".

 Examples:

 REPEAT ('S', 3) has the value SSS.

 REPEAT ('ABC', 0) has the value of a zero-length string.
3 RESHAPE  
 RESHAPE (source, shape [,pad] [,order])

 Class:  Transformational function

 Constructs an array with a different shape from the argument
 "source" array.

 The size of the "source" array must be >= PRODUCT(shape) if "pad"
 is absent or has size zero.  The "shape" must be an integer array
 of up to 7 elements, with rank one and constant size.  Its size
 must be positive; its elements must not have negative values.  The
 "pad" must be an array of the same type and kind type parameters as
 "source".  It is used to fill in extra values if the result array
 is larger than "source".  The "order" must be an integer array with
 the same shape as "shape".

 The result is an array of shape "shape" with the same type and kind
 type parameters as "source".  The size of the result is the product
 of the values of the elements of "shape".

 In the result array, the array elements of "source" are placed in
 the order of dimensions specified by "order".  If "order" is
 omitted, the array elements are placed in normal array element
 order.

 The array elements of "source" are followed (if necessary) by the
 array elements of "pad" in array element order.  If necessary,
 additional copies of "pad" follow until all the elements of the
 result array have values.

 Examples:

 RESHAPE ((/3, 4, 5, 6, 7, 8/), (/2, 3/)) has the value

  |3 5 7|.
  |4 6 8|.

 RESHAPE ((/3, 4, 5, 6, 7, 8/), (/2, 4/), (/1, 1/), (/2, 1/)) has
 the value

  |3 4 5 6|.
  |7 8 1 1|
3 RRSPACING
 RRSPACING (real-number)

 Class:  Elemental function

 Returns the reciprocal of the relative spacing of model numbers
 near the argument value.

 The result type is the same as the argument.  For information on
 the model for real numbers, see your language reference manual.

 Example:

 If -3.0 is a REAL*4 value, RRSPACING (-3.0) has the value 0.75 x
 2**24.
3 SCALE   
 SCALE (real-number, integer)

 Class:  Elemental function

 Returns the value of the exponent part (of the model for the
 argument) changed by a specified value.

 The result type is the same as the "real-number" argument.  For
 information on the real model, see your language reference manual.

 Examples:

 If 3.0 is a REAL*4 value, SCALE (3.0, 2) has the value 12.0 and
 SCALE (3.0, 3) has the value 24.0.
3 SCAN    
 SCAN (string, set [,back])

 Class:  Elemental function

 Scans a string for any character in a set of characters.  The "set"
 is of type character (the same type as "string").  The "back" is of
 type logical.

 The result type is default integer.

 If "back" is absent (or is present with the value false) and
 "string" has at least one character that is in "set", the value of
 the result is the position of the leftmost character of "string"
 that is in "set".

 If "back" is present with the value true and "string" has at least
 one character that is in "set", the value of the result is the
 position of the rightmost character of "string" that is in "set".

 If no character of "string" is in "set" or the length of "string"
 or "set" is zero, the value of the result is zero.

 Examples:

 SCAN ('ASTRING', 'ST') has the value 2.

 SCAN ('ASTRING', 'ST', BACK=.TRUE.) has the value 3.

 SCAN ('ASTRING', 'CD') has the value zero.
3 SECNDS  
 SECNDS (real-number)

 Class:  Elemental function

 Returns the number of seconds since midnight minus the value of the
 argument.  The argument must be a REAL*4 data type.  The return
 value is a REAL*4 data type.  The time returned is accurate to .01
 seconds.
3 SELECTED_INT_KIND
 SELECTED_INT_KIND (integer)

 Class:  Transformational function

 Returns the value of the kind type parameter of an integer data
 type.

 The result is a scalar of type default integer.

 Example:

 SELECTED_INT_KIND (6) = 4
3 SELECTED_REAL_KIND
 SELECTED_REAL_KIND ([integer-p] [,integer-r])

 Class:  Transformational function

 Returns the value of the kind type parameter of a real data type.

 The "integer-p" specifies decimal precision.  The "integer-r"
 specifies decimal exponent range.  At least one argument must be
 specified.

 The result is a scalar of type default integer.

 Example:

 SELECTED_REAL_KIND (6, 70) = 8
3 SET_EXPONENT
 SET_EXPONENT (real-number, integer)

 Class:  Elemental function

 Returns the value of the exponent part (of the model for the
 argument) set to a specified value.

 The result type is the same as the "real-number" argument.  For
 information on the real model, see your language reference manual.

 Example:

 If 3.0 is a REAL*4 value, SET_EXPONENT (3.0, 1) has the value 1.5.
3 SHAPE   
 SHAPE (source)

 Class:  Inquiry function

 Returns the shape of an array or scalar argument.

 The "source" must not be an assumed-size array, a disassociated
 pointer, or an allocatable array that is not allocated.

 The result is a rank-one default integer array whose size is equal
 to the rank of "source".  The value of the result is the shape of
 "source".

 Examples:

 SHAPE (2) has the value of a rank-one array of size zero.

 If B is declared as B(2:4, -3:1), then SHAPE (B) has the value (3,
 5).
3 SIGN    
 SIGN (arg1, sign-arg2)

 Class:  Elemental function

 Assigns the sign of the second argument to the absolute value of
 the first.

 If the second argument is of type real and zero, the value of the
 result is |arg1|.  However, if the -assume minus0 compiler option
 is specified and the processor can distinguish between positive and
 negative real zero, the following occurs:

  o  If the second argument is positive real zero, the value of the
     result is |arg1|.

  o  If the second argument is negative real zero, the value of the
     result is -|arg1|.

 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  2   |  SIGN   |  --      | INTEGER*1  | INTEGER*1   |
 |      |         | IISIGN   | INTEGER*2  | INTEGER*2   |
 |      |see note | ISIGN    | INTEGER*4  | INTEGER*4   |
 |      |         | KISIGN   | INTEGER*8  | INTEGER*8   |
 |      |         | SIGN     | REAL*4     | REAL*4      |
 |      |         | DSIGN    | REAL*8     | REAL*8      |
 |      |         | QSIGN    | REAL*16    | REAL*16     |
 +------+---------+----------+------------+-------------+

 NOTE: Or JISIGN.  For compatibility with older versions 
       of Fortran, ISIGN can also be specified as a generic
       function.
3 SIN     
 SIN (number)

 Class:  Elemental function

 Returns the sine of the argument.  The argument must be in radians;
 it is treated modulo 2*pi.
 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  1   |  SIN    | SIN      | REAL*4     | REAL*4      |
 |      |         | DSIN     | REAL*8     | REAL*8      |
 |      |         | QSIN     | REAL*16    | REAL*16     |
 |      |         | CSIN     | COMPLEX*8  | COMPLEX*8   |
 |      |         | CDSIN    | COMPLEX*16 | COMPLEX*16  |
 |      |         | ZSIN     | COMPLEX*16 | COMPLEX*16  |
 +------+---------+----------+------------+-------------+
3 SIND    
 SIND (number)

 Class:  Elemental function

 Returns the sine of the argument.  The argument must be in degrees;
 it is treated modulo 360.
 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  1   |  SIND   | SIND     | REAL*4     | REAL*4      |
 |      |         | DSIND    | REAL*8     | REAL*8      |
 |      |         | QSIND    | REAL*16    | REAL*16     |
 +------+---------+----------+------------+-------------+
3 SINH    
 SINH (number)

 Class:  Elemental function

 Returns the hyperbolic sine of the argument.
 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  1   |  SINH   | SINH     | REAL*4     | REAL*4      |
 |      |         | DSINH    | REAL*8     | REAL*8      |
 |      |         | QSINH    | REAL*16    | REAL*16     |
 +------+---------+----------+------------+-------------+
3 SIZE    
 SIZE (array [,dim])

 Class:  Inquiry function

 Returns the total number of elements in an array, or the extent of
 an array along a specified dimension.

 The "array" must not be a disassociated pointer or an allocatable
 array that is not allocated.  It can be an assumed-size array if
 "dim" is present with a value less than the rank of "array".  The
 "dim" must be a scalar integer with a value in the range 1 to n,
 where "n" is the rank of "array".

 The result is a scalar of type integer.  If "dim" is present, the
 result is the extent of dimension "dim" in "array"; otherwise, the
 result is the total number of elements in "array".

 Example:

 If B is declared as B(2:4, -3:1), then SIZE (B, DIM=2) has the
 value 5 and SIZE (B) has the value 15.
3 SIZEOF  
 SIZEOF (arg)

 Class:  Elemental function

 Returns the number of bytes of storage used by the argument.
 +------+---------+----------+------------------+-------------+   
 | Args | Generic | Specific |    Argument      | Result Type |
 +------+---------+----------+------------------+-------------+
 |   1  |   --    | SIZEOF   | Anything with a  | INTEGER*8   |
 |      |         |   --     | valid data type, |             |
 |      |         |          | except assumed-  |             |
 |      |         |          | size arrays.     |             |
 +------+---------+----------+------------------+-------------+
3 SPACING 
 SPACING (real-number)

 Class:  Elemental function

 Returns the absolute spacing of model numbers near the argument
 value.  The result type is the same as the argument.

 Example:

 If 3.0 is a REAL*4 value, SPACING (3.0) has the value 2**-22.
3 SPREAD  
 SPREAD (source, dim, ncopies)

 Class:  Transformational function

 Creates a replicated array with an added dimension by making copies
 of existing elements along a specified dimension.

 The "source" can be an array or scalar.  The "dim" is a scalar of
 type integer.  It must have a value in the range 1 to n +
 1(inclusive), where "n" is the rank of "source".  The integer
 scalar "ncopies" becomes the extent of the added dimension in the
 result.

 The result is an array of the same type as "source" and of rank
 that is one greater than "source".

 If "source" is an "array", each array element in dimension "dim" of
 the result is equal to the corresponding array element in "source".

 If "source" is a scalar, the result is a rank-one array with
 "ncopies" elements, each with the value "source".

 Examples:

 SPREAD ("B", 1, 4) is the character array (/"B", "B", "B", "B"/).

 B is the array (3, 4, 5) and NC has the value 4.

 SPREAD (B, DIM=1, NCOPIES=NC) produces the array

  |3 4 5|
  |3 4 5|.
  |3 4 5|
  |3 4 5|

 SPREAD (B, DIM=2, NCOPIES=NC) produces the array

  |3 3 3 3|
  |4 4 4 4|.
  |5 5 5 5|
3 SNGL    
 See the REAL function.
3 SQRT    
 SQRT (number)

 Class:  Elemental function

 Returns the square root of the argument.
 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  1   |  SQRT   | SQRT     | REAL*4     | REAL*4      |
 |      |         | DSQRT    | REAL*8     | REAL*8      |
 |      |         | QSQRT    | REAL*16    | REAL*16     |
 |      |         | CSQRT    | COMPLEX*8  | COMPLEX*8   |
 |      |         | CDSQRT   | COMPLEX*16 | COMPLEX*8   |
 |      |         | ZSQRT    | COMPLEX*16 | COMPLEX*8   |
 +------+---------+----------+------------+-------------+

 The argument for SQRT, DSQRT, and QSORT must be greater than or
 equal to zero.

 The result of CSQRT, CDSQRT, and ZSQRT is the principal value, with
 the real part greater than or equal to zero.  If the real part is
 zero, the result is the principal value, with the imaginary part
 greater than or equal to zero.
3 SUM     
 SUM (array [,dim] [,mask])

 Class:  Transformational function

 Returns the sum of all the elements in an entire array or in a
 specified dimension of an array.

 The "array" can be of integer or real type.  The "dim" must be a
 scalar integer with a value in the range 1 to n, where "n" is the
 rank of "array".  The "mask" must be a logical array that is
 conformable with "array".

 The result is the same data type as "array".  The result is scalar
 if "dim" is absent or "array" has rank one.  Otherwise, the result
 is an array with rank that is one less than "array", and shape (d1,
 d2,..., d"dim"-1, d"dim"+1,..., dn), where (d1, d2,..., dn) is the
 shape of "array".

 If only "array" appears, the result is the sum of all elements of
 "array".  If "array" has size zero, the result is zero.

 If "array" and "mask" both appear, the result is the sum of all
 elements of "array" corresponding to true elements of "mask".  If
 there are no true elements, the result is zero.

 If "dim" also appears and "array" has rank one, the value is the
 same as SUM (array [,mask=mask]).  Otherwise, the value of element
 (s1, s2,..., s"dim"-1, s"dim"+1,..., sn) of SUM (array, dim,
 [,mask]) is equal to SUM (array (s1, s2,..., s"dim"-1, :, s"dim"+1,
 ..., sn)) [mask=mask (s1, s2, ..., s"dim"-1, :, s "dim"+1 ...,
 sn)].

 Examples:

 SUM ((/2, 3, 4/)) and SUM ((/2, 3, 4/), DIM=1) returns the value 9.

 SUM (B, MASK=B .LT.  0.0) returns the arithmetic sum of the
 negative elements of B.

 Consider that C is the array:

  |1 2 3|
  |4 5 6|.

 SUM (C, DIM=1) returns the value (5, 7, 9).

 SUM (C, DIM=2) returns the value (6, 15).
3 SYSTEM_CLOCK
 SYSTEM_CLOCK ([count] [,count-rate] [,count-max])

 Class:  Subroutine

 Returns integer data from a real-time clock.

 All arguments are scalar of type default integer.  The "clock" is
 set to a value based on the current value of the processor clock.
 The value is increased by one for each clock count until the value
 "countmax" is reached, and is reset to zero at the next count.
 ("count" lies in the range 0 to "countmax".) The "countrate" is set
 to the number of processor clock counts per second (1000 for
 INTEGER*2, 10000 for INTEGER*4, and 1000000 for INTEGER*8).

 SYSTEM_CLOCK returns the number of seconds from 00:00 Coordinated
 Universal Time (CUT) 1 JAN 1970.  The number is returned with no
 bias.  To get the elapsed time, you must call SYSTEM_CLOCK twice,
 and subtract the starting time value from the ending time value.

 Examples:

 Consider the following:

   INTEGER(2) :: IC2, CRATE2, CMAX2
   INTEGER(4) :: IC4, CRATE4, CMAX4
   CALL SYSTEM_CLOCK(COUNT=IC2, COUNT_RATE=CRATE2, COUNT_MAX=CMAX2)
   CALL SYSTEM_CLOCK(COUNT=IC4, COUNT_RATE=CRATE4, COUNT_MAX=CMAX4)
   PRINT *, IC2, CRATE2, CMAX2
   PRINT *, IC4, CRATE4, CMAX4
   END

 This program was run on Thursday Dec 11, 1997 at 14:23:55 EST and
 produced the following output:
   13880   1000  32767
   1129498807       10000  2147483647
3 TAN     
 TAN (real-number)

 Class:  Elemental function

 Returns the tangent of the argument.  The argument must be in
 radians; it is treated modulo 2*pi.

 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  1   |  TAN    | TAN      | REAL*4     | REAL*4      |
 |      |         | DTAN     | REAL*8     | REAL*8      |
 |      |         | QTAN     | REAL*16    | REAL*16     |
 +------+---------+----------+------------+-------------+
3 TAND    
 TAND (real-number)

 Class:  Elemental function

 Returns the tangent of the argument.  The argument must be in
 degrees; it is treated modulo 360.

 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  1   |  TAND   | TAND     | REAL*4     | REAL*4      |
 |      |         | DTAND    | REAL*8     | REAL*8      |
 |      |         | QTAND    | REAL*16    | REAL*16     |
 +------+---------+----------+------------+-------------+
3 TANH    
 TANH (real-number)

 Class:  Elemental function

 Returns the hyperbolic tangent of the argument.

 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  1   |  TANH   | TANH     | REAL*4     | REAL*4      |
 |      |         | DTANH    | REAL*8     | REAL*8      |
 |      |         | QTANH    | REAL*16    | REAL*16     |
 +------+---------+----------+------------+-------------+
3 TIME    
 TIME (buf)

 Class:  Elemental function

 Places the current time in 24-hour ASCII format in the argument.
 The time is returned as an 8-byte ASCII character string having the
 following form:

    hh:mm:ss

 A 24-hour clock is used.

 The "buf" is an 8-byte variable, array, array element, or character
 substring.  If "buf" is numeric type and smaller than 8 bytes, data
 corruption can occur.

 If "buf" is character type, its associated length is passed to the
 subroutine.  If "buf" is smaller than 8 bytes, the subroutine
 truncates the date to fit in the specified length.  Note that if a
 CHARACTER array is passed, the subroutine stores the time in the
 first array element, using the element length, not the length of
 the entire array.  For example, consider the following:

 CHARACTER*1 HOUR(8)
 ...
 CALL TIME(HOUR)

 The length of the first array element in CHARACTER array HOUR is
 passed to the TIME subroutine.  The subroutine then truncates the
 time to fit into the one-character element, producing an incorrect
 result.
3 TINY    
 TINY (real-number)

 Class:  Inquiry function

 Returns the smallest number in the model representing the same type
 and kind type parameter as the argument.

 The argument must be of type real; it can be scalar or array
 valued.  The result type is scalar of the same type and kind type
 parameter as the argument.  The real model is described in your
 language reference manual.

 Examples:

 If X is of type REAL*4, TINY (X) has the value 2**-126.
3 TRAILZ   
 TRAILZ (integer)

 Class:  Elemental function

 Returns the number of trailing zeros in the binary representation
 of the integer argument.  The result type is the same as the
 argument.

 Example:

 Consider the following:

   INTEGER*8 J, TWO
   PARAMETER (TWO=2)
   DO J= -1, 40
     TYPE *, TRAILZ(TWO**J)  ! Prints 64, then 0 up to
   ENDDO                     !   40 (trailing zeros)
   END
3 TRANSFER
 TRANSFER (source, mold [,size])

 Class:  Transformational function

 Converts the bit pattern of "source" according to the type and kind
 type parameters of "mold".

 The "source" and "mold" can be of any type; they can be scalar or
 array valued.  The "mold" provides the type characteristics (not a
 value) for the result.  The "size" must be scalar of type integer;
 it provides the number of elements for the output result.

 If "mold" is a scalar and "size" is absent, the result is a scalar.

 If "mold" is an array and "size" is absent, the result is a
 rank-one array.  Its size is the smallest that is possible to hold
 all of "source".

 If "size" is present, the result is a rank-one array of size
 "size".

 If the physical representation of the result is larger than
 "source", the result contains "source"'s bit pattern in its
 right-most bits; the left-most bits of the result are undefined.

 If the physical representation of the result is smaller than
 "source", the result contains the right-most bits of "source"'s bit
 pattern.

 Examples:

 TRANSFER (1082130432, 0.0) has the value 4.0 (on processors that
 represent the values 4.0 and 1082130432 as the string of binary
 digits 0100 0000 1000 0000 0000 0000 0000 0000).

 TRANSFER ((/2.2, 3.3, 4.4/), ((0.0, 0.0))) results in a scalar
 whose value is (2.2, 3.3).

 TRANSFER ((/2.2, 3.3, 4.4/), (/(0.0, 0.0)/)) results in a complex
 rank-one array of length 2.  Its first element is (2.2,3.3) and its
 second element has a real part with the value 4.4 and an undefined
 imaginary part.

 TRANSFER ((/2.2, 3.3, 4.4/), (/(0.0, 0.0)/), 1) results in a
 complex rank-one array having one element with the value (2.2,
 3.3).
3 TRANSPOSE
 TRANSPOSE (matrix)

 Class:  Transformational function

 Transposes an array of rank two (can be any data type).

 The result is a rank-two array with the same type and kind type
 parameters as "matrix".  Its shape is (n, m), where (m, n) is the
 shape of "matrix".  For example, if the shape of "matrix" is (4,6),
 the shape of the result is (6,4).

 Element (i, j) of the result has the value matrix(j, i), where "i"
 is in the range 1 to n, and "j" is in the range 1 to m.

 Examples:

 Consider that B is the array:

  |2 3 4|
  |5 6 7|.
  |8 9 1|

 TRANSPOSE (B) has the value

  |2 5 8|
  |3 6 9|.
  |4 7 1|
3 TRIM    
 TRIM (string)

 Class:  Transformational function

 Returns the argument with trailing blanks removed.

 The "string" is a scalar of type character.  The result type is
 character with the same kind type parameter as "string".  Its
 length is the length of "string" minus the number of trailing
 blanks in "string".

 The value of the result is the same as "string", except any
 trailing blanks are removed.  If "string" contains only blank
 characters, the result has zero length.

 Examples:

 TRIM ('  NAME    ') has the value '  NAME'.

 TRIM ('  C  D     ') has the value '  C  D'.
3 UBOUND  
 UBOUND (array [,dim])

 Class:  Inquiry function

 Returns the upper bounds for all dimensions of an array, or the
 upper bound for a specified dimension.

 The "array" cannot be an allocatable array that is not allocated,
 or a disassociated pointer.  The "dim" is a scalar integer with a
 value in the range 1 to n, where "n" is the rank of "array".

 The result type is default integer.  If "dim" is present, the
 result is a scalar.  Otherwise, the result is a rank-one array with
 one element for each dimension of "array".  Each element in the
 result corresponds to a dimension of "array".

 If "array" is an array section or an array expression that is not a
 whole array or array structure component, UBOUND (array,dim) has a
 value equal to the number of elements in the given dimension.

 Examples:

 Consider the following:

 REAL ARRAY_A (1:3, 5:8)
 REAL ARRAY_B (2:8, -3:20)

 UBOUND (ARRAY_A) is (3, 8).  UBOUND (ARRAY_A, DIM=2) is 8.

 UBOUND (ARRAY_B) is (8, 20).  UBOUND (ARRAY_B (5:8, :)) is (4,24)
 because the number of elements is significant for array section
 arguments.
3 UNPACK  
 UNPACK (vector, mask, field)

 Class:  Transformational function

 Takes elements from a rank-one array and unpacks them into another
 (possibly larger) array under the control of a mask.

 The "vector" must be a rank-one array of any type.  Its size must
 be at least t, where "t" is the number of true elements in "mask".
 The "mask" must be of logical type; it determines where elements of
 "vector" are placed when they are unpacked.

 The "field" must be of the same type and type parameters as
 "vector" and conformable with "mask".  Elements in "field" are
 inserted into the result array when the corresponding "mask"
 element has the value false.

 The result is an array with the same shape as "mask", and the same
 type and type parameters as "vector".

 Elements in the result array are filled in array element order.  If
 element i of the result is true, the corresponding element of the
 result is filled by the next element in "vector".

 Examples:

 Consider that N is the array |0 0 1|, P is the array (2, 3, 4, 5),
                              |1 0 1|
                              |1 0 0|

 and Q is the array |T F F|
                    |F T F|.
                    |T T F|

 UNPACK (P, MASK=Q, FIELD=N) produces the result

  |2 0 1|
  |1 4 1|.
  |3 5 0|

 UNPACK (P, MASK=Q, FIELD=1) produces the result

  |2 1 1|
  |1 4 1|.
  |3 5 1|
3 VERIFY  
 VERIFY (string, set [,back])

 Class:  Elemental function

 Verifies that a set of characters contains all the characters in a
 string by identifying the first character in the string that is not
 in the set.

 The "set" must be of type character with the same kind type
 parameter as "string".  The "back" must be of type logical.

 The result type is default integer.

 If "back" is absent (or is present with the value false) and
 "string" has at least one character that is not in "set", the value
 of the result is the position of the leftmost character of "string"
 that is not in "set".

 If "back" is present with the value true and "string" has at least
 one character that is not in "set", the value of the result is the
 position of the rightmost character of "string" that is not in
 "set".

 If each character of "string" is in "set" or the length of "string"
 is zero, the value of the result is zero.

 Examples:

 VERIFY ('CDDDC', 'C') has the value 2.

 VERIFY ('CDDDC', 'C', BACK=.TRUE.) has the value 4.

 VERIFY ('CDDDC', 'CD') has the value zero.
3 ZEXT    
 ZEXT (integer)

 Class:  Elemental function

 Returns the value of the argument, zero extended.
 +------+----------+----------+------------+-------------+        
 | Args | Generic  | Specific |  Argument  | Result Type |
 +------+----------+----------+------------+-------------+
 |  1   |  ZEXT    | IZEXT    | LOGICAL*1  | INTEGER*2   |
 |      |          |  --      | LOGICAL*2  | INTEGER*2   |
 |      |          |  --      | INTEGER*1  | INTEGER*2   |
 |      |          |  --      | INTEGER*2  | INTEGER*2   |
 |      |          | JZEXT    | LOGICAL*1  | INTEGER*4   |
 |      |          |  --      | LOGICAL*2  | INTEGER*4   |
 |      |          |  --      | LOGICAL*4  | INTEGER*4   |
 |      |          |  --      | INTEGER*1  | INTEGER*4   |
 |      |          |  --      | INTEGER*2  | INTEGER*4   |
 |      |          |  --      | INTEGER*4  | INTEGER*4   |
 |      |          | KZEXT    | LOGICAL*1  | INTEGER*8   |
 |      |          |  --      | LOGICAL*2  | INTEGER*8   |
 |      |          |  --      | LOGICAL*4  | INTEGER*8   |
 |      |          |  --      | LOGICAL*8  | INTEGER*8   |
 |      |          |  --      | INTEGER*1  | INTEGER*8   |
 |      |          |  --      | INTEGER*2  | INTEGER*8   |
 |      |          |  --      | INTEGER*4  | INTEGER*8   |
 |      |          |  --      | INTEGER*8  | INTEGER*8   |
 +------+----------+----------+------------+-------------+

 The setting of integer size compiler options can affect this
 function.
2 Source_Format     
 Source code can be in free, fixed, or tab format.  Fixed or tab
 forms must not be mixed with free form in the same source program,
 but different source forms can be used in different source
 programs.

 All source forms allow lowercase characters to be used as an
 alternative to uppercase characters.

 More than one statement (or partial statement) can appear on a
 single source line if a statement separator is placed between the
 statements.

 The statement separator is a semicolon character (;).  Consecutive
 semicolons (with or without intervening blanks) are considered to
 be one semicolon.  If a semicolon is the last character on a line,
 or the last character before a comment, it is ignored.
3 Free_Form
 In free source form, statements are not limited to specific
 positions on a source line, and a line can contain from 0 to 132
 characters.

 Blank characters are significant in free source form.  The
 following are rules for blank characters:

  o  Blank characters must not appear in lexical tokens, except
     within a character context.  For example, there can be no
     blanks between the exponentiation operator **.  Blank
     characters can be used freely between lexical tokens to improve
     legibility.

  o  Blank characters must be used to separate names, constants, or
     labels from adjacent keywords, names, constants, or labels.
     For example, consider the following statements:

       INTEGER NUM
       GO TO 40
       20 DO K=1,8

     The blanks are required after INTEGER, TO, 20, and DO.

  o  Some adjacent keywords must have one or more blank characters
     between them.  Others do not require any; for example, BLOCK
     DATA can also be spelled BLOCKDATA.  The following list shows
     which keywords have optional or required blanks.

     Optional Blanks           Required Blanks
     ----------------          ----------------
     BLOCK DATA                CASE DEFAULT
     DOUBLE COMPLEX            DO WHILE
     DOUBLE PRECISION          IMPLICIT type
     ELSE IF                   IMPLICIT NONE
     END BLOCK DATA            INTERFACE ASSIGNMENT
     END DO                    INTERFACE OPERATOR
     END FILE                  MODULE PROCEDURE
     END FORALL                RECURSIVE FUNCTION
     END FUNCTION              RECURSIVE SUBROUTINE
     END IF                    RECURSIVE type FUNCTION
     END INTERFACE             type FUNCTION
     END MODULE                type RECURSIVE FUNCTION
     END PROGRAM
     END SELECT
     END SUBROUTINE
     END TYPE
     END WHERE
     GO TO
     IN OUT
     SELECT CASE


 The exclamation point character (!) indicates a comment if it is
 within a source line, or a comment line if it is the first
 character in a source line.

 The ampersand character (&) indicates a continuation line (unless
 it appears in a Hollerith or character constant, or within a
 comment).  The continuation line is the first noncomment line
 following the ampersand.  Although Fortran 90 permits up to 39
 continuation lines in free-form programs, DIGITAL Fortran allows up
 to 511 continuation lines.

 The following shows a continued statement:

 TCOSH(Y) = EXP(Y) + &        ! The initial statement line
            EXP(-Y)           ! A continuation line

 If the first nonblank character on the next noncomment line is an
 ampersand, the statement continues at the character following the
 ampersand.  For example, the preceding example can be written as
 follows:

 TCOSH(Y) = EXP(Y) + &         
           & EXP(-Y)            

 If a lexical token must be continued, the first nonblank character
 on the next noncomment line must be an ampersand followed
 immediately by the rest of the token.  For example:

 TCOSH(Y) = EXP(Y) + EX&
           &P(-Y)            

 If you indent the continuation line of a character constant, an
 ampersand must be the first character of the continued line;
 otherwise, the blanks at the beginning of the continuation line
 will be included as part of the character constant.  For example:

 ADVERTISER = "Davis, O'Brien, Chalmers & Peter&
                  &son"

 The ampersand cannot be the only nonblank character in a line, or
 the only nonblank character before a comment; an ampersand in a
 comment is ignored.
3 Fixed_and_Tab_Format
 Each Fortran line has the following four fields:

   Statement label field           Columns 1-5
   Continuation indicator field    Column 6
   Statement field                 Columns 7-72 (if you specify 
                                     the EXTEND_SOURCE compiler
                                     option or OPTIONS/EXTEND_SOURCE, 
                                     statements extend to column 132)
   Sequence number field           Columns 73-80

4 Fixed   
 A Fortran line is divided into fields for the required information.
 Each column represents a single character.

  COLUMN    FIELD
  ------    -----
      1     Indicator: Comment(C,c,*,!,blank) or Debug(D,d)
    1-5     Label (any decimal integer except zero)
      6     Indicator: Continuation of statement (any character
                  except zero or space)
   7-72     Statement Field (up to column 72)
  73-80     Sequence Number (optionally to column 132 -- ignored)


                                NOTE

         This source format is obsolescent  in  Fortran  95.
         DIGITAL  Fortran  flags  obsolescent  features, but
         fully supports them.

4 Tab     
 A Fortran line is divided into fields for the required information.
 Each column represents a single character.  You cannot specify a
 sequence number field using this method of coding.

  COLUMN   FIELD
  ------   -----
  (before tab)
    1      Indicator: Comment(C,c,*,!,blank) or Debug(D,d)
  1-5      Label (any decimal integer except zero)
  (after first tab)
    6      Indicator: Continuation of statement (any digit 1-9)
  (after second tab)
           Statement Field (up to column 72)

 Tabs are treated as single characters.
3 Example   
 The following example is valid for all source forms:

 Column:

 12345678...                                                            73
 _________________________________________________________________________

 ! Define the user function MY_SIN

       DOUBLE PRECISION FUNCTION MY_SIN(X)
         MY_SIN = X - X**3/FACTOR(3) + X**5/FACTOR(5)                    &
      &          - X**7/FACTOR(7)
       CONTAINS
         INTEGER FUNCTION FACTOR(N)
          FACTOR = 1
          DO 10 I = N, 1, -1
   10     FACTOR = FACTOR * I
         END FUNCTION FACTOR
       END FUNCTION MY_SIN
2 Statements        
 Statements in a Fortran program unit follow a required order.  In
 the following figure, vertical lines separate statement types that
 can be interspersed.  For example, DATA statements can be
 interspersed with executable statements.  Horizontal lines indicate
 statement types that cannot be interspersed.  For example, type
 declaration statements cannot be interspersed with executable
 statements.










 +-------+--------------------------------------------------------+
 |       |                  OPTIONS Statements                    |
 |       |--------------------------------------------------------|
 |       |       PROGRAM, FUNCTION, SUBROUTINE, MODULE, or        |
 |       |                BLOCK DATA Statements                   |
 |       |--------------------------------------------------------|
 |       |                    USE Statements                      |
 |       |---------+----------------------------------------------|
 |COMMENT|         |       IMPLICIT NONE Statements               |
 | Lines,|         |------------+-------------------+-------------|
 |INCLUDE|NAMELIST,| PARAMETER  |  IMPLICIT Statements            |
 |State- | FORMAT, |------------+---------------------------------|
 | ments,|   &     |            | Derived-Type Definitions,       |
 |  &    | ENTRY   | PARAMETER  | Interface Blocks, Type          |
 |Direc- | State-  | and DATA   | Declaration Statements, State-  |
 | tives |  ments  | Statements | ment Function Statements, and   |
 |       |         |            | Specification Statements        |
 |       |         +------------+---------------------------------|
 |       |         |   DATA     | Executable Statements           | 
 |       |         | Statements |                                 |
 |       |---------+----------------------------------------------|
 |       |                CONTAINS Statement                      |
 |       |--------------------------------------------------------|
 |       |    Internal Subprograms or Module Subprograms          |
 |-------+--------------------------------------------------------|
 |                     END Statement                              |
 +----------------------------------------------------------------+
3 Directives              
 You can use directives in a Fortran source program to influence
 certain aspects of the compilation process.

 General directives begin with the cDEC$ prefix.  These directives
 are enabled in all Fortran compilation units, regardless of the
 options used on the command line.

 The general directives are:

 ALIAS                       MESSAGE
 ATTRIBUTES                  OBJCOMMENT
 DECLARE and NODECLARE       OPTIONS
 DEFINE and UNDEFINE         PACK
 FIXEDFORMLINESIZE           PSECT 
 FREEFORM and NOFREEFORM     REAL
 IDENT                       STRICT and NOSTRICT
 IF and IF DEFINED           SUBTITLE and TITLE 
 INTEGER

 The "c" in the directive prefix (cDEC$) is one of the following:  C
 (or c), !, or *.

 The following are source form rules for directive prefixes:

  o  Prefixes beginning with C (or c) and * are only allowed in
     fixed and tab source forms.

     In these source forms, the prefix must appear in columns 1
     through 5; column 6 must be a blank or tab.  From column 7 on,
     blanks are insignificant, so the directive can be positioned
     anywhere on the line after column 6.  A directive ends in
     column 72 (or column 132, if a compiler option is specified).

  o  Prefixes beginning with !  are allowed in all source forms.

     In fixed and tab source forms, a prefix beginning with !  must
     follow the same rules for prefixes beginning with C, c, or *
     (see above).

     In free source form, the prefix need not start in column 1, but
     it cannot be preceded by any nonblank characters on the same
     line.  It can only be preceded by whitespace.


 General directives cannot be continued.

 A comment can follow a directive on the same line.

 Additional Fortran statements (or directives) cannot appear on the
 same line as the general directive.

 General directives cannot appear within a continued Fortran
 statement.

 If a blank common is used in a general compiler directive, it must
 be specified as two slashes (/ /).
4 ALIAS       
 cDEC$ ALIAS

 Specifies an alternate external name to be used when referring to
 external subprograms.  It takes the following form:

 cDEC$ ALIAS internal-name, external name

   c               Is one of the following: C (or c), !, or *.

   internal-name   Is the name of the subprogram as used 
                   in the current program unit.

   external name   Is a name, or a character constant delimited 
                   by quotation marks or apostrophes.

 If a name is specified, the name (in uppercase) is used as the
 external name for the specified "internal-name".  If a character
 constant is specified, it is used as is; the string is not changed
 to uppercase nor are blanks removed.

 The ALIAS directive affects only the external name used for
 references to the specified "internal-name".

 Names that are not acceptable to the linker will cause link-time
 errors.

 This directive can be useful when compiling applications written
 for other platforms that have different naming conventions.
4 ATTRIBUTES      
 cDEC$ ATTRIBUTES

 Lets you specify properties for data objects and procedures.  It
 takes the following form:

 cDEC$ ATTRIBUTES att [,att]... :: object [,object]...

   c        Is one of the following: C (or c), !, or *.
   
   att      Is one of the following properties:
            ALIAS                REFERENCE
            C                    STDCALL
            DLLEXPORT (WNT,W95)  VALUE
            DLLIMPORT (WNT,W95)  VARYING
            EXTERN

   object   Is the name of a data object or procedure.

 The properties can be used in function and subroutine definitions,
 in type declarations, and with the INTERFACE and ENTRY statements.

 Properties applied to entities available through use or host
 association are in effect during the association.  For example,
 consider the following:

 MODULE MOD1
   INTERFACE
     SUBROUTINE SUB1 
     !DEC$ ATTRIBUTES C, ALIAS:'othername' :: NEW_SUB
     END SUBROUTINE
   END INTERFACE
   CONTAINS
     SUBROUTINE SUB2
     CALL NEW_SUB
     END SUBROUTINE
 END MODULE

 In this case, the call to NEW_SUB within SUB2 uses the C and ALIAS
 properties specified in the interface block.

 For compatibility, !MS$ATTRIBUTES can be used in place of cDEC$
 ATTRIBUTES.

 The properties are described in the following sections.
5 ALIAS          
 Specifies an alternate external name to be used when referring to
 external subprograms.  Its form is:

 ALIAS:external-name

   external-name  Is a character constant delimited by apostrophes 
                  or quotation marks.  The character constant is 
                  used as is; the string is not changed to uppercase, 
                  nor are blanks removed.  

 The ALIAS property overrides the C (and STDCALL) property.  If both
 C and ALIAS are specified for a subprogram, the subprogram is given
 the C calling convention, but not the C naming convention.  It
 instead receives the name given for ALIAS, with no modifications.

 ALIAS cannot be used with internal procedures, and it cannot be
 applied to dummy arguments.

 cDEC$ ATTRIBUTES ALIAS has the same effect as the cDEC$ ALIAS
 directive.
5 C_and_STDCALL  
 Specify how data is to be passed when you use routines written in C
 or assembler with FORTRAN or Fortran 90 routines.

 On Intel processors, C and STDCALL have slightly different
 meanings; on all other platforms, they are interpreted as synonyms.

 When applied to a subprogram, these properties define the
 subprogram as having a specific set of calling conventions.

 The following table summarizes the differences between the calling
 conventions.  Note that C and STDCALL are synonyms on OpenVMS and
 DIGITAL UNIX systems, and Windows NT systems on Alpha processors.
 In the table, U=uppercase and L=lowercase:

 Convention                C       STDCALL    F90 Calling Convention

 Arguments passed 
      by value             Yes     Yes        No
 Case of external 
      subprogram names     VMS:U   VMS:U      VMS:U
                           U*X:L   U*X:L      U*X:L
                           WNT:L   WNT:L      WNT:U
                           W95:L   W95:L      W95:U

 U*X only:
 Trailing underscore added No      No         Yes

 WNT, W95:
 Leading underscore added  Yes     Yes        Yes
 Number of arguments
      added                No      Yes        Yes
 Caller stack cleanup      Yes     No         No
 Variable number of
      arguments            Yes     No         No

 If C or STDCALL is specified for a subprogram, arguments (except
 for arrays and characters) are passed by value.  Subprograms using
 standard Fortran 90 conventions pass arguments by reference.

 On Intel processors, an underscore (_) is placed at the beginning
 of the external name of a subprogram.  If STDCALL is specified, an
 at sign (@) followed by the number of argument bytes being passed
 is placed at the end of the name.  For example, a subprogram named
 SUB1 that has three INTEGER(4) arguments and is defined with
 STDCALL is assigned the external name _sub1@12.

 Character arguments are passed as follows:

  o  By default:

      -  On OpenVMS and DIGITAL UNIX Systems, hidden lengths are put
         at the end of the argument list.

      -  On Windows NT and Windows 95 Systems, hidden lengths
         immediately follow the variable.


  o  If C or STDCALL (only) are specified:

     On all systems, the first character of the string is passed
     (and padded with zeros out to INTEGER(4) length).

  o  If C or STDCALL are specified with REFERENCE:

     On all systems, the string is passed with no length.

5 DLLEXPORT_and_DLLIMPORT (WNT,W95) 
 Define a dynamic-link library's (DLL) interface for processes that
 use them.  The properties can be assigned to data objects or
 procedures.

 DLLEXPORT specifies that procedures or data are being exported to
 other applications or DLLs.  This causes the compiler to produce
 efficient code, eliminating the need for a module definition (.def)
 file to export symbols.

 If a procedure (or data) is declared with the DLLEXPORT property,
 it must be defined in the same module of the same program.

 Symbols defined in a DLL are imported by programs that use them.
 The program must link with the import DLL and use the DLLIMPORT
 property inside the program unit that imports the symbol.
 DLLIMPORT is specified in a declaration, not a definition, since
 you cannot define a symbol you are importing.
5 EXTERN         
 Specifies that a variable is allocated in another source file.
 EXTERN can be used in global variable declarations, but it must not
 be applied to dummy arguments.

 EXTERN must be used when accessing variables declared in other
 languages.
5 REFERENCE_and_VALUE 
 Specify how a dummy argument is to be passed.

 REFERENCE specifies a dummy argument's memory location is to be
 passed instead of the argument's value.

 VALUE specifies a dummy argument's value is to be passed instead of
 the argument's memory location.

 When a dummy argument has the VALUE property, the actual argument
 passed to it can be of a different type.  If necessary, type
 conversion is performed before the subprogram is called.

 When a complex (KIND=4 or KIND=8) argument is passed by value, two
 floating-point arguments (one containing the real part, the other
 containing the imaginary part) are passed by immediate value.

 Character values, substrings, assumed-size arrays, and adjustable
 arrays cannot be passed by value.

 If REFERENCE (only) is specified for a character argument, the
 following occurs:

  o  On OpenVMS and DIGITAL UNIX systems, the string is passed with
     no length

  o  On Windows NT and Windows 95 systems, hidden lengths
     immediately follow the variable


 If REFERENCE and C (or STDCALL) are specified for a character
 argument, the string is passed with no length.

 VALUE is the default if the C or STDCALL property is specified in
 the subprogram definition.
5 VARYING        
 Allows a variable number of calling arguments.  If VARYING is
 specified, the C property must also be specified.

 Either the first argument must be a number indicating how many
 arguments to process, or the last argument must be a special marker
 (such as -1) indicating it is the final argument.  The sequence of
 the arguments, and types and kinds must be compatible with the
 called procedure.
4 DECLARE_and_NODECLARE  
 cDEC$ DECLARE
 cDEC$ NODECLARE

 The DECLARE directive generates warnings for variables that have
 been used but have not been declared (like the IMPLICIT NONE
 statement).  The NODECLARE directive (the default) disables these
 warnings.

 The "c" in cDEC$ is one of the following:  a C (or c), !, or *.

 The DECLARE directive is primarily a debugging tool that locates
 variables that have not been properly initialized, or that have
 been defined but never used.   

 For compatibility, !MS$DECLARE and !MS$NODECLARE can be used in
 place of cDEC$ DECLARE and cDEC$ NODECLARE.
4 DEFINE_and_UNDEFINE  
 cDEC$ DEFINE
 cDEC$ UNDEFINE

 The DEFINE directive creates a symbolic variable whose existence or
 value can be tested during conditional compilation.  The UNDEFINE
 directive removes a defined symbol.

 The DEFINE and UNDEFINE directives take the following forms:

 cDEC$ DEFINE   name [=val]
 cDEC$ UNDEFINE name [=val]

   c        Is one of the following: C (or c), !, or *.

   name     Is an identifier up to 31 characters.  It can 
            contain letters, digits, an underscore (_),
            and the dollar sign ($) special character.
            The identifier cannot begin with a number.

   val      Is an INTEGER(4) value assigned to "name".

 DEFINE and UNDEFINE create and remove variables for use with the IF
 (or IF DEFINED) directive.  Symbols defined with the DEFINE
 directive are local to the directive.  They cannot be declared in
 the Fortran program.

 Because Fortran programs cannot access the named variables, the
 names can duplicate Fortran keywords, intrinsic functions, or
 user-defined names without conflict.

 To test whether a symbol has been defined, use the IF DEFINED
 (name) directive You can assign an integer value to a defined
 symbol.  To test the assigned value of "name", use the IF
 directive.  IF test expressions can contain most logical and
 arithmetic operators.

 Attempting to undefine a symbol which has not been defined produces
 a compiler warning.

 The DEFINE and UNDEFINE directives can appear anywhere in a
 program, enabling and disabling symbol definitions.

 For compatibility, !MS$DEFINE and !MS$UNDEFINE can be used in place
 of cDEC$ DEFINE and cDEC$ UNDEFINE.

 Examples:

 Consider the following:

 !DEC$ DEFINE  testflag
 !DEC$ IF DEFINED (testflag)
     write (*,*) 'Compiling first line'
 !DEC$ ELSE
      write (*,*) "Compiling second line'
 !DEC$ ENDIF
 !DEC$ UNDEFINE  testflag
4 FIXEDFORMLINESIZE  
 cDEC$ FIXEDFORMLINESIZE

 Sets the line length for fixed-form source code.  The directive
 takes the following form:

 cDEC$ FIXEDFORMLINESIZE:{72 | 80 | 132}

   c        Is one of the following: C (or c), !, or *.

 You can set FIXEDFORMLINESIZE to 72 (the default), 80, or 132
 characters.  The FIXEDFORMLINESIZE setting remains in effect until
 the end of the file, or until it is reset.

 The FIXEDFORMLINESIZE directive sets the source-code line length in
 include files, but not in USE modules, which are compiled
 separately.  If an include file resets the line length, the change
 does not affect the host file.

 This directive has no effect on free-form source code.

 For compatibility, !MS$FIXEDFORMLINESIZE can be used in place of
 cDEC$ FIXEDFORMLINESIZE.

 Examples:

 Consider the following:

 CDEC$ NOFREEFORM
 CDEC$ FIXEDFORMLINESIZE:132
 WRITE(*,*) 'Text that goes past the 72nd column without continuation'
4 FREEFORM_and_NOFREEFORM 
 cDEC$ FREEFORM
 cDEC$ NOFREEFORM

 The FREEFORM directive specifies that source code is in free-form
 format.  The NOFREEFORM directive specifies that source code is in
 fixed-form format.

 The "c" in cDEC$ is one of the following:  a C (or c), !, or *.

 When the FREEFORM or NOFREEFORM directives are used, they remain in
 effect for the remainder of the file, or until the opposite
 directive is used.  When in effect, they apply to include files,
 but do not affect USE modules, which are compiled separately.

 For compatibility, !MS$FREEFORM and !MS$NOFREEFORM can be used in
 place of cDEC$ FREEFORM and cDEC$ NOFREEFORM.
4 IDENT      
 cDEC$ IDENT string

 Lets you specify a string that can be used to identify an object
 module.  The compiler places the string in the identification field
 of an object module when it generates the module for each source
 program unit.

 The "string" is a character constant containing up to 31 printable
 characters.

 Only the first IDENT directive is effective -- the compiler ignores
 any additional IDENT directives in a program unit.

 IDENT has no effect when you specify the /NOOBJECT compiler option.
4 IF_and_IFDEFINED  
 cDEC$ IF
 cDEC$ IF DEFINED

 The IF and IF DEFINED directives specify a conditional compilation
 construct.  IF tests whether a logical expression is .TRUE.  or
 .FALSE..  IF DEFINED tests whether a symbol has been defined.

 The directive-initiated construct takes the following form:

 cDEC$ IF (expr) [or cDEC$ IF DEFINED (name)]
    block
 [cDEC$ ELSE IF (expr)
    block]...
 [cDEC$ ELSE 
    block]
 cDEC$ ENDIF 

   c        Is one of the following: C (or c), !, or *.

   exp      A logical expression that evaluates to .TRUE. 
            or .FALSE.. 

   name     Is the name of a symbol to be tested for definition.

   block    Are executable statements that are compiled (or not)
            depending on the value of logical expressions in 
            the IF directive construct. 

 The IF and IF DEFINED directive constructs end with an ENDIF
 directive and can contain one or more ELSEIF directives and at most
 one ELSE directive.  If the logical condition within a directive
 evaluates to .TRUE.  at compilation, and all preceding conditions
 in the IF construct evaluate to .FALSE., then the statements
 contained in the directive block are compiled.

 A "name" can be defined with a DEFINE directive, and can optionally
 be assigned an integer value.  If the symbol has been defined, with
 or without being assigned a value, IF DEFINED (name) evaluates to
 .TRUE.; otherwise, it evaluates to .FALSE..

 If the logical condition in the IF or IF DEFINED directive is
 .TRUE., statements within the IF or IF DEFINED block are compiled.
 If the condition is .FALSE., control transfers to the next ELSEIF
 or ELSE directive, if any.

 If the logical expression in an ELSEIF directive is .TRUE.,
 statements within the ELSEIF block are compiled.  If the expression
 is .FALSE., control transfers to the next ELSEIF or ELSE directive,
 if any.

 If control reaches an ELSE directive because all previous logical
 conditions in the IF construct evaluated to .FALSE., the statements
 in an ELSE block are compiled unconditionally.

 You can use any Fortran logical or relational operator or symbol in
 the logical expression of the directive.  The logical expression
 can be as complex as you like, but the whole directive must fit on
 one line.

 For compatibility, each directive in the construct can begin with
 the prefix !MS$ instead of cDEC$.

 Examples:

 Consider the following:

 ! When the following code is compiled and run, 
 !  the output depends on whether one of the expressions 
 !  tests .TRUE.; or all test .FALSE.

 !DEC$ DEFINE flag=3
 !DEC$ IF (flag .LT. 2)
    WRITE (*,*) "This is compiled if flag less than 2."
 !DEC$ ELSEIF (flag >= 8)
    WRITE (*,*) "Or this compiled if flag greater than &
                 or equal to 8."
 !DEC$ ELSE
    WRITE (*,*) "Or this compiled if all preceding &
                 conditions .FALSE."
 !DEC$ ENDIF
 END
4 INTEGER      
 cDEC$ INTEGER

 Specifies the default integer kind.  It takes the following form:

 cDEC$ INTEGER:{1 | 2 | 4 | 8}

   c        Is one of the following: C (or c), !, or *.

 The INTEGER directive specifies a size of 1 (KIND=1), 2 (KIND=2), 4
 (KIND=4), or 8 (KIND=8) bytes for default integer numbers.
 INTEGER(KIND=8) is only allowed on Alpha processors.

 When the INTEGER directive is effect, all default integer variables
 are of the kind specified in the directive.  Only numbers specified
 or implied as INTEGER without KIND are affected.

 The INTEGER directive can only appear at the top of a program unit.
 A program unit is a main program, an external subroutine or
 function, a module or a block data program unit.  The directive
 cannot appear between program units, or at the beginning of
 internal subprograms.  It does not affect modules invoked with the
 USE statement in the program unit that contains it.

 The default logical kind is the same as the default integer kind.
 So, when you change the default integer kind you also change the
 default logical kind.

 For compatibility, !MS$INTEGER can be used in place of cDEC$
 INTEGER.

 Examples:

 Consider the following:

 INTEGER i              ! a 4-byte integer
 WRITE(*,*) KIND(i)
 CALL INTEGER2( )
 WRITE(*,*) KIND(i)     ! still a 4-byte integer
                        !   not affected by setting in subroutine
 END
 SUBROUTINE INTEGER2( )
    !DEC$ INTEGER:2
    INTEGER j           ! a 2-byte integer
    WRITE(*,*) KIND(j)
 END SUBROUTINE
4 MESSAGE      
 cDEC$ MESSAGE

 Specifies a character string to be sent to the standard output
 device during the first compiler pass; this aids debugging.

 This directive takes the following form:

 cDEC$ MESSAGE:string

   c        Is one of the following: C (or c), !, or *.

   string   Is a character constant specifying a message.

 For compatibility, !MS$MESSAGE can be used in place of cDEC$
 MESSAGE.

 Examples:

 Consider the following:

 !DEC$ MESSAGE:'Compiling Sound Speed Equations'
4 OBJCOMMENT      
 cDEC$ OBJCOMMENT

 Specifies a library search path in an object file.  This directive
 takes the following form:

 cDEC$ OBJCOMMENT LIB:library

   c        Is one of the following: C (or c), !, or *.

   library  Is a character constant specifying the name 
            and, if necessary, the path of the library 
            that the linker is to search.

 The linker searches for the library named by the OBJCOMMENT
 directive as if you named it on the command line, that is, before
 default library searches.  You can place multiple library search
 directives in the same source file.  Each search directive appears
 in the object file in the order it is encountered in the source
 file.

 If the OBJCOMMENT directive appears in the scope of a module, any
 program unit that uses the module also contains the directive, just
 as if   the OBJCOMMENT directive appeared in the source file using
 the module.

 If you want to have the OBJCOMMENT directive in a module, but do
 not want it in the program units that use the module, place the
 directive outside the module that is used.

 For compatibility, !MS$OBJCOMMENT can be used in place of cDEC$
 OBJCOMMENT.

 Examples:

 Consider the following:

 ! MOD1.F90
 MODULE a
    !DEC$ OBJCOMMENT LIB: "opengl32.lib"
 END MODULE a

 ! MOD2.F90
 !DEC$ OBJCOMMENT LIB: "graftools.lib"
 MODULE b
    !
 END MODULE b

 ! USER.F90
 PROGRAM go
    USE a      ! library search contained in MODULE a 
               !   included here
    USE b      ! library search not included 
 END
4 OPTIONS      
 cDEC$ OPTIONS

 Controls whether the DIGITAL Fortran compiler naturally aligns
 fields in derived-type and record structures and data items in
 common blocks for performance reasons, or whether the compiler
 packs those fields and data items together on arbitrary byte
 boundaries.  The OPTIONS directive takes the following form:

 cDEC$ OPTIONS /[NO]ALIGN[=p]
   ...
 cDEC$ END OPTIONS

 p  Is a specifier with one of the following forms:

    [class =] rule    
    (class = rule,...) 
    ALL
    NONE

    class  Is one of the following keywords:

        COMMONS    (for common blocks)
        RECORDS    (for derived-type and record structures)
        STRUCTURES (a synonym for RECORDS)

    rule   Is one of the following keywords:

           PACKED -   Packs fields in structures or data 
                      items in common blocks on arbitrary 
                      byte boundaries.

           NATURAL -  Naturally aligns fields in structures
                      and data items in common blocks on 
                      up to 64-bit boundaries (inconsistent 
                      with the FORTRAN 77 standard).

                      If you specify NATURAL, the compiler will 
                      naturally align all data in a common 
                      block, including INTEGER*8, REAL*8, and 
                      all COMPLEX data.

           STANDARD - Naturally aligns data items in common 
                      blocks on up to 32-bit boundaries (con-
                      sistent with the FORTRAN 77 standard).

                      Note that this keyword only applies to 
                      common blocks; so, you can specify 
                      /ALIGN=COMMONS=STANDARD, but you cannot 
                      specify /ALIGN=STANDARD.

    ALL    Is the same as /ALIGN, /ALIGN=NATURAL, and 
           /ALIGN=(RECORDS=NATURAL,COMMONS=NATURAL).

    NONE   Is the same as /NOALIGN, /ALIGN=PACKED, and
           /ALIGN=(RECORDS=PACKED,COMMONS=PACKED)

 cDEC$ OPTIONS (and accompanying cDEC$ END OPTIONS) directives must
 come after OPTIONS, SUBROUTINE, FUNCTION, and BLOCK DATA statements
 (if any) in the program unit, and before statement functions or the
 executable part of the program unit.

 For performance reasons, DIGITAL Fortran always aligns local data
 items on natural boundaries.  However, EQUIVALENCE, COMMON, RECORD,
 and STRUCTURE data declaration statements can force misaligned
 data.  You can use the OPTIONS directive to control the alignment
 of fields associated with COMMON and RECORD statements.  By
 default, you receive compiler messages when misaligned data is
 encountered.

 To request packed, unaligned data in a record structure, specify
 /ALIGN=RECORDS=PACKED, or consider placing source data declarations
 for the record so that the data is naturally aligned.

                                NOTE

         Misaligned data significantly increases the time it
         takes  to  execute  a  program.   As  the number of
         misaligned fields encountered  increases,  so  does
         the  time  needed  to  complete  program execution.
         Specifying  cDEC$  OPTIONS/ALIGN  (or  the   /ALIGN
         compiler option) minimizes misaligned data.


 To request aligned, data in common blocks, specify
 /ALIGN=COMMONS=STANDARD (for data items up to 32 bits in length) or
 /ALIGN=COMMONS=NATURAL (for data items up to 64 bits in length), or
 place source data declarations within the common block in
 descending size order, so that each data field is naturally
 aligned.

 The OPTIONS directive supersedes the -align "keyword" compiler
 option.

 OPTIONS directives must be balanced and can be nested up to 100
 levels, for example:

    CDEC$ OPTIONS /ALIGN=PACKED         ! Group A
       declarations
    CDEC$ OPTIONS /ALIGN=RECO=NATU         ! Group B
       more declarations
    CDEC$ END OPTIONS                      ! End of Group B
       still more declarations
    CDEC$ END OPTIONS                   ! End of Group A

 Note that common blocks within Group B will be PACKED.  The CDEC$
 OPTION specification for Group B only applies to RECORDS, so
 COMMONS retains the previous setting (in this case, from the Group
 A specification).

 For more information on alignment and data sizes, see your user
 manual.
4 PACK         
 cDEC$ PACK

 Specifies the memory starting addresses of derived-type items.  It
 takes the following form:

 cDEC$ PACK:[{1 | 2 | 4}]

   c        Is one of the following: C (or c), !, or *.

 Items of derived types and record structures are aligned in memory
 on the smaller of two sizes:  the size of the type of the item, or
 the current alignment setting.  The current alignment setting can
 be 1, 2, 4, or 8 bytes.  The default initial setting is 8 bytes
 (unless a compiler option specifies otherwise).  By reducing the
 alignment setting, you can pack variables closer together in
 memory.

 The PACK directive lets you control the packing of derived-type or
 record structure items inside your program by overriding the
 current memory alignment setting.

 For example, if CDEC$ PACK:1 is specified, all variables begin at
 the next available byte, whether odd or even.  Although this
 slightly increases access time, no memory space is wasted.  If
 CDEC$ PACK:4 is specified, INTEGER(1), LOGICAL(1), and all
 character variables begin at the next available byte, whether odd
 or even.  INTEGER(2) and LOGICAL(2) begin on the next even byte;
 all other variables begin on 4-byte boundaries.

 If the PACK directive is specified without a number, packing
 reverts to the compiler option setting (if any), or the default
 setting of 8.

 The directive can appear anywhere in a program before the
 derived-type definition or record structure definition.  It cannot
 appear inside a derived-type or record structure definition.

 For compatibility, !MS$PACK can be used in place of cDEC$ PACK.

 Examples:

 Consider the following:

 ! Use 4-byte packing for this derived type
 ! Note PACK is used outside of the derived-type definition
 !DEC$ PACK:4
 TYPE pair
   INTEGER a, b
 END TYPE
 ! revert to default or compiler option
 !DEC$ PACK:   
4 PSECT      
 cDEC$ PSECT /common-name/ attr [,attr,...]

 Lets you modify several attributes of a common block.

 Specify the name of a common block, preceded and followed by a
 slash, and one of the following attributes:

  o  ALIGN=val or ALIGN=keyword

     Specifies alignment for the common block.

     "val" must be a constant ranging from 0 through 16.

     The specified number is interpreted as a power of 2.  The value
     of the expression is the alignment in bytes.

     "keyword" is one of the following:

           Keyword        Equivalent to "val"
           BYTE               0
           WORD               1
           LONG               2
           QUAD               3
           OCTA               4
           PAGE              16

     The default is octaword alignment (4).

  o  GBL

     Specifies global scope.  This is the default scope.

  o  LCL

     Specifies local scope.  This keyword is opposite to GBL and
     cannot appear with it.

  o  [NO]MULTILANGUAGE

     Controls whether the compiler pads the size of overlaid psects
     (program sections) to ensure compatibility when the psect is
     shared by code created by other DIGITAL compilers.

     When a psect generated by a Fortran common block is overlaid
     with a psect consisting of a C structure, linker error messages
     can occur.  This is because the sizes of the psects are
     inconsistent; the C structure is padded, but the Fortran common
     block is not.

     Specifying MULTILANGUAGE ensures that DIGITAL Fortran 90
     follows a consistent psect size allocation scheme that works
     with DEC C psects shared across multiple images.  Psects shared
     in a single image do not have a problem.

     The default is NOMULTILANGUAGE.  This is also the default
     behavior of DIGITAL Fortran 77 and is sufficient for most
     applications.

     To specify MULTILANGUAGE for all COMMON blocks in a module, use
     compiler option /ALIGN=COMMON=MULTILANGUAGE.  (For more
     information, see your user manual.)

  o  [NO]SHR

     Determines whether the contents of a common block can be shared
     by more than one process.  The default is NOSHR.

  o  [NO]WRT

     Determines whether the contents of a common block can be
     modified during program execution.  The default is WRT.


 Global or local scope is significant for an image that has more
 than one cluster.  Program sections with the same name that are
 from different modules in different clusters are placed in separate
 clusters if local scope is in effect.  They are placed in the same
 cluster if global scope is in effect.

 If one program unit changes one or more characteristics of a common
 block, all other units that reference that common block must also
 change those characteristics in the same way.

 Default characteristics apply if you do not modify them with a
 PSECT directive.

 See the "OpenVMS Linker Utility Manual" for detailed information
 about default attributes of common blocks.
4 REAL         
 cDEC$ REAL

 Specifies the default real kind.  It takes the following form:

 cDEC$ REAL:{4 | 8 | 16}

   c        Is one of the following: C (or c), !, or *.

 The REAL directive specifies a size of 4 (KIND=4), 8 (KIND=8), or
 16 (KIND=16) bytes for default real numbers.  REAL(KIND=16) is only
 allowed on OpenVMS and DIGITAL UNIX systems.

 When the REAL directive is effect, all default real variables are
 of the kind specified in the directive.  Only numbers specified or
 implied as REAL without KIND are affected.

 The REAL directive can only appear at the top of a program unit.  A
 program unit is a main program, an external subroutine or function,
 a module or a block data program unit.  The directive cannot appear
 between program units, or at the beginning of internal subprograms.
 It does not affect modules invoked with the USE statement in the
 program unit that contains it.

 For compatibility, !MS$REAL can be used in place of cDEC$ REAL.

 Consider the following:

 REAL r               ! a 4-byte REAL
 WRITE(*,*) KIND(r)
 CALL REAL8( )
 WRITE(*,*) KIND(r)   ! still a 4-byte REAL
                      !  not affected by setting in subroutine
 END
 SUBROUTINE REAL8( )
    !DEC$ REAL:8
    REAL s            ! an 8-byte REAL
    WRITE(*,*) KIND(s)
 END SUBROUTINE
4 STRICT_and_NOSTRICT  
 cDEC$ STRICT
 cDEC$ NOSTRICT

 The STRICT directive disables language features not found in the
 Fortran 90 language standard.  The NOSTRICT directive (the default)
 enables these language features.

 The "c" in cDEC$ is one of the following:  a C (or c), !, or *.

 The STRICT and NOSTRICT directives can appear only appear at the
 top of a program unit.  A program unit is a main program, an
 external subroutine or function, a module or a block data program
 unit.  The directives cannot appear between program units, or at
 the beginning of internal subprograms.  They do not affect any
 modules invoked with the USE statement in the program unit that
 contains them.

 For compatibility, !MS$STRICT and !MS$NOSTRICT can be used in place
 of cDEC$ STRICT and cDEC$ NOSTRICT.

 Examples:

 Consider the following:

 ! NOSTRICT by default
 TYPE stuff
    INTEGER(4) k
    INTEGER(4) m
    CHARACTER(4) name
 END TYPE stuff
 TYPE (stuff) examp
 DOUBLE COMPLEX cd    ! non-standard data type, no error
 cd =(3.0D0, 4.0D0)
 examp.k = 4          ! non-standard component designation, 
                      !   no error
 END

 SUBROUTINE STRICTDEMO( )
    !DEC$ STRICT
     TYPE stuff
       INTEGER(4) k
       INTEGER(4) m
       CHARACTER(4) name
    END TYPE stuff
    TYPE (stuff) samp
    DOUBLE COMPLEX cd      ! ERROR
    cd =(3.0D0, 4.0D0)
    samp.k = 4             ! ERROR
 END SUBROUTINE
4 TITLE_and_SUBTITLE
 cDEC$ TITLE string
 cDEC$ SUBTITLE string

 The TITLE directive lets you specify a string and place it in the
 title field of a listing header.  Similarly, SUBTITLE lets you
 place a specified string in the subtitle field of a listing header.

 The "string" is a character constant containing up to 31 printable
 characters.

 To enable TITLE and SUBTITLE directives, you must specify the -V
 compiler option.

 When TITLE or SUBTITLE appears on a page of a listing file, the
 specified string appears in the listing header of the following
 page.

 If two or more of either directive appear on a page, the last
 directive is the one in effect for the following page.

 If either directive does not specify a string, no change occurs in
 the listing file header.

 For compatibility, !MS$TITLE:  and !MS$SUBTITLE:  can be used in
 place of cDEC$ TITLE and cDEC$ SUBTITLE.
3 ACCEPT                  
 Transfers input data to internal storage from external records
 accessed under the sequential mode of access.  It takes one of the
 following forms:

     Formatted           ACCEPT f[,iolist]
     List-directed       ACCEPT *[,iolist]
     Namelist            ACCEPT n

     f       Is a format specifier not prefaced by FMT=.

     iolist  Is a simple I/O list element or an implied-DO list.

     *       Specifies list-directed formatting (can be specified
             as FMT=*).

     n       The nonkeyword form of a namelist specifier.

 The control-list parameters are "f," "*" (or FMT=*), and "n".  The
 I/O list parameter is "iolist".

 The formatted ACCEPT statement transfers data from your terminal to
 internal storage.  The access mode is sequential.

 The list-directed ACCEPT statement translates the data from
 character to binary format according to the data types of the
 variables in the I/O list.

 The namelist ACCEPT statement translates the data from character to
 binary format according to the data types of the list entities in
 the corresponding NAMELIST statement.

 Also see the READ Statement.
3 ALLOCATABLE             
 Specifies that an array is an allocatable array with a deferred
 shape.  The shape of an allocatable array is determined when an
 ALLOCATE statement is executed, dynamically allocating space for
 the array.

 The ALLOCATABLE attribute can be specified in a type declaration
 statement or an ALLOCATABLE statement, and takes one of the
 following forms:

 Type Declaration Statement:

  type, [att-ls,] ALLOCATABLE [,att-ls] :: a[(d-spec)] [,a[(d-spec)]]... 

 Statement:

  ALLOCATABLE [::] a[(d-spec)] [,a[(d-spec)]]... 

    type        Is a data type specifier.

    att-ls      Is an optional list of attribute specifiers.

    a           Is the name of the allocatable array; it must 
                not be a dummy argument or function result.  

    d-spec      Is a deferred-shape specification (: [,:]...). 
                Each colon represents a dimension of the array.

 If the array is given the DIMENSION attribute elsewhere in the
 program, it must be declared as a deferred-shape array.

 When the allocatable array is no longer needed, it can be
 deallocated by execution of a DEALLOCATE statement.

 During program execution, the allocation status of an allocatable
 array is one of the following:

  o  Not currently allocated

     The array was never allocated or the last operation performed
     on it was a deallocation.  Deallocation is performed:

      -  Explicitly, by using a DEALLOCATE statement.

      -  By default, when the allocatable array is a local variable
         of a procedure that does not have the SAVE attribute and is
         terminated by an END or RETURN statement.


     An array that is not currently allocated must not be referenced
     or defined.

  o  Currently allocated

     The array was allocated by an ALLOCATE statement.  Such an
     array can be referenced, defined, or deallocated.


 An allocatable array cannot be specified in a COMMON, EQUIVALENCE,
 DATA, or NAMELIST statement.

 The ALLOCATABLE attribute is compatible with the AUTOMATIC,
 DIMENSION (with deferred shape), PRIVATE, PUBLIC, SAVE, STATIC,
 TARGET, and VOLATILE attributes.

 EXAMPLES:

 The following example shows a type declaration statement specifying
 the ALLOCATABLE attribute:

    REAL, ALLOCATABLE :: Z(:, :, :)

 The following is an example of the ALLOCATABLE statement:

    REAL A, B(:)
    ALLOCATABLE :: A(:,:), B
3 ALLOCATE                
 Dynamically creates storage for allocatable arrays and pointer
 targets.  The storage space allocated is uninitialized.

 The ALLOCATE statement takes the following form:

   ALLOCATE (object [(s-spec[,s-spec...])] 
             [,object[(s-spec[,s-spec...])]]...[,STAT=sv])

     object  Is the object to be allocated.  It is a variable 
             name or structure component, and must be a pointer 
             or allocatable array.  The object can be of type 
             character with zero length.

     s-spec  Is a shape specification in the form 
             [lower-bound:]upper-bound. Each bound must be a 
             scalar integer expression. The number of shape 
             specifications must be the same as the rank of 
             the "object".

     sv      Is a scalar integer variable in which the status 
             of the allocation is stored.

 A bound in "s-spec" must not be an expression containing an array
 inquiry function whose argument is any allocatable object in the
 same ALLOCATE statement; for example, the following is not
 permitted:

    INTEGER ERR
    INTEGER, ALLOCATABLE :: A(:), B(:)
    ...
    ALLOCATE(A(10:25), B(SIZE(A)), STAT=ERR)  ! A is invalid as an argu-
                                              !   ment to function SIZE

 If a STAT variable is specified, it must not be allocated in the
 ALLOCATE statement in which it appears.  If the allocation is
 successful, the variable is set to zero.  If the allocation is not
 successful, an error condition occurs, and the variable is set to a
 positive integer value (representing the run-time error).  If no
 STAT variable is specified and an error condition occurs, program
 execution terminates.

 To release the storage for an allocated array, use the DEALLOCATE
 statement.

 To determine whether an allocatable array is currently allocated,
 use the ALLOCATED intrinsic function.

 To determine whether a pointer is currently associated with a
 target, use the ASSOCIATED intrinsic function.

 For information on allocation of allocatable arrays and pointer
 targets, see your language reference manual.

 EXAMPLES:

 The following is an example of the ALLOCATE statement:

    INTEGER J, N, ALLOC_ERR
    REAL, ALLOCATABLE :: A(:), B(:,:)
    ...
    ALLOCATE(A(0:80), B(-3:J+1, N), STAT = ALLOC_ERR)
3 ASSIGN                  
 Assigns the value of a statement label to an integer variable.
 This statement is an obsolescent feature in Fortran 90, which is
 deleted in Fortran 95.  DIGITAL Fortran flags deleted and
 obsolescent features, but fully supports them.

 Statement format:

    ASSIGN s TO v

    s  Is the label of an executable statement or a 
       FORMAT statement.  You must specify the label 
       as an unsigned integer (from 1-5 characters
       long, using digits 0-9).

    v  Is an integer variable.

 When the value of a statement label is assigned to an integer
 variable:  the variable can then be used as a transfer destination
 in a subsequent assigned GOTO statement or as a format specifier in
 a formatted I/O statement.  The ASSIGN statement must be in the
 same program unit as and must be executed before the statement(s)
 in which the assigned variable is used.
3 Assignment              
 Assigns the value of the expression to the variable.
 Arithmetic/Logical/Character assignment takes the form:

    v = e

    v  Is the name of a scalar or array of intrinsic 
       or derived type (with no defined assignment).
       The array cannot be an assumed-size array, and 
       neither the scalar nor the array can be declared 
       with the PARAMETER or INTENT(IN) attribute.
  
    e  Is an expression of intrinsic type or the same 
       derived type as "v". Its shape must conform with 
       "v". If necessary, it is converted to the same kind 
       type as "v".

 Before a value is assigned to the variable, the expression part of
 the assignment statement and any expressions within the variable
 are evaluated.  No definition of expressions in the variable can
 affect or be affected by the evaluation of the expression part of
 the assignment statement.

 NOTE:  When the run-time system assigns a value to a scalar integer
 or character variable and the variable is shorter than the value
 being assigned, the assigned value may be truncated and significant
 bits (or characters) lost.  This truncation can occur without
 warning, and can cause the run-time system to pass incorrect
 information back to the program.

 If the variable is a pointer, it must be associated with a
 definable target.  The shape of the target and expression must
 conform and their types and kind type parameters must match.
4 Conversion_Rules     
 The following tables summarize the conversion rules for assignment
 statements.  MS signifies the most significant (high-order) bit; LS
 signifies the least significant (low-order) bit.

 +---------+----------------------------------------------------+
 |Variable |          Expression (E)                            |
 |or Array |-----------------------------------------------------
 |Element  |integer or logical | REAL(KIND=4)  |    REAL(KIND=8)|
 +---------+----------------------------------------------------+
 | integer |  Assign E to V    | Truncate E to | Truncate E to  |
 |  or     |                   | integer and   | integer and    |
 | logical |                   | assign to V   | assign to V    |
 +--------------------------------------------------------------+
 |  REAL   | Append fraction   | Assign E to V | Assign MS por- |
 |(KIND=4) | (.0) to E and     |               | tion of E to V;|
 |         | assign to V       |               | LS portion of E|
 |         |                   |               | is rounded     |
 +--------------------------------------------------------------+
 |  REAL   | Append fraction   | Assign E to MS| Assign E to V  |
 |(KIND=8) | (.0) to E and     | portion of V; |                |
 |         | assign to V       | LS portion of |                |
 |         |                   | V is 0        |                |
 +--------------------------------------------------------------+
 | REAL    | same as above     | same as above | Assign E to MS |
 |(KIND=16)|                   |               | portion of V;  |
 |         |                   |               | LS portion of V|
 |         |                   |               | is 0           |
 +--------------------------------------------------------------+
 | COMPLEX | Append fraction   | Assign E to   | Assign MS por- |
 |(KIND=4) | (.0) to E and     | real part of  | tion of E to   |
 |         | assign to real    | V; imaginary  | real part of V;|
 |         | part of V; imagin-| part of V is  | LS portion of  |
 |         | ary part of V is  | 0.0           | E is rounded;  |
 |         | 0.0               |               | imaginary part |
 |         |                   |               | of V is 0.0    |
 +--------------------------------------------------------------+
 |COMPLEX   | Append fraction  | Assign E to MS | Assign E to   |
 |(KIND=8)  | (.0) to E and    | portion of     | real part of  |
 |          | assign to V;     | real part of V;| V; imaginary  |
 |          | imaginary part of| imaginary part | part is 0.0   |
 |          | V is 0.0         | of V is 0.0    |               |
 +--------------------------------------------------------------+

 continued chart
 +---------+----------------------------------------------------+
 |Variable |          Expression (E)                            |
 |or Array |-----------------------------------------------------
 |Element  |   REAL      |    COMPLEX    |    COMPLEX           |
 |         | (KIND=16)   |    (KIND=4)   |    (KIND=8)          |
 +---------+----------------------------------------------------+
 |integer  | Truncate E  | Truncate real | Truncate real part of|
 | or      | to integer  | part of E to  | E to integer and     |
 |logical  | and assign  | integer and   | assign to V; imagin- |
 |         | to V        | assign to V;  | ary part of E is not |
 |         |             | imaginary part| used                 |
 |         |             | is not used   |                      |
 +--------------------------------------------------------------+
 |  REAL   | Assign MS   | Assign real   | Assign MS portion of |
 |(KIND=4) | portion of E| part of E to  | the real part of E to|
 |         | to V; LS    | V; imaginary  | V; LS portion of the |
 |         | portion of E| part of E is  | real part of E is    |
 |         | is rounded  | not used      | rounded; imaginary   |
 |         |             |               | part of E is not used|
 +--------------------------------------------------------------+
 | REAL    | same as     | Assign real   | Assign real part of E|
 |(KIND=8) | above       | part of E to  | to V; imaginary part |
 |         |             | MS of V; LS   | of E is not used     |
 |         |             | portion of V  |                      |
 |         |             | is 0; imagin- |                      |
 |         |             | ary part of E |                      |
 |         |             | is not used   |                      |
 +--------------------------------------------------------------+
 | REAL    | Assign E to | same as above | Assign real part of E|
 |(KIND=16)| V           |               | to MS portion of V;  |
 |         |             |               | LS portion of real   |
 |         |             |               | part of V is 0; imag-|
 |         |             |               | inary part of E is   |
 |         |             |               | not used             |
 +--------------------------------------------------------------+
 | COMPLEX | Assign MS   | Assign E to V | Assign MS portion of |
 |(KIND=4) | portion of E|               | real part of E to    |
 |         | to real part|               | real part of V; LS   |
 |         | of V; LS    |               | portion of real part |
 |         | portion of E|               | of E is rounded.     |
 |         | is rounded; |               | Assign MS portion of |
 |         | imaginary   |               | imaginary part of E  |
 |         | part of V is|               | to imaginary part of |
 |         | 0.0         |               | V; LS portion of     |
 |         |             |               | imaginary part of E  |
 |         |             |               | is rounded           |
 +--------------------------------------------------------------+
 |COMPLEX   | same as    | Assign real    | Assign E to V       |
 |(KIND=8)  | above      | part of E to   |                     |
 |          |            | MS portion of  |                     |
 |          |            | real part of V;|                     |
 |          |            | LS portion of  |                     |
 |          |            | real part is 0.|                     |
 |          |            | Assign imagin- |                     |
 |          |            | ary part of E  |                     |
 |          |            | to MS portion  |                     |
 |          |            | of imaginary   |                     |
 |          |            | part of V;     |                     |
 |          |            | LS portion of  |                     |
 |          |            | imaginary part |                     |
 |          |            | is 0           |                     |
 +--------------------------------------------------------------+
3 AUTOMATIC_and_STATIC  
 Control the storage allocation of variables in subprograms.

 The AUTOMATIC and STATIC attributes can be specified in a type
 declaration statement or an AUTOMATIC or STATIC statement, and take
 one of the following forms:

 Type Declaration Statement:

   type, [att-ls,] AUTOMATIC [,att-ls] ::   v [,v]...
   type, [att-ls,] STATIC    [,att-ls] ::   v [,v]...

 Statement:

    AUTOMATIC  v [,v]...
    STATIC     v [,v]...

    type      Is a data type specifier.

    att-ls    Is an optional list of attribute specifiers.

    v         Is the name of a variable or an array 
              specification. It can be of any type.

 AUTOMATIC and STATIC declarations only affect how data is allocated
 in storage, as follows:

  o  A variable declared as AUTOMATIC and allocated in memory
     resides the stack storage area.

  o  A variable declared as STATIC and allocated in memory resides
     in the static storage area.


 If you want to retain definitions of variables upon reentry to
 subprograms, you must use the SAVE attribute.

 Automatic variables can reduce memory use because only the
 variables currently being used are allocated to memory.

 Automatic variables allow possible recursion.  With recursion, a
 subprogram can call itself (directly or indirectly), and resulting
 values are available upon a subsequent call or return to the
 subprogram.  For recursion to occur, RECURSIVE must be specified in
 one of the following ways:

  o  As a keyword in a FUNCTION or SUBROUTINE statement

  o  As a compiler option

  o  As an option in an OPTIONS statement


 By default, the compiler allocates local variables of non-recursive
 subprograms, except for allocatable arrays, in the static storage
 area.  The compiler may choose to allocate a variable in temporary
 (stack or register) storage if it notices that the variable is
 always defined before use.  Appropriate use of the SAVE attribute
 can prevent compiler warnings if a variable is used before it is
 defined.

 To change the default for variables, specify them as AUTOMATIC or
 specify RECURSIVE (in one of the ways mentioned above).

 To override any compiler option that may affect variables,
 explicitly specify the variables as AUTOMATIC or STATIC.

                                NOTE

         Variables that are data-initialized, and  variables
         in  COMMON  and  SAVE statements are always static.
         This is regardless of  whether  a  compiler  option
         specifies recursion.


 A variable cannot be specified as AUTOMATIC or STATIC more than
 once in the same scoping unit.

 If the variable is a pointer, AUTOMATIC or STATIC apply only to the
 pointer itself, not to any associated target.

 Some variables cannot be specified as AUTOMATIC or STATIC.  The
 following table shows these restrictions:

 Variable                    AUTOMATIC       STATIC
 --------                    ---------       ------
 Dummy argument                Yes             No
 Automatic object              No              No
 Common block item             No              Yes
 Use-associated item           No              No
 Function result               Yes             No
 Component of a derived type   No              No

 A variable can be specified with both the STATIC and SAVE
 attributes.

 If a variable is in a module's outer scope, it can be specified as
 STATIC, but not as AUTOMATIC.

 The AUTOMATIC attribute is compatible with the ALLOCATABLE,
 DIMENSION, POINTER, TARGET, and VOLATILE attributes.

 The STATIC attribute is compatible with the ALLOCATABLE, DIMENSION,
 POINTER, PRIVATE, PUBLIC, SAVE, TARGET, and VOLATILE attributes.
3 BACKSPACE               
 Positions a sequential file at the beginning of the preceding
 record, making it available for subsequent I/O processing.  The
 file must be on disk or tape.  Statement format:

     BACKSPACE ([UNIT=]io-unit [,ERR=label] [,IOSTAT=i-var])
     BACKSPACE io-unit

     io-unit  Is an integer variable or constant specifying the 
              logical unit number of the file, optionally prefaced 
              by UNIT=.  UNIT= is required if unit is not the 
              first I/O specifier.

     label    Is the label of a statement that receives control 
              if an error occurs, prefaced by ERR=.

     i-var    Is a scalar integer variable to which the completion 
              status of the I/O operation is returned, prefaced 
              by IOSTAT= (positive if an error occurs, zero if 
              no error occurs).

 A BACKSPACE statement should not be specified for a file that is
 open for direct, append, or keyed access, because record "n" is not
 available to the RMS I/O system.

 If a file is already positioned at the beginning of a file, a
 BACKSPACE statement has no effect.
3 BLOCK_DATA               
 Begins a block data program unit.  Statement format:

    BLOCK DATA [nam]
      [stmts]
    END [BLOCK DATA [nam]]

    nam   Is the symbolic name used to identify the block.  
    
    stmts Is one or more of the following statements:

           COMMON        PARAMETER  Type declaration
           DATA          POINTER    Derived-type definition  
           DIMENSION     RECORD     Record structure declaration
           EQUIVALENCE   SAVE
           IMPLICIT      TARGET
           INTRINSIC     USE

    Note: A type declaration cannot contain the ALLOCATABLE,
          EXTERNAL, INTENT, OPTIONAL, PRIVATE, or PUBLIC
          attributes.

 A BLOCK DATA statement and its associated specification statements
 are a special kind of program unit, called a block data subprogram.

 A block data program unit need not be named, but there can only be
 one unnamed block data program unit in an executable program.

 A block data subprogram must not contain any executable statements.

 As with other types of program units, the last statement in a block
 data subprogram must be an END statement.  If a name follows the
 END statement, it must be the same as the name specified in the
 BLOCK DATA statement.

 Within a block data subprogram, if a DATA statement initializes any
 entity in a named common block, the subprogram must have a complete
 set of specification statements that establishes the common block.
 However, all of the entities in the block do not have to be
 assigned initial values in a DATA statement.

 One block data subprogram can establish and define initial values
 for more than one common block.

 The name of a block data subprogram can appear in the EXTERNAL
 statement of a different program unit to force a search of object
 libraries for the BLOCK DATA program unit at link time.
3 CALL                    
 Transfers control and passes arguments to a subprogram.  Statement
 format:

    CALL sub[([a][,[a]]...)]

    sub  Is the name of the subroutine subprogram.

    a    Is an actual argument optionally preceded by [keyword=], 
         where "keyword" is the name of a dummy argument in the 
         explicit interface for the subroutine.  The keyword is
         assigned a value when the  procedure is invoked.  

 Each actual argument must be a variable, an expression, the name of
 a procedure, or an alternate return specifier.  (It must not be the
 name of an internal procedure, statement function, or the generic
 name of a procedure.)

 An alternate return specifier is an asterisk (*) or ampersand (&)
 followed by the label of an executable branch target statement in
 the same scoping unit as the CALL statement.


                                NOTE

         An alternate return is an  obsolescent  feature  in
         Fortran  90  and Fortran 95.  DIGITAL Fortran flags
         obsolescent features, but fully supports them.


 When the CALL statement is executed, any expressions in the actual
 argument list are evaluated, then control is passed to the first
 executable statement or construct in the subroutine.  When the
 subroutine finishes executing, control returns to the next
 executable statement following the CALL statement, or to a
 statement identified by an alternate return label (if any).

 If an argument list appears, each actual argument is associated
 with the corresponding dummy argument by its position in the
 argument list or by the name of its keyword.  The arguments must
 agree in type and kind type parameters.

 If positional arguments and argument keywords are specified, the
 argument keywords must appear last in the actual argument list.

 If a dummy argument is optional, the actual argument can be
 omitted.

 An actual argument associated with a dummy procedure must be the
 specific name of a procedure, or be another dummy procedure.
 Certain specific intrinsic function names must not be used as
 actual arguments (see your language reference manual).

 EXAMPLES:

 The following example shows a subroutine with argument keywords:

   PROGRAM KEYWORD_EXAMPLE
     INTERFACE
       SUBROUTINE TEST_C(I, L, J, KYWD2, D, F, KYWD1)
       INTEGER I, L(20), J, KYWD1
       REAL, OPTIONAL :: D, F
       COMPLEX KYWD2
       ...
       END SUBROUTINE TEST_C
     END INTERFACE
     INTEGER I, J, K
     INTEGER L(20)
     COMPLEX Z1
     CALL TEST_C(I, L, J, KYWD1 = K, KYWD2 = Z1)
     ...

 The first three actual arguments are associated with their
 corresponding dummy arguments by position.  The argument keywords
 are associated by keyword name, so they can appear in any order.

 Note that the interface to subroutine TEST has two optional
 arguments that have been omitted in the CALL statement.
3 CASE                    
 Conditionally executes one block of constructs or statements
 depending on the value of a scalar expression in a SELECT CASE
 statement.  Statement format:

   [name :] SELECT CASE (expr)
   [CASE (case-value [,case-value]...) [name]
     block]...
   [CASE DEFAULT [name]
     block]
   END SELECT [name]

   name   Is the name of the CASE construct.

   expr   Is an expression of type integer, logical, or 
          character (enclosed in parentheses). Evaluation
          of this expression results in a value called 
          the case index.

   case-value  Is one or more compile-time constant expressions 
               of type integer, logical, or character (enclosed 
               in parentheses).  Each "case-value" must be of the 
               same data type as "expr". If the type is character, 
               "case-value" and "expr" can be of different lengths.

               Integer and character expressions can be expressed 
               as a range of case values, taking one of the following 
               forms:

               low:high
               low:
               :high

               Case values must not overlap.

   block  Is a sequence of zero or more statements or 
          constructs.

 If a construct name is specified in a SELECT CASE statement, the
 same name must appear in the corresponding END SELECT statement.
 The same construct name can optionally appear in any CASE statement
 in the construct.

 The case expression ("expr") is evaluated first.  The resulting
 case index is compared to the case values to find a matching value
 (there can only be one).  When a match occurs, the block following
 the matching case value is executed and the construct terminates.

 The following rules determine whether a match occurs:

  o  When the case value is a single value (no colon appears), a
     match occurs as follows:

       Data Type              A Match Occurs If:
       ---------              ---------------------------
       Logical                case-index .EQV. case-value
       Integer or character   case-index ==  case-value

  o  When the case value is a range of values (a colon appears), a
     match depends on the range specified, as follows:

       Range       A Match Occurs If:
       -----       -------------------------
       low:        case-index >= low
       :high       case-index <= high
       low:high    low <= case-index <= high


 The following are all valid case values:

    CASE (1, 4, 7, 11:14, 22)      ! Individual values as specified:
                                   !     1, 4, 7, 11, 12, 13, 14, 22
    CASE (:-1)                     ! All values less than zero
    CASE (0)                       ! Only zero
    CASE (1:)                      ! All values above zero

 If no match occurs but a CASE DEFAULT statement is present, the
 block following that statement is executed and the construct
 terminates.

 If no match occurs and no CASE DEFAULT statement is present, no
 block is executed, the construct terminates, and control passes to
 the next executable statement or construct following the END SELECT
 statement.

 The following are examples of CASE constructs:

   INTEGER FUNCTION STATUS_CODE (I)
     INTEGER I
     CHECK_STATUS: SELECT CASE (I)
     CASE (:-1)
       STATUS_CODE = -1
     CASE (0)
       STATUS_CODE = 0
     CASE (1:)
       STATUS_CODE = 1
     END SELECT CHECK_STATUS
   END FUNCTION STATUS_CODE

   SELECT CASE (J)
   CASE (1, 3:7, 9)    ! Values: 1, 3, 4, 5, 6, 7, 9
     CALL SUB_A
   CASE DEFAULT
     CALL SUB_B
   END SELECT

 The following three examples are equivalent:

   1. SELECT CASE (ITEST .EQ. 1)
      CASE (.TRUE.)
        CALL SUB1 ()
      CASE (.FALSE.)
        CALL SUB2 ()
      END SELECT

   2. SELECT CASE (ITEST)
      CASE DEFAULT
        CALL SUB2 ()
      CASE (1)
        CALL SUB1 ()
      END SELECT

   3. IF (ITEST .EQ. 1) THEN
        CALL SUB1 ()
      ELSE
        CALL SUB2 ()
      END IF
3 CLOSE                   
 Closes a file.  Statement format:

    CLOSE ([UNIT=]io-unit[,p][,ERR=label][,IOSTAT=i-var])

    io-unit Is an integer variable or constant specifying the 
            logical unit number of the file, optionally prefaced 
            by UNIT=.  UNIT= is required if unit is not the 
            first I/O specifier.

    p       Is the disposition of the file after closing, prefaced 
            by STATUS=, DISPOSE= or DISP=.  Dispositions are as 
            follows:

            'KEEP'             Retains the file.
                              *DEFAULT FOR ALL BUT SCRATCH FILES*
            'SAVE'             Retains the file.
            'DELETE'           Deletes the file (unless OPEN(READONLY)
                               is specified).
                              *DEFAULT FOR SCRATCH FILES*
            'PRINT'            Submits the file as a print job.
            'PRINT/DELETE'     Submits the file as a print job,
                               then deletes it.
            'SUBMIT'           Submits the file as a batch job.
            'SUBMIT/DELETE'    Submits the file as a batch job,
                               then deletes it.

     label  Is the label of an executable statement that 
            receives control if an error occurs.

     i-var  Is a scalar integer variable. (Returns a 
            zero if no error condition exists or a positive
            integer if an error condition exists.)

 The CLOSE statement specifiers can appear in any order.  An I/O
 unit must be specified, but the UNIT specifier is optional if the
 unit specifier is the first item in the I/O control list.

 The status specified in the CLOSE statement supersedes the status
 specified in the OPEN statement, except that a file opened as a
 scratch file cannot be saved, printed, or submitted, and a file
 opened for read-only access cannot be deleted.

 If a CLOSE statement is specified for a unit that is not open, it
 has no effect.
3 COMMON                  
 Defines one or more contiguous blocks of storage shared among
 separate subprograms.  You can define the same common block in
 different program units of your program.  The first COMMON
 statement in a program unit to name a common block defines it;
 subsequent COMMON statements that name the block reference it.  You
 can leave one common block (the "blank" common block) unnamed.

 Statement format:

    COMMON [/[cb]/] nlist[[,] /[cb] /nlist]...

    cb     Is a symbolic name that identifies the common block.

    nlist  Is one or more names of variables that identify items in
           the common block. The variable must not be a dummy 
           argument, allocatable array, automatic object, function, 
           function result, or entry to a procedure.  

           It must not have the PARAMETER attribute.  If an object 
           of derived type is specified, it must be a sequence type.

 Any common block name, blank or otherwise, can appear more than
 once in one or more COMMON statements in a program unit.  The list
 following each successive appearance of the same common block name
 is treated as a continuation of the list for the block associated
 with that name.

 A variable can appear in only one common block within a scoping
 unit.

 If an array is specified, it can be followed by an explicit-shape
 array specification.  The array must not have the POINTER attribute
 and each bound in the specification must be a constant
 specification expression.

 A pointer can only be associated with pointers of the same type,
 kind type parameters, and rank.

 Nonpointer variables can be associated if they are of different
 numeric type.

 A common block can have the same name as a variable, array, record,
 structure, or field.  However, in a program with one or more
 program units, a common block cannot have the same name as a
 function, subroutine, or entry name in the executable program.

 When common blocks from different program units have the same name,
 they share the same storage area when the units are combined into
 an executable program.

 Entities are assigned storage in common blocks on a one-for-one
 basis.  Thus, the entities assigned by a COMMON statement in one
 program unit should agree with the data type of entities placed in
 a common block by another program unit; for example, consider a
 program unit containing the following statement:

    COMMON CENTS

 Consider another program unit containing the following statements:

    INTEGER*2 MONEY
    COMMON MONEY

 When these program units are combined into an executable program,
 incorrect results can occur if the 2-byte integer variable MONEY is
 made to correspond to the lower-addressed two bytes of the real
 variable CENTS.
3 CONTAINS                
 Separates the body of a main program, module, or external
 subprogram from any internal or module procedures it may contain.
 It is not executable.  Statement format:

    CONTAINS
3 CONTINUE                
 Transfers control to the next executable statement.  The CONTINUE
 statement is used primarily as the terminal statement of a labeled
 DO loop when that loop would otherwise end improperly with a GOTO,
 arithmetic IF, or other prohibited control statement.  Statement
 format:

    CONTINUE

 The statement by itself does nothing and has no effect on program
 results or execution sequence.
3 CYCLE                   
 Terminates the current execution cycle of the innermost (or named)
 DO construct.  Statement format:

    CYCLE [name]

    name   Is the name of the DO construct. 

 When a CYCLE statement is executed, the following occurs:

 1.  The current execution cycle of the named (or innermost) DO
     construct is terminated.

     If a DO construct name is specified, the CYCLE statement must
     be within the range of that construct.

 2.  The iteration count (if any) is decremented by 1.

 3.  The DO variable (if any) is incremented by the value of the
     increment parameter (if any).

 4.  A new iteration cycle of the DO construct begins.


 Any executable statements following the CYCLE statement (including
 a labeled terminal statement) are not executed.

 A CYCLE statement can be labeled, but it cannot be used to
 terminate a DO construct.

 The following example shows the CYCLE statement:

 DO I =1, 10
   A(I) = C + D(I)
   IF (D(I) < 0) CYCLE    ! If true, the next statement is omitted
   A(I) = 0               ! from the loop and the loop is tested again.
 END DO
3 DATA                    
 Assigns values to variables at compile time.  The values within the
 backslashes are assigned to the preceding variables left to right;
 the number of values must equal the number of variable elements.
 Statement format:

    DATA nlist/clist/[[,] nlist/clist]...

    nlist  Is a list combining any combination of variable names
           and implied-DO lists, separated by commas.  RECORD 
           structures are not allowed in this list.

           Subscript expressions and expressions in substring 
           references must be initialization expressions.
  
           An implied-DO list in a DATA statement takes the 
           following form:

           (dlist, i = n1,n2[,n3])

           dlist     Is a list of one or more array elements,
                     character substrings, scalar structure
                     components or implied-DO lists, separated 
                     by commas.

           i         Is the name of a scalar integer variable.

           n1,n2,n3  Are scalar integer expressions.  The 
                     expression can contain implied-DO variables 
                     of other implied-DO lists that have this 
                     implied-DO list within their ranges.

    clist  Is a list of constants separated by commas; "clist"
           constants take one of the following forms:

           c OR n*c
  
           c  Is a constant or the symbolic name of a constant.

           n  Defines the number of times the same value is to 
              be assigned to successive entities in the associated 
              "nlist"; "n" is a nonzero, unsigned integer constant 
              or the symbolic name of an unsigned integer constant.

 The DATA statement assigns the constant values in each "clist" to
 the entities in the preceding "nlist", from left to right, as they
 appear in the "nlist".  The number of constants must equal the
 number of entities in the "nlist".

 When an unsubscripted array name appears in a DATA statement,
 values are assigned to every element of that array in the order of
 subscript progression.  The associated constant list must contain
 enough values to fill the array.

 The following objects cannot be initialized in a DATA statement:

  o  A dummy argument

  o  A function

  o  A function result

  o  An automatic object

  o  An allocatable array

  o  A variable that is accessible by use or host association

  o  A variable in a named common block (unless the DATA statement
     is in a block data program unit)

  o  A variable in blank common


 For more details, see your language reference manual.
3 DEALLOCATE              
 Frees storage allocated for allocatable arrays and pointer targets.
 It takes the following form:

   DEALLOCATE (object [,object]...[,STAT=sv])

     object  Is a structure component or the name of a variable,
             and must be a pointer or allocatable array.  

     sv      Is a scalar integer variable in which the status 
             of the deallocation is stored.

 If a STAT variable is specified, it must not be deallocated in the
 DEALLOCATE statement in which it appears.  If the deallocation is
 successful, the variable is set to zero.  If the deallocation is
 not successful, an error condition occurs, and the variable is set
 to a positive integer value (representing the run-time error).  If
 no STAT variable is specified and an error condition occurs,
 program execution terminates.

 It is recommended that all explicitly allocated storage be
 explicitly deallocated when it is no longer needed.

 For information on deallocation of allocatable arrays and pointer
 targets, see your language reference manual.

 EXAMPLES:

 The following is an example of the DEALLOCATE statement:

    INTEGER ALLOC_ERR
    REAL, ALLOCATABLE :: A(:), B(:,:)
    ...
    ALLOCATE (A(10), B(-2:8,1:5))
    ...
    DEALLOCATE(A, B, STAT = ALLOC_ERR)
3 DECODE                  
 See COMPATIBILITY_FEATURES in this Help file.
3 DEFINE_FILE            
 See COMPATIBILITY_FEATURES in this Help file.
3 DELETE                  
 Deletes a record from an indexed or a relative file.  Statement
 format:

 Format -- Indexed:

    DELETE ([UNIT=]io-unit [,ERR=label] [,IOSTAT=i-var])

    Deletes the current record (last record  read)  from  an  indexed
    file.

 Format -- Relative:

    DELETE ([UNIT=]io-unit [,REC=r] [,ERR=label] [,IOSTAT=i-var])
    DELETE (io-unit'r [,ERR=label] [,IOSTAT=i-var])

    Deletes the specified record from a relative file.

    io-unit   Is the logical unit specifier, optionally prefaced 
              by UNIT=.  UNIT= is required if unit is not the first 
              I/O specifier.

    r         Is a record position specifier, prefaced by REC=.

    io-unit'r Is a unit and a record position specifier, not 
              prefaced by REC=.

    label     Is the label of a statement to which control is 
              transferred if an error occurs, prefaced by ERR=.

    i-var     Is an I/O status specifier, prefaced by IOSTAT=.
              (Returns a zero if no error condition exists or 
              a positive integer if an error condition exists.)

 The forms of the DELETE statement with relative files are direct
 access deletes.  These forms delete the record specified by the
 number "r".

 The DELETE statement logically removes the appropriate record from
 the specified file by locating the record and marking it as a
 deleted record.  A new record can be written into that position.

 If REC=r is omitted, the current record is deleted.  When the
 direct access record is deleted, any associated variable is set to
 the next record number.
 thus, a relative pathname specifies the remainder of
3 DIMENSION               
 Specifies that an object is an array, and defines the shape of the
 array.

 The DIMENSION attribute can be specified in a type declaration
 statement or a DIMENSION statement, and takes one of the following
 forms:

 Type Declaration Statement:

  type, [att-ls,] DIMENSION (spec) [,att-ls] :: a[(spec)] [,a[(spec)]]...

 Statement:

  DIMENSION [::] a(spec) [,a(spec)]...


    type        Is a data type specifier.

    att-ls      Is an optional list of attribute specifiers.

    spec        Is an array specification.  In a type declaration,
                any array specification following an array overrides 
                any array specification following DIMENSION.

    a           Is the symbolic name of the array.  If the array 
                is not defined in a type declaration statement, the 
                array takes an implicit data type.

 An array can also be declared in the following statements:
 ALLOCATABLE, POINTER, TARGET, and COMMON.

 The DIMENSION attribute is compatible with the ALLOCATABLE,
 AUTOMATIC, INTENT, OPTIONAL, POINTER, PRIVATE, PUBLIC, SAVE,
 STATIC, TARGET, and VOLATILE attributes.

 See also DATA ARRAYS in this Help file.
3 DO                      
 Executes a block of statements repeatedly until the value of a
 control variable equals, exceeds, or is less than the terminal
 value, according to the control variable specified in the DO loop
 (indexed DO).  The block of statements starts immediately following
 the DO statement.

 You can transfer control out of a DO loop, but not out of a
 parallel DO loop.

 Statement format:

     [name:] DO [s][,] v = e1,e2[,e3]
        block
     [s] term-stmt

     name Is the name of the DO construct.

     s    Is the optional label of an executable statement 
          which follows the DO statement in the same program unit. 
          The label designates the last statement of the DO
          loop. If omitted, an END DO statement is required.

     v    Is the control variable; an integer or real variable
          (it cannot be a record field).  You cannot modify 
          the control variable inside the DO loop.

     e1   Is the initial value of the control variable; an 
          integer or real value.

     e2   Is the terminal value of the control variable; an 
          integer or real value.

     e3   Is the value by which to increment the control 
          variable after each execution of the DO loop; 
          integer or real value.  It cannot be 0. 
          The default of e3 is 1.

     block Is a sequence of zero or more statements or
           constructs.

     term-stmt Is the terminal statement for the construct.

 If the iteration count (the number of executions of the DO range)
 is zero or negative, the body of the loop is not executed.  If the
 /NOF77 compiler option is specified and the iteration count is zero
 or negative, the body of the loop is executed once.

 If a DO statement does not contain a terminal statement label, the
 construct must be terminated by an END DO statement.  If it does
 contain a terminal statement label, the END DO is optional.

 If a construct name is specified in a block DO statement, the same
 name must appear in the terminal END DO statement.  If no construct
 name is specified in the block DO statement, no name can appear in
 the terminal END DO statement.  The construct name must be a unique
 identifier in the program unit.

 The following cannot be terminal statements for DO constructs:
 CYCLE, DO, END (for a program unit), EXIT, GO TO, IF, RETURN, or
 STOP.
3 DO_WHILE                
 Executes a block of statements repeatedly until the value of a
 logical expression is false.  Statement format:

    DO [s][,] WHILE (e)

    s  Is the label of an executable statement which follows 
       the DO statement in the same program unit. The label 
       designates the last statement of the DO loop. If 
       omitted, an END DO statement is required.

    e  Is a logical expression.  You can reference and modify 
       the variable elements of the expression within the 
       DO loop.

 You can transfer control out of a DO WHILE loop but not into a loop
 from elsewhere in the program.

 The DO WHILE statement tests the logical expression at the
 beginning of each execution of the loop, including the first.  If
 the value of the expression is true, the statements in the body of
 the loop are executed; if the expression is false, control
 transfers to the statement following the loop.

 If no label appears in the DO WHILE statement, the DO WHILE loop
 must be terminated with an END DO statement.
3 ELSE                    
 Executes a block of statements if no preceding statement block in a
 block IF construct was executed.  The block of statements starts
 immediately following the ELSE statement.  The block is terminated
 by an END IF statement.  Statement format:

    ELSE
3 ELSE_IF                 
 Executes a block of statements if no preceding statement block in a
 block IF construct was executed and if the value of a logical
 expression is true.  The block of statements starts immediately
 following the ELSE IF statement.  The block is terminated by
 another ELSE IF statement, an ELSE statement, or an END IF
 statement.  Statement format:

    ELSE IF (e) THEN

    Where e represents a logical expression.
3 ELSEWHERE               
 An optional statement in a WHERE construct.  Statement format:

    ELSEWHERE (mask-expr2) [name]
    or
    ELSEWHERE [name]

 The "mask-expr2" is a logical array expression (called a mask
 expression).

 The "name" is the name of the WHERE construct.

 Assignment statements following an ELSEWHERE statement are executed
 as if they were WHERE statements with ".NOT.  where-mask-expr".  If
 ELSEWHERE specifies "mask-expr2", it is executed as "(.NOT.
 where-mask-expr) .AND.  mask-expr2".

 See also STATEMENTS WHERE in this Help file.
3 ENCODE                  
 See COMPATIBILITY_FEATURES in this Help file.
3 END                     
 Marks the end of a program unit.  The END statement must be present
 as the last statement of every program unit.  In a main program,
 execution terminates if control reaches the END statement.  In a
 subprogram, a RETURN statement is implicitly executed.  Statement
 format:

    END
3 END_DO                  
 Terminates the block of statements following a DO or DO WHILE
 statement when a label is not used.  Statement format:

    END DO
3 END_IF                  
 Terminates a block IF construct.  Statement format:

    END IF
3 END_MAP                 
 Marks the end of a map declaration within a union declaration in a
 record structure declaration block.  Terminates a field declaration
 or a series of field declarations that started with the MAP
 statement.  The END MAP statement must be present in a map
 declaration.  Statement format:

    END MAP
3 END_SELECT              
 Marks the end of a CASE construct.  Statement format:

    END SELECT [name]
3 END_STRUCTURE           
 Marks the end of a record structure declaration.  The END STRUCTURE
 statement must be present as the last statement of every record
 structure declaration.  Statement format:

    END STRUCTURE
3 END_TYPE                
 Marks the end of a derived-type definition.  The END statement must
 be present as the last statement of every derived-type definition.
 Statement format:

    END TYPE

 For more information on derived types, see DATA DERIVED_TYPES in
 this Help file.
3 END_UNION               
 Marks the end of a union declaration within a record structure
 declaration block.  The END statement must be present as the last
 statement of every union declaration.  Statement format:

    END UNION
3 ENDFILE                 
 Writes an end-of-file record to a sequential file and positions the
 file after this record (the terminal point).  Statement format:

    ENDFILE ([UNIT=]io-unit[,ERR=label][,IOSTAT=i-var])
    ENDFILE io-unit

    io-unit   Is the logical unit specifier, optionally prefaced 
              by UNIT=.  UNIT= is required if unit is not the first 
              I/O specifier.

    label     Is the label of an executable statement that 
              receives control if an error occurs, prefaced 
              by ERR=.

    i-var     Is an I/O status specifier, prefaced by IOSTAT=.
              (Returns a zero if no error condition exists or 
              a positive integer if an error condition exists.)

 If the unit specified in the ENDFILE statement is not open, the
 default file is opened for unformatted output.

 An end-of-file record can be written only to sequential
 organization files that are accessed as formatted sequential files
 or unformatted segmented sequential files.

 An ENDFILE statement must not be specified for a file that is open
 for direct or keyed access.  End-of-file records should not be
 written in files that are read by programs written in a language
 other than Fortran.
3 ENTRY                   
 Designates an alternate entry point at which execution of a
 subprogram can start.  It is not executable and must precede any
 CONTAINS statement (if any) within the subprogram.  Statement
 format:

    ENTRY nam [([p[,p]...])] [RESULT (r-name)]]

    nam     Is a symbolic name for the entry point.  The name 
            must be unique among all global names in the program.  
            In a function subprogram, the data type defined for 
            or implied by the name and the data type of the
            function must be consistent within the following groups:  

            Group 1: Type default integer, default real, double 
                     precision real, default complex, double complex,
                     or default logical
            Group 2: REAL(KIND=16) 
            Group 3: Type default character 

            If the data type is character, the length of the entry 
            point name must be the same as the function name or must 
            be of passed (or assumed) length.

    p       Is a dummy argument or an alternate return argument 
            (designated by a *).  The arguments must agree in order, 
            number, and type with the actual arguments of the 
            statement invoking the entry point.  The arguments need 
            not agree in name, order, number, or type with the dummy 
            arguments in the SUBROUTINE or FUNCTION statement for the 
            subprogram.  You must use only the dummy arguments 
            defined in the ENTRY statement.

    r-name  Is the name of a function result.  This name must not be 
            the same as the name of the entry point, or the name of 
            any other function or function result.  This parameter 
            can only be specified for function subprograms.

 The ENTRY statement is not executable and can appear within a
 function or subroutine program after the FUNCTION or SUBROUTINE
 statement.  Execution of a subprogram referred to by an entry name
 begins with the first executable statement after the ENTRY
 statement.

 An ENTRY statement must not appear in a CASE, DO, IF, FORALL, or
 WHERE construct or a nonblock DO loop.
3 EQUIVALENCE             
 Starts two or more data elements in one program unit at the same
 storage location, thereby overlaying them in memory.  Statement
 format:

    EQUIVALENCE (nlist)[,(nlist)]...

    nlist  Is a list of variables, array elements, arrays, 
           or character substring references, separated by 
           commas.  You must specify at least two of these 
           entities in each list.

 The elements named within each set of parentheses are given the
 same storage location.  The data elements do not have to be of the
 same type or length.  An equivalency begins with the first byte of
 each element.  When an array or substring element is equivalenced,
 the entire array or string is equivalenced in its normal linear
 storage.

 You cannot equivalence array or string elements in a manner that is
 inconsistent with their normal linear order.  You cannot
 equivalence elements of the same array or string.  You cannot
 equivalence two elements that are both in common areas.

 The following objects cannot be specified in EQUIVALENCE
 statements:

  o  A dummy argument

  o  An allocatable array

  o  A pointer

  o  An object of nonsequence derived type

  o  An object of sequence derived type containing a pointer in the
     structure

  o  An automatic object

  o  A function, entry, or result name

  o  A named constant

  o  A structure component

  o  A subobject of any of the above objects


 You can identify a multidimensional array element by a single
 subscript.  The single subscript designates the absolute position
 of the element within the array.
3 EXIT                    
 The EXIT statement terminates execution of a DO construct.
 Statement format:

    EXIT [name]

    name  Is the name of the DO construct. 

 The EXIT statement causes execution of the named (or innermost) DO
 construct to be terminated.

 If a DO construct name is specified, the EXIT statement must be
 within the range of that construct.

 Any DO variable present retains its last defined value.

 An EXIT statement can be labeled, but it cannot be used to
 terminate a DO construct.

 The following example shows an EXIT statement:

 LOOP_A : DO I = 1, 15
   N = N + 1
   IF (N > I) EXIT LOOP_A
 END DO LOOP_A
3 EXTERNAL                
 Allows an external or dummy procedure to be used as an actual
 argument.  (To specify intrinsic procedures as actual arguments,
 use the INTRINSIC statement.)

 The EXTERNAL attribute can be specified in a type declaration
 statement or an EXTERNAL statement, and takes one of the following
 forms:

 Type Declaration Statement:

  type [att-ls,] EXTERNAL [,att-ls] :: v[,v]...

 Statement:

  EXTERNAL v [,v]...


    type      Is a data type specifier.

    att-ls    Is an optional list of attribute specifiers.

    v         Is the symbolic name of a user-supplied subprogram, 
              or the name of a dummy argument associated with the 
              name of a subprogram.  If you name an intrinsic 
              subprogram, that name becomes disassociated from 
              the intrinsic subprogram and is assumed to be the 
              name of an external object.

 You must use EXTERNAL statements in the following cases:

  -  To identify subprogram or entry point names passed as actual
     arguments

  -  To identify a block data program unit that will reside in a
     library module not explicitly referenced at link time.


 You do not need to use an EXTERNAL statement to identify a
 subprogram or entry point name used as the object of a CALL
 statement or function reference; these names are recognized as
 external implicitly.

 The EXTERNAL attribute is compatible with the OPTIONAL, PRIVATE,
 and PUBLIC attributes.
3 FIND                    
 See COMPATIBILITY_FEATURES in this Help file.
3 FORALL                  
 A generalization of the Fortran 90 WHERE statement and construct.
 It allows more general array shapes to be assigned, especially in
 construct form.  Statement format:

   FORALL (triplet-spec [,triplet-spec]...[,mask-expr]) assign-stmt

 Construct format:

   [name: ] FORALL (triplet-spec [,triplet-spec]...[,mask-expr]) 
   forall-body-stmt
   [forall-body-stmt]...
   END FORALL [name]

   name          Is the name of the FORALL construct.

   triplet-spec  Is a triplet specification with the following form:

     subscript-name = subscript-1 : subscript-2 [:stride]

     The "subscript-name" must be a scalar of type integer.  
     It is valid only within the scope of the FORALL; its
     value is undefined on completion of the FORALL.  

     The "subscript"s and "stride" cannot contain a reference 
     to any "subscript-name" in "triplet-spec".

     The "stride" cannot be zero.  If it is omitted, the default 
     value is 1.

     Evaluation of an expression in a triplet specification must 
     not affect the result of evaluating any other expression in 
     another triplet specification.


   mask-expr  Is a logical array expression (called the mask 
              expression). If it is omitted, the value .TRUE. 
              is assumed. The mask expression can reference the 
              subscript name in "triplet-spec".

   assign-stmt  Is an assignment statement or a pointer assignment
                statement. The variable being assigned to must be 
                an array element or array section and must reference 
                all subscript names included in all "triplet-spec"s.  
                The expression being assigned must not be a 
                character expression.

   forall-body-stmt  Is one of the following:
                     o An "assign-stmt"
                     o A WHERE statement or construct
                       The WHERE statement or construct uses a mask
                       to make array assignments.
                     o A FORALL statement or construct

 If a construct name is specified in the FORALL statement, the same
 name must appear in the corresponding END FORALL statement.

 A FORALL statement is executed by first evaluating all bounds and
 stride expressions in the triplet specifications, giving a set of
 values for each subscript name.  The FORALL assignment statement is
 executed for all combinations of subscript name values for which
 the mask expression is true.

 The FORALL assignment statement is executed as if all expressions
 (on both sides of the assignment) are completely evaluated before
 any part of the left side is changed.  Valid values are assigned to
 corresponding elements of the array being assigned to.  No element
 of an array can be assigned a value more than once.

 A FORALL construct is executed as if it were multiple FORALL
 statements, with the same triplet specifications and mask
 expressions.  Each statement in the FORALL body is executed
 completely before execution begins on the next FORALL body
 statement.

 Any procedure referenced in the mask expression or FORALL
 assignment statement must be pure.

 Pure functions can be used in the mask expression or called
 directly in a FORALL statement.  Pure subroutines cannot be called
 directly in a FORALL statement, but can be called from other pure
 procedures.

 EXAMPLES:

 Consider the following:

   FORALL(I = 1:N, J = 1:N, A(I, J) .NE. 0.0) B(I, J) = 1.0 / A(I, J)

 This statement takes the reciprocal of each nonzero element of
 array A(1:N, 1:N) and assigns it to the corresponding element of
 array B.  Elements of A that are zero do not have their reciprocal
 taken, and no assignments are made to corresponding elements of B.

 Every array assignment statement and WHERE statement can be written
 as a FORALL statement, but some FORALL statements cannot be written
 using just array syntax.  For example, the preceding FORALL
 statement is equivalent to the following:

   WHERE(A /= 0.0) B = 1.0 / A

 It is also equivalent to:

   FORALL (I = 1:N, J = 1:N)
     WHERE(A(I, J) .NE. 0.0) B(I, J) = 1.0/A(I, J)
   END FORALL

 However, the following FORALL example cannot be written using just
 array syntax:

    FORALL(I = 1:N, J = 1:N) H(I, J) = 1.0/REAL(I + J - 1)

 This statement sets array element H(I, J) to the value 1.0/REAL(I +
 J - 1) for values of I and J between 1 and N.

 Consider the following:

   TYPE MONARCH
     INTEGER, POINTER :: P
   END TYPE MONARCH

   TYPE(MONARCH), DIMENSION(8)   :: PATTERN
   INTEGER, DIMENSION(8), TARGET :: OBJECT
   FORALL(J=1:8)  PATTERN(J)%P => OBJECT(1+IEOR(J-1,2))

 This FORALL statement causes elements 1 through 8 of array PATTERN
 to point to elements 3, 4, 1, 2, 7, 8, 5, and 6, respectively, of
 OBJECT.  IEOR can be referenced here because it is pure.

 The following example shows a FORALL construct:

   FORALL(I = 3:N + 1, J = 3:N + 1)
     C(I, J) = C(I, J + 2) + C(I, J - 2) + C(I + 2, J) + C(I - 2, J)
     D(I, J) = C(I, J)
   END FORALL

 The assignment to array D uses the values of C computed in the
 first statement in the construct, not the values before the
 construct began execution.

 FORALL is a DIGITAL Fortran extension to Fortran 90, but it is a
 language feature of Fortran 95.
3 FORMAT                  
 Defines the conversion of data in formatted data transfer
 operations.  Statement format:

    FORMAT (q1 f1s1 f2s2 ... fnsn qn)

    qn   Is zero or more slash (/) record terminators.

    fn   Is a data edit (field) descriptor, a control edit 
         descriptor, a string edit descriptor, or a group of 
         such descriptors enclosed in parentheses.

    sn   Is a field separator (a comma or slash).  A
         comma can be omitted in the following cases:

         o Between a P edit descriptor and an immediately
           following F, E, D, or G edit descriptor.

         o Before or after a slash (/) record terminator.

         o Before or after a colon (:) edit descriptor.

 The "data edit descriptor" has one of the following forms:

    [r]c  [r]cw  [r]cw.m  [r]cw.d[Ee]

    r    Is the optional repeat count.  (If you omit r, 
         the repeat count is assumed to be 1.)

    c    Is a format code (I,O,Z,F,E,EN,ES,D,G,L, or A).

    w    Is the external field width in characters.  Each
         data item in the external medium is called an 
         external field.

    m    Is the minimum number of characters that must appear 
         in the field (including leading zeros).

    d    Is the number of characters to the right of the decimal point.

    E    Is an exponent field.

    e    Is the number of characters in the exponent.

 The ranges for "r", "w", "m", "d", and "e" are as follows:

 Term      Range                 
 ----      __________                 
  r        1 to 2147483647 (2**31-1)  
  w        1 to 2147483647            
  m        0 to 32767 (2**15-1)       
  d        0 to 32767                 
  e        1 to 32767                 

 The terms must all be unsigned integer constants or variable format
 expressions.  A variable format expression is an integer variable
 or expression enclosed in angle brackets that takes the place of an
 integer constant.  The value of the variable or variables can
 change during program execution.

 You cannot use PARAMETER constants for "r", "w", "m", "d", or "e".

 The "control edit descriptor" has one of the following forms:

    c  [n]c  c[n]
   
    c     Is a format code (X,T,TL,TR,SP,SS,S,BN,BZ,P,
          Q, $, or :).

    n     Is the optional number of characters or character
          positions.

 The term "n" must be an unsigned integer constant (for format code
 P, it can be signed or unsigned) or a variable format expression.
 A variable format expression is an integer variable or expression
 enclosed in angle brackets that takes the place of an integer
 constant.  The value of the variable or variables can change during
 program execution.

 The value of "n" for P must be within the range -128 to 127.  For
 all other format codes, the value of "n" must be within the range 1
 through 2147483647 (2**31-1); actual useful ranges may be
 constrained by record sizes (RECL) and the file system.


 The "string edit descriptor" has one of the following forms:

    "string" 'string'  nHc1...cn
   
    string  Is a character literal constant.

    n       Is the number of characters to be transferred.

    c1...cn Is a string of printable ASCII characters.

 Although no string edit descriptor can be preceded by a repeat
 specification, a parenthesized group of string edit descriptors can
 be preceded by a repeat specification.

 For more information, see FORMAT_SPECIFIERS in this Help file.
3 FUNCTION                
 Begins a function subprogram.  Identifies the data type of the
 function and names the dummy arguments.  Format:

    [prefx] FUNCTION nam [([p[,p]...])] [RESULT (r-nam)]

    prefx Is either:

          typ [kywd]
          kywd [typ]

    typ   Is a data type.  If you do not specify a data type, 
          the data type of the function is implied from its 
          name.  
          
          If the data type is CHARACTER, you can specify 
          CHARACTER*(*) to indicate an assumed-length function
          type -- the function type assumes the length of its 
          definition in the program unit invoking it. Assumed-
          length character functions are obsolescent in
          Fortran 95.  DIGITAL Fortran flags obsolescent features, 
          but fully supports them.

    kywd  Is one of the following:

          RECURSIVE    Permits direct recursion to occur.  If
                       a function is directly recursive and 
                       array valued, RESULT must also be
                       specified.
          
          PURE         Restricts the procedure from having
                       side effects.

          ELEMENTAL    Specifies PURE with certain constraints:
                       o A dummy argument:
                         - Must be scalar and cannot have the POINTER 
                           attribute
                         - Cannot appear in a specification expression,
                           except as an argument to the BIT_SIZE, KIND, 
                           or LEN intrinsic functions or the numeric 
                           inquiry intrinsic functions
                         - Must not be *
                         - Must not be a dummy procedure
                       o The function result must be scalar and cannot 
                         have the POINTER attribute.
                       If ELEMENT is specified, RECURSIVE must not 
                       be specified.

          EXTRINSIC(HPF), EXTRINSIC(HPF_LOCAL), and 
          EXTRINSIC(SCALAR) can also be specified, but they
          have no effect on OpenVMS systems.


    nam   Is a symbolic name for the function.  The name must be 
          unique among all global names in the program.  The name 
          is used as a variable within the function.  The value of 
          the variable is returned to the caller of the function 
          as the value of the function.

          The name can be followed by * and the length of the data 
          type. It must be one of the valid length specifiers for 
          "typ".  This length overrides the length specified or 
          implied by the type.  This length specification is not 
          permitted if the length has already been specified 
          following CHARACTER.

    p     Is an unsubscripted variable name specifying a dummy 
          argument.  The arguments must agree in order, number, and 
          type with the actual arguments of the statement invoking 
          the function.  A dummy argument must not be defined as an 
          array with more elements than the actual argument holds.

    r-nam Is the name of the function result.  This name must not 
          be the same as the function name.

 The array declarator for a dummy argument can itself contain
 integer values that are dummy arguments or are references to a
 common block, providing for adjustable size arrays in functions.
 The upper bound of the array declarator for a dummy argument can be
 specified as an asterisk, in which case the upper bound of the
 dummy argument assumes the size of the upper bound of the actual
 argument.  The size in a character string declarator for a dummy
 argument can be specified as an asterisk in parentheses (*) -- in
 which case the size of the actual argument is passed to the dummy
 argument.

 The values of the actual arguments in the invoking program unit
 become the values of the dummy arguments in the function.  If you
 modify a dummy argument, the corresponding actual argument in the
 invoking program unit is also modified; the actual argument must be
 a variable if it is to be modified.

 If the actual argument is a character constant, the dummy argument
 can be either character or numeric in type, unless the name of the
 subprogram being invoked is a dummy argument in the invoking
 program unit.  If the actual argument is a Hollerith constant, the
 dummy argument must be numeric.

 The FUNCTION statement must be the first statement of a function
 subprogram, unless an OPTIONS statement is specified.  A function
 subprogram cannot contain a SUBROUTINE statement, a BLOCK DATA
 statement, a PROGRAM statement, or another FUNCTION statement.
 ENTRY statements can be included to provide multiple entry points
 to the subprogram.

                                NOTE

         In a function, the function name identifier  refers
         to  the  return  value,  not  the  function itself,
         unless an argument list is present.  Therefore,  it
         is  not  possible to pass a function as an argument
         to another routine from inside the  function.   For
         example, consider the following:

            INTEGER FUNCTION RECURSIVE_FUNCTION
               . 
               .
               .
            CALL OTHERSUB (RECURSIVE_FUNCTION)

         The reference to  RECURSIVE_FUNCTION  in  the  CALL
         statement passes the function return value, not the
         function itself.

4 RESULT_Keyword          
 Specifies a name for the result variable of a function.  Its name
 must be different from the name of the function.

 If RESULT "is not" specified, the function name is the result
 variable.  All references to the function are references to the
 function result variable.

 If RESULT "is" specified, the result name is the result variable.
 In this case, all references to the function name are recursive
 calls, and the function name must not appear in specification
 statements.

 The following is an example of a recursive function specifying a
 RESULT variable:

   RECURSIVE FUNCTION FACTORIAL(P) RESULT(L)
     INTEGER, INTENT(IN) :: P
     INTEGER L
     IF (P == 1) THEN
       L = 1
     ELSE
       L = P * FACTORIAL(P - 1)
     END IF
   END FUNCTION
4 Function_Reference      
 Transfers control and passes arguments to a function.  Format:

    nam (p[,p]...)

    nam  Is the name of the function or the name of an entry 
         point to the function.

    p    Is a value to be passed to the function.  The value 
         can be a constant, the name of a variable, the name 
         of an array element, the name of an array, an expression, 
         a substring, field reference, or the name of a subprogram 
         or entry point to a subprogram (must be defined as 
         external).  You must not specify more than 255 arguments.
3 GOTO                    
 Transfers control within a program unit.  Depending upon the value
 of an expression, control is transferred either to the same
 statement every time GO TO is executed or to one of a set of
 statements.
4 Unconditional  
 Transfers control unconditionally to the same statement every time
 the GO TO is executed.  Statement format:

    GO TO s

    s  Is the label of an executable statement that is 
       in the same program unit as the GO TO statement.
4 Computed       
 Transfers control to a statement based upon the value of an
 expression within the statement.  Statement format:

    GO TO (slist)[,]e

    slist  Is a list of one or more labels of executable 
           statements separated by commas. The list of labels 
           is called the transfer list.

    e      Is an integer arithmetic expression in the range 
           1 to n (where "n" is the number of statement labels 
           in the transfer list).

 If the value of "e" is less than one or greater than the number of
 labels in the transfer list, control is transferred to the first
 executable statement after the computed GO TO.


                                NOTE

         This  statement  is  obsolescent  in  Fortran   95.
         DIGITAL  Fortran  flags  obsolescent  features, but
         fully supports them.

4 Assigned       
 Transfers control to a statement label that is represented by a
 variable.  An ASSIGN statement must establish a relationship
 between the variable and the specified statement label.  Statement
 format:

    GO TO v[[,](slist)]

    v      Is an integer variable whose value was set by a 
           preceding ASSIGN statement in the same program unit.

    slist  Is a list of one or more labels of executable 
           statements separated by commas.

 The assigned GO TO statement is an obsolescent feature in Fortran
 90, which is deleted in Fortran 95.  DIGITAL Fortran flags deleted
 and obsolescent features, but fully supports them.
3 IF                      
 Conditionally transfers control or executes a statement or block of
 statements.

 For each type of IF statement, the decision to transfer control or
 to execute the statement or block of statements is based on the
 evaluation of an expression within the IF statement.
4 Arithmetic 
 Conditionally transfers control to one of three statements, based
 on the current value of an arithmetic expression.  Statement
 format:

    IF (e) s1,s2,s3

    e         Is an arithmetic expression.

    s1,s2,s3  Are labels of executable statements in the same 
              program unit.  All three labels are required, 
              but they need not refer to different statements.

 Executes the statement at the first label ("s1") if the arithmetic
 expression evaluates to a value less than 0; the statement at the
 second label ("s2") if the arithmetic expression evaluates to 0; or
 the statement at the third label ("s3") if the arithmetic
 expression evaluates to a value greater than 0.


                                NOTE

         The  arithmetic  IF  statement  is  an  obsolescent
         feature  in  Fortran  90  and  Fortran 95.  DIGITAL
         Fortran  flags  obsolescent  features,  but   fully
         supports them.

4 Logical    
 Executes the statement if the logical expression is true.  In
 Fortran 90, this is called an IF statement (as compared to block
 IFs, which are called IF constructs).  Statement format:

    IF (e) st

    e   Is a logical expression.

    st  Is a complete Fortran statement. The statement can 
        be any statement except DO, END DO, END, block IF, 
        CASE constructs, or another logical IF statement.
4 Block      
 Executes a block of statements if the logical expression is true.
 The block of statements starts immediately following the IF
 statement.  The block of statements can be followed by optional
 ELSE IF statements (any number) and one optional ELSE statement.
 The entire block IF construct must be terminated by an END IF
 statement.  Format:

    [name:] IF (e) THEN
      block
    [ELSE IF (e1) THEN [name]
      block]...
    [ELSE [name]
      block]
    END IF [name]

    name   Is the name of the IF construct.

    e,e1   Are logical expressions.

    block  Is a series of zero or more Fortran statements
           (called a statement block).

 If a construct name is specified in a block IF statement, the same
 name must appear in the terminal END IF statement.  If no construct
 name is specified in the block IF statement, no name can appear in
 the terminal END IF statement.  The construct name must be a unique
 identifier in the program unit.

                                NOTE

         No additional statement can be placed after the  IF
         THEN  statement  in  a  block  IF  construct.   For
         example, the following statement is invalid in  the
         block IF construct:

            IF (e) THEN I = J

         This  statement  is  translated  as  the  following
         logical IF statement:

            IF (e) THENI = J

3 IMPLICIT                
 Overrides implied (default) data typing of symbolic names.
 Statement format:

    IMPLICIT typ (a[,a]...)[,typ (a[,a]...)]...

    typ  Is any data type except CHARACTER*(*).  When "typ" 
         is equal to CHARACTER*len, "len" specifies the length 
         for character data type.  The "len" is an unsigned 
         integer constant or an integer constant expression 
         enclosed in parentheses, and must be in the range of 
         1 to 2**31-1.

    a    Is an alphabetical character.  If you specify a 
         range of alphabetic characters (two characters 
         joined by a hyphen), the first character must be 
         less than the second.

 The IMPLICIT statement assigns the specified data type to all
 symbolic names that have no explicit data type and begins with the
 specified letter or range of letters.  It has no effect on the
 default types of intrinsic procedures.
3 IMPLICIT_NONE           
 Disables the implicit declaration of data types in the program
 unit.  When it is used, you must declare the data types of all
 symbols explicitly.  You must not include any other IMPLICIT
 statements in the program unit containing an IMPLICIT NONE
 statement.  Statement format:

    IMPLICIT NONE

                                NOTE

         To receive diagnostic messages when  variables  are
         used   but   not  declared,  you  can  specify  the
         /WARNINGS=DECLARATIONS compiler option  instead  of
         IMPLICIT NONE.

3 INCLUDE                 
 Directs the compiler to stop reading statements from the current
 file and read the statements in the included file or module.  When
 it reaches the end of the included file or module, the compiler
 resumes compilation with the next statement after the INCLUDE
 statement.  Statement format:

    INCLUDE 'full-file-name[/[NO]LIST]'

    INCLUDE '[text-lib] (module-name)[/[NO]LIST]' 

    full-file-name  Is a character string that specifies 
                    the file to be included.  The form of
                    the "full-file-name" must be acceptable
                    to the operating system, as described
                    in your user manual.

    /[NO]LIST       Specifies whether the incorporated code 
                    is to appear in the compilation source 
                    listing.  In the listing, a number 
                    precedes each incorporated statement.  The 
                    number indicates the "include" nesting 
                    depth of the code. The default is /NOLIST.  
                    /LIST and /NOLIST must be spelled completely.

    text-lib        Is a character string that specifies the 
                    "full-file-name" of the text library to be 
                    searched.  Its form must be acceptable to 
                    the operating system, as described in your 
                    user manual.

    module-name     Is the name of the text module, located in 
                    a text library, that is to be included. The 
                    name of the module must be enclosed in 
                    parentheses.  It can be up to 31 characters 
                    long and can contain any alphanumeric character 
                    and the special characters dollar sign ($) and 
                    underscore (_).

 The file or module must contain valid Fortran statements.  The file
 or module cannot start with a continuation line, but it can contain
 an INCLUDE statement.

 The limit on nesting depth is when system resources are exhausted.

 In the following example, the file COMMON.FOR defines a parameter
 constant M, and defines arrays X and Y as part of the blank common
 block.

    Main Program File              COMMON.FOR File
    -----------------              ---------------
    INCLUDE 'COMMON.FOR'           PARAMETER (M=100)
    DIMENSION Z(M)                 COMMON X(M),Y(M)
    CALL CUBE
    DO 5, I=1,M

 5  Z(I) = X(I)+SQRT(Y(I))
        .
        .
        .
    END

    SUBROUTINE CUBE
    INCLUDE 'COMMON.FOR'
    DO 10, I=1,M
 10 X(I) = Y(I)**3
    RETURN
    END
3 Input_Output            
 Transfer I/O statements include READ, WRITE, REWRITE, ACCEPT, TYPE,
 and PRINT.  Auxiliary I/O statements include OPEN, CLOSE, INQUIRE,
 REWIND, BACKSPACE, ENDFILE, DELETE, and UNLOCK.

 Transfer I/O statements may be formatted (F), unformatted (U),
 list-directed (L-D), or namelist (N) as follows:

    ACCEPT     Sequential -- F, L-D, N
    DELETE     Relative -- U
               Indexed -- U 
    PRINT      Sequential -- F, L-D, N
    READ       Sequential -- F, U, L-D, N
               Direct Access -- F, U
               Internal -- F, L-D
               Indexed -- F, U 
    REWRITE    Relative -- F, U
               Sequential -- F
               Indexed -- F, U 
    TYPE       Sequential -- F, L-D, N
    WRITE      Sequential -- F, U, L-D, N
               Direct Access -- F, U
               Internal -- F, L-D
               Indexed -- F, U 
4 Formatted        
 Formatted I/O statements contain explicit format specifiers that
 are used to control the translation of data from internal (binary)
 form within a program to external (readable character) form in the
 records, or vice versa.

 Formatted I/O statements must have a format (FMT=) specified in the
 control list (clist).  Additional "clist" elements are required
 depending on the type of access.

 Formatted sequential READ:

   READ (UNIT=u,FMT=f[,ADVANCE=exp][,SIZE=var][,IOSTAT=ios]
         [,ERR=err][,END=end]) [iolist]
   READ f [,iolist]

 Formatted direct access READ:

   READ (UNIT=u,REC=rec,FMT=f[,IOSTAT=ios][,ERR=err]) [iolist]
    
 Formatted indexed READ:

   READ (UNIT=u,FMT=f,KEY=k[,KEYID=n][,IOSTAT=ios]
        [,ERR=err]) [iolist]

 Formatted internal READ:

   READ (UNIT=u,FMT=f[,IOSTAT=ios][,ERR=err][,END=end]) [iolist]

 Formatted sequential WRITE:

   WRITE (UNIT=u,FMT=f[,ADVANCE=exp][,IOSTAT=ios]
         [,ERR=err]) [iolist]

 Formatted direct access WRITE:

   WRITE (UNIT=u,REC=rec,FMT=f[,IOSTAT=ios][,ERR=err]) [iolist]

 Formatted indexed WRITE:

   WRITE (UNIT=u,FMT=f[,IOSTAT=ios][,ERR=err]) [iolist]

 Formatted internal WRITE:

   WRITE (UNIT=u,FMT=f[,IOSTAT=ios][,ERR=err]) [iolist]
4 Unformatted      
 Unformatted I/O statements do not contain format specifiers and
 therefore do not translate the data being transferred.

 Unformatted I/O is especially appropriate where the output data
 will subsequently be used as input.  Unformatted I/O saves
 execution time by eliminating the data translation process,
 preserves greater precision in the external data, and usually
 conserves file storage space.

 Unformatted I/O statements do not specify a format (FMT=) in the
 control list (clist).  Other "clist" elements are required
 depending on the type of access.

 Unformatted sequential READ:

   READ (UNIT=u[,IOSTAT=ios][,ERR=err][,END=end]) [iolist]

 Unformatted direct access READ:

   READ (UNIT=u,REC=rec[,IOSTAT=ios][,ERR=err]) [iolist]

 Unformatted indexed READ:

   READ (UNIT=u,KEY=k[,KEYID=n][,IOSTAT=ios][,ERR=err]) [iolist]

 Unformatted sequential WRITE:

   WRITE (UNIT=u,[,IOSTAT=ios][,ERR=err]) [iolist]

 Unformatted direct access WRITE:

   WRITE (UNIT=u,REC=rec[,IOSTAT=ios][,ERR=err]) [iolist]

 Unformatted indexed WRITE:

   WRITE (UNIT=u[,IOSTAT=ios][,ERR=err]) [iolist]
4 List-Directed    
 List-directed I/O statements are similar to formatted statements in
 function, but control the translation of data through data types
 instead of explicit format specifiers.

 List-directed I/O statements specify a format (FMT=) in the control
 list (clist).  Other "clist" elements are required depending on the
 type of access.

 List-directed sequential READ:

   READ (UNIT=u,FMT=*[,IOSTAT=ios][,ERR=err][,END=end]) [iolist]
   READ * [,iolist]

 List-directed internal READ

   READ (UNIT=u,FMT=*[,IOSTAT=ios][,ERR=err][,END=end]) [iolist]

 List-directed sequential WRITE

   WRITE (UNIT=u,FMT=*[,IOSTAT=ios][,ERR=err]) [iolist]

 List-directed internal WRITE

   WRITE (UNIT=u,FMT=*[,IOSTAT=ios][,ERR=err]) [iolist]
4 Namelist           
 Namelist I/O statements are similar to formatted statements in
 function, but control the translation of data through data types
 instead of explicit format specifiers.

 Namelist I/O statements do not specify a format (FMT=) in the
 control list (clist).

 Namelist sequential READ:

    READ (UNIT=u,NML=nml[,IOSTAT=ios][,ERR=err][,END=end]) 
    READ n

 Namelist sequential WRITE:

   WRITE (UNIT=u,NML=nml[,IOSTAT=ios][,ERR=err]) 

 Comments (beginning with !  only) can appear anywhere in namelist
 input.  The comment extends to the end of the source line.
3 INQUIRE                 
 Returns information about specified properties of a file or of a
 logical unit on which a file might be opened.  The unit need not
 exist, nor need it be connected to a file.  If the unit is
 connected to a file, the inquiry encompasses both the connection
 and the file.  Statement format:

    INQUIRE (FILE=fi [,DEFAULTFILE=dfi...], flist)
    INQUIRE ([UNIT=]u,flist)

    fi     Is a character expression, numeric scalar memory 
           reference, or numeric array name reference whose 
           value specifies the name of the file to be 
           inquired about.  

    dfi    Is a character expression specifying a default file 
           pathname (or file specification) string.  

    flist  Is a list of property specifiers in which any one 
           specifier appears only once.  Information about the 
           individual specifiers is available under the 
           subtopic headings listed at the end of this Help 
           topic.

    u      Is an integer variable or constant specifying the 
           logical unit number of the file, optionally prefaced 
           by UNIT=.  UNIT= is required if unit is not the 
           first I/O specifier.  The unit does not have to 
           exist, nor does it need to be connected to a file.
           If the unit is connected to a file, the inquiry 
           encompasses both the connection and the file.

 FILE=fi and UNIT=u can appear anywhere in the property-specifier
 list; however, if the UNIT keyword is omitted, the unit specifier
 ("u") must be the first parameter in the list.

 When inquiring by file, you can specify DEFAULTFILE=dfi in addition
 to, or in place of, FILE=fi.  If a file is open with both FILE and
 DEFAULTFILE keywords specified in the OPEN statement, then you can
 inquire about this file by specifying both the FILE and DEFAULTFILE
 keywords in the INQUIRE statement.

 An INQUIRE statement may be executed before, during, or after the
 connection of a file to a unit.  The values assigned by the
 statement are those that are current when the INQUIRE statement
 executes.

 You can use INQUIRE to get file characteristics before opening a
 file.  (File characteristics are stored in the file header.)
4 ACCESS          
 ACCESS = acc

 acc  Is a scalar default character variable that is 
      assigned one of the following values:

 'SEQUENTIAL'      If the file is open for sequential access 
 'DIRECT'          If the file is open for direct access 
 'KEYED'(VMS only) If the file is open for keyed access
 'UNDEFINED'       If the file is not open
4 ACTION          
 ACTION = act

 act  Is a scalar default character variable that is assigned
      one of the following values:

 'READ'       If the file is connected for input only
 'WRITE'      If the file is connected for output only
 'READWRITE'  If the file is connected for both input 
              and output
 'UNDEFINED'  If the file is not connected
4 BINARY (WNT,W95)  
 BINARY = bin

 bin  Is a scalar default character variable that is assigned
      one of the following values:

 'YES'       If the file is connected to a binary file
 'NO'        If the file is connected to a nonbinary file
 'UNKNOWN'   If the file is not connected
4 BLANK           
 BLANK = blnk

 blnk  Is a character scalar memory reference that is 
       assigned one of the following values:

 'NULL'      If null blank control is in effect for the
             file open for formatted I/O.  (Blanks are 
             ignored unless the field is all blanks, in
             which case it is treated as zero.)

 'ZERO'      If zero blank control is in effect.  (All 
             blanks other than leading blanks are treated 
             as zeros.)

 'UNDEFINED' If the file is not open or if the existing
             file is not open for formatted I/O.
4 BLOCKSIZE (WNT,W95)  
 BLOCKSIZE = bks

 bks  Is a scalar default integer variable.

 The "bks" is assigned the current size of the I/O buffer.  If the
 unit or file is not connected, the value assigned is zero.
4 CARRIAGECONTROL
 CARRIAGECONTROL = cc

 cc  Is a character scalar memory reference that is
     assigned one of the following values:

 'FORTRAN'  If the file is open with the FORTRAN carriage 
            control 
 'LIST'     If the file is open with implied carriage control
            (single spacing between records)
 'NONE'     If the file is open with no carriage control 
            attribute
 'UNKNOWN'  If the file is not open
4 CONVERT         
 CONVERT = fm

 fm  Is a character scalar memory reference that is assigned 
     one of the following values:

 'LITTLE_ENDIAN':  If the file is open with little endian 
                   integer and IEEE floating-point data 
                   conversion in effect.

 'BIG_ENDIAN':     If the file is open with big endian 
                   integer and IEEE floating-point data 
                   conversion in effect.

 'CRAY':           If the file is open with big endian 
                   integer and CRAY floating-point data 
                   conversion in effect.

 'FDX':            If the file is open with little endian 
                   integer and DIGITAL VAX F_floating, 
                   D_floating, and IEEE X_floating data 
                   conversion in effect.

 'FGX':            If the file is open with little endian 
                   integer and DIGITAL VAX F_floating, 
                   G_floating, and IEEE X_floating data 
                   conversion in effect.

 'IBM':            If the file is open with big endian 
                   integer and IBM System\370 floating-
                   point data conversion in effect.

 'VAXD':           If the file is open with little endian 
                   integer and DIGITAL VAX F_floating, 
                   D_floating, and H_floating data 
                   conversion in effect.

 'VAXG':           If the file is open with little endian 
                   integer and DIGITAL VAX F_floating, 
                   G_floating, and H_floating data 
                   conversion in effect.

 'NATIVE':         If the file is open with no data 
                   conversion in effect.

 'UNKNOWN':        If the file or unit is not connected 
                   for unformatted I/O.
4 DELIM           
 DELIM = del

 del  Is a scalar default character variable that is assigned
      one of the following values:

 'APOSTROPHE'  If apostrophes are used to delimit character 
               constants in list-directed and namelist output

 'QUOTE'       If quotation marks are used to delimit character 
               constants in list-directed and namelist output

 'NONE'        If no delimiters are used

 'UNDEFINED'   If the file is not connected, or is not connected 
               for formatted data transfer
4 DIRECT          
 DIRECT = dir

 dir  Is a character scalar memory reference that is
      assigned one of the following values:

 'YES'       If the file is open for direct access
 'NO'        If the file is not open for direct access
 'UNKNOWN'   If the file is not open
4 ERR             
 ERR = s

 s  Is the label of an executable statement.

 ERR is a control specifier rather than a property specifier.  If an
 error occurs during the execution of the INQUIRE statement, control
 is transferred to the statement whose label is "s".
4 EXIST           
 EXIST = lv

 lv  Is a logical scalar memory reference that is
     assigned one of the following values:

 .TRUE.    If the specified file exists and can be opened 
           or if the unit exists
 .FALSE.   If the specified file or unit does not exist or 
           if the file exists but cannot be opened 

 The unit exists if it is a number in the range allowed by the
 processor.
4 FORM            
 FORM = fm

 fm  Is a character scalar memory reference that is
     assigned one of the following values:

 'FORMATTED'       If the file is open for formatted I/O
 'UNFORMATTED'     If the file is open for unformatted I/O
 'BINARY'(WNT,W95) If the file is open for binary I/O
 'UNDEFINED'       If the file is not open
4 FORMATTED       
 FORMATTED = fmd

 fmd  Is a character character scalar memory reference that is
      assigned one of the following values:

 'YES'       If formatted I/O is allowed
 'NO'        If formatted I/O is not allowed
 'UNKNOWN'   If the processor cannot determine whether formatted
             I/O is allowed
4 IOFOCUS (WNT,W95)  
 IOFOCUS = iof

 iof Is a scalar default logical variable that is
      assigned one of the following values:

 .TRUE.     If the specified unit is the active window in a 
            QuickWin application
 .FALSE.    If the specified unit is not the active window in a 
            QuickWin application
4 IOSTAT          
 IOSTAT = ios

 ios  Is a scalar default integer variable.

 IOSTAT is a control specifier rather than a property specifier.
 The "ios" is assigned a processor-dependent positive integer value
 if an error occurs during execution of the INQUIRE statement; it is
 assigned the value zero if there is no error condition.
4 KEYED (VMS only)  
 KEYED = kyd

 kyd  Is a character scalar memory reference that is assigned
      one of the following values:

 'YES'       If keyed access is allowed.
 'NO'        If keyed access is not allowed.
 'UNKNOWN'   If the processor cannot determine whether
             keyed access is allowed
4 MODE (WNT,W95)  
 MODE is a nonstandard synonym for ACTION.  (See INQ ACTION.)
4 NAME            
 NAME = nme

 nme  Is a character scalar memory reference that is 
      assigned the name of the file being inquired about.  
      If the file does not have a name, "nme" is undefined.

                                NOTE

         The FILE and NAME keywords are synonyms  when  used
         with the OPEN statement, but not when used with the
         INQUIRE statement.

4 NAMED           
 NAMED = nmd

 nmd  Is a logical scalar memory reference that is
      assigned one of the following values:

 .TRUE.    If the specified file has a name
 .FALSE.   If the file does not have a name
4 NEXTREC         
 NEXTREC = nr

 nr  Is a scalar default integer variable whose value depends
     on the following conditions:

     - If a record was previously read or written on the 
       specified unit, the value of "nr" is one more than the 
       number of that record.

     - If no records have been read or written, the value 
       of "nr" is 1.

     - If the file is not opened for direct access or if the 
       position is indeterminate because of an error condition, 
       "nr" is 0.
4 NUMBER          
 NUMBER = num

 num  Is a scalar default integer variable to which the 
      logical unit number of the file is returned.  No value 
      is returned if the file is not connected to a unit.
4 OPENED          
 OPENED = od

 od  Is a logical scalar memory reference that is
     assigned one of the following values:

 .TRUE.    If the specified file or unit is open
 .FALSE.   If the specified file or unit is not open
4 ORGANIZATION    
 ORGANIZATION = org

 org  Is a character scalar memory reference that is
      assigned one of the following values:

 'SEQUENTIAL'         If the file is a sequential file
 'RELATIVE'           If the file is a relative file
 'INDEXED'(VMS only)  If the file is an indexed file
 'UNKNOWN'            If the file organization cannot 
                       be determined
4 PAD             
 PAD = pd

 pd   Is a scalar default character variable that is assigned
      one of the following values:

 'NO'   If the file or unit was connected with PAD='NO'

 'YES'  If the file or unit was connected with PAD='YES'
4 POSITION        
 POSITION = pos

 pos   Is a scalar default character variable that is assigned
       one of the following values:

 'REWIND'    If  the file is connected with its position 
             at its initial point

 'APPEND'    If the file is connected with its position 
             at its terminal point (or before its end-of-file 
             record, if any)

 'ASIS'      If the file is connected without changing 
             its position

 'UNDEFINED' If the file is not connected, or is connected 
             for direct access data transfer
4 READ            
 READ = rd

 rd   Is a scalar default character variable that is assigned
      one of the following values:

 'YES'     If the file can be read

 'NO'      If the file cannot be read

 'UNKNOWN' If the processor cannot determine whether 
           the file can be read
4 READWRITE       
 READWRITE = rdwr

 rdwr   Is a scalar default character variable that is assigned
        one of the following values:

 'YES'     If the file can be both read and written to

 'NO'      If the file cannot be both read and written to

 'UNKNOWN' If the processor cannot determine whether 
           the file can be both read and written to
4 RECL            
 RECL = rcl

 rcl  Is an integer scalar memory reference to which the 
      maximum allowed record length is returned if the file 
      or unit is open.  If the file or unit is not open or 
      does not exist, rcl is zero.

 The assigned value is expressed in longwords (4-byte units) if the
 file is currently (or was previously) connected for unformatted
 data transfer; otherwise, the value is expressed in bytes.
4 RECORDTYPE      
 RECORDTYPE = rtype

 rtype  Is a character scalar memory reference that is
        assigned one of the following values:

 'FIXED'       If the file is open for fixed-length records
 'VARIABLE'    If the file is open for variable-length records
 'SEGMENTED'   If the file is open for unformatted sequential
               I/O using segmented records
 'STREAM'      If the file's records are not terminated
 'STREAM_CR'   If the file's records are terminated with a 
               carriage-return
 'STREAM_LF'   If the file's records are terminated with a 
               line-feed
 'UNKNOWN'     If the processor cannot determine the record type
               or the file is not open
4 SEQUENTIAL      
 SEQUENTIAL = seq

 seq  Is a character scalar memory reference that is
      assigned one of the following values:

 'YES'       If sequential access is allowed for the 
             specified file
 'NO'        If sequential access is not allowed
 'UNKNOWN'   If the access mode cannot be determined
4 SHARE (WNT,W95)  
 SHARE = shr

 shr  Is a scalar default character variable that is 
      assigned one of the following values:

 'DENYRW'      If the file is open for deny-read/write mode
 'DENYWR'      If the file is open for deny-write mode
 'DENYRD'      If the file is open for deny-read mode
 'DENYNONE'    If the file is open for deny-none mode
 'UNDEFINED'   If the file is not open
4 UNFORMATTED     
 UNFORMATTED = unf

 unf  Is a character scalar memory reference that is
      assigned one of the following values:

 'YES'       If unformatted I/O is allowed for the 
             specified file
 'NO'        If unformatted I/O is not allowed
 'UNKNOWN'   If the form cannot be determined
4 WRITE           
 WRITE = wr

 wr   Is a scalar default character variable that is assigned
      one of the following values:

 'YES'     If the file can be written to

 'NO'      If the file cannot be written to

 'UNKNOWN' If the processor cannot determine whether 
           the file can be written to
3 INTENT                  
 Specifies the intended use of one or more dummy arguments.

 The INTENT attribute can be specified in a type declaration
 statement or an INTENT statement, and takes one of the following
 forms:

 Type Declaration Statement:

   type, [att-ls,] INTENT (spec) [,att-ls] :: d [, d]...

 Statement:

   INTENT (spec) [::] d [, d]...

    type      Is a data type specifier.

    att-ls    Is an optional list of attribute specifiers.

    spec      Is one of the following specifiers:

              IN    Specifies that the dummy argument must 
                    not be redefined (or become undefined) 
                    during execution of the procedure.

                    Any associated actual argument must be 
                    an expression.

              OUT   Specifies that the dummy argument must be 
                    defined before it is referenced in the 
                    procedure.

                    Any associated actual argument must be 
                    definable.  The argument becomes undefined 
                    on entry to the procedure, and is intended 
                    only to pass information out of the procedure.

              INOUT Specifies that the dummy argument can both 
                    receive data from and return data to the 
                    calling program unit.  
           
                    Any associated actual argument must be 
                    definable.

    d         Is the name of a dummy argument.  It cannot 
              be a dummy procedure or dummy pointer.

 If no INTENT attribute is specified for a dummy argument, its use
 is subject to the limitations of the associated actual argument.

 If a function specifies a defined operator, the dummy arguments
 must have intent IN.

 If a subroutine specifies defined assignment, the first argument
 must have intent OUT or INOUT, and the second argument must have
 intent IN.

 If an actual argument is an array section with a vector subscript,
 it cannot be associated with a dummy array that is defined or
 redefined (has intent OUT or INOUT).

 The INTENT attribute is compatible with the DIMENSION, OPTIONAL,
 TARGET, and VOLATILE attributes.

 EXAMPLES:

 The following example shows type declaration statements specifying
 the INTENT attribute:

   SUBROUTINE TEST(I, J)
     INTEGER, INTENT(IN) :: I
     INTEGER, INTENT(OUT), DIMENSION(I) :: J

 The following are examples of the INTENT statement:

   SUBROUTINE TEST(A, B, X)
      INTENT(INOUT) :: A, B
      ...

   SUBROUTINE CHANGE(FROM, TO)
      USE EMPLOYEE_MODULE
      TYPE(EMPLOYEE) FROM, TO
      INTENT(IN) FROM
      INTENT(OUT) TO
      ...
3 INTERFACE              
 The first statement of an interface block.  Interface blocks define
 explicit interfaces for external or dummy procedures.  They can
 also be used to define a generic name for procedures, a new
 operator for functions, and a new form of assignment for
 subroutines.  Format:

    INTERFACE [spec]
      [body]...
      [MODULE PROCEDURE nam]...
    END INTERFACE [spec]

    spec  Is one of the following:
          
          A generic name
         
          OPERATOR (op)
          
          The "op" is the defined unary, defined binary, 
          or extended intrinsic operator being defined.

          ASSIGNMENT (=)

          A "spec" can only be included in the END INTERFACE
          statement if one was provided in the INTERFACE
          statement; both "spec"s must be identical.

    body  Is one or more function or subroutine subprograms.  
          A function must end with END FUNCTION and a subroutine 
          must end with END SUBROUTINE.

          The subprogram must not contain a statement function 
          or a DATA, ENTRY or FORMAT statement; an entry name 
          can be used as a procedure name.

          The subprogram can contain a USE statement.

    nam   Is the name of one or more module procedures that 
          are accessible in the host. The MODULE PROCEDURE 
          statement is only allowed if the interface block 
          specifies a "spec" and has a host that is a module 
          (or accesses a module by use association).

          The characteristics of module procedures are not 
          given in interface blocks, but are assumed from
          the module subprogram definitions.  

 Interface blocks can appear in the specification part of the
 program unit that invokes the external or dummy procedure.

 The characteristics specified for the external or dummy procedure
 must be consistent with those specified in the procedure's
 definition.

 An interface block must not appear in a block data program unit.

 An interface block comprises its own scoping unit, and does not
 inherit anything from its host through host association.

 A procedure must not have more than one explicit interface in a
 given scoping unit.

 For more information see your language reference manual.

 EXAMPLES:

 The following example shows a simple procedure interface block with
 no generic specification:

   SUBROUTINE SUB_B (B, FB)
     REAL B
     ...
     INTERFACE 
       FUNCTION FB (GN)
         REAL FB, GN
       END FUNCTION 
     END INTERFACE
4 Generic_Names
 An interface block can be used to specify a generic name to
 reference all of the procedures within the interface block.
 Statement format for initial line in block:

    INTERFACE generic-name

 This kind of interface block can be used to extend or redefine a
 generic intrinsic procedure.

 The procedures that are given the generic name must be the same
 kind of subprogram:  all must be functions, or all must be
 subroutines.

 Any procedure reference involving a generic procedure name must be
 resolvable to one specific procedure; it must be unambiguous.

 EXAMPLES:

   INTERFACE GROUP_SUBS
     SUBROUTINE INTEGER_SUB (A, B)
       INTEGER, INTENT(INOUT) :: A, B
     END SUBROUTINE INTEGER_SUB
   
     SUBROUTINE REAL_SUB (A, B)
       REAL, INTENT(INOUT) :: A, B
     END SUBROUTINE REAL_SUB

     SUBROUTINE COMPLEX_SUB (A, B)
       COMPLEX, INTENT(INOUT) :: A, B
     END SUBROUTINE COMPLEX_SUB
   END INTERFACE 

 The three subroutines can be referenced by their individual
 specific names or by the group name GROUP_SUBS.

 The following example shows a reference to INTEGER_SUB:

 INTEGER V1, V2
 CALL GROUP_SUBS (V1, V2)
4 Generic_Operators
 An interface block can be used to define a generic operator.  The
 only procedures allowed in the interface block are functions that
 can be referenced as defined operations.  Statement format for
 initial line in block:

    INTERFACE OPERATOR (op)
    
    op  Is one of the following:
   
        A defined unary  operator (one argument) 

        A defined binary  operator (two arguments)

        An extended intrinsic operator (number of arguments 
              must be consistent with the intrinsic uses of 
              that operator)

 The functions within the interface block must have one or two
 nonoptional arguments with intent IN, and the function result must
 not be of type character with assumed length.  A defined operation
 is treated as a reference to the function.

 EXAMPLES:

   INTERFACE OPERATOR(.BAR.)
     FUNCTION BAR(A_1)
       INTEGER, INTENT(IN) :: A_1
       INTEGER :: BAR
     END FUNCTION BAR
   END INTERFACE

 The following example shows a way to reference function BAR by
 using the new operator:

   INTEGER B
   I = 4 + (.BAR. B)

 The following is an example of a procedure interface block with a
 defined operator extending an existing operator:

   INTERFACE OPERATOR(+)
     FUNCTION LGFUNC (A, B)
     LOGICAL, INTENT(IN) :: A(:), B(SIZE(A))
     LOGICAL :: LGFUNC(SIZE(A))
     END FUNCTION LGFUNC
   END INTERFACE

 The following example shows two equivalent ways to reference
 function LGFUNC:

   LOGICAL, DIMENSION(1:10) :: C, D, E
   N = 10
   E = LGFUNC(C(1:N), D(1:N))
   E = C(1:N) + D(1:N) 
4 Generic_Assignment
 An interface block can be used to define generic assignment.  The
 only procedures allowed in the interface block are subroutines that
 can be referenced as defined assignments.  Statement format for
 initial line in block:

    INTERFACE ASSIGNMENT(=)

 The subroutines within the interface block must have two
 nonoptional arguments, the first with intent OUT or INOUT, and the
 second with intent IN.

 A defined assignment is treated as a reference to a subroutine.
 The left side of the assignment corresponds to the first dummy
 argument of the subroutine; the right side of the assignment
 corresponds to the second argument.

 The ASSIGNMENT keyword extends or redefines an assignment operation
 if both sides of the equal sign are of the same derived type.

 Any procedure reference involving generic assignment must be
 resolvable to one specific procedure; it must be unambiguous.

 EXAMPLES:

   INTERFACE ASSIGNMENT (=)
     SUBROUTINE BIT_TO_NUMERIC (NUM, BIT)
     INTEGER, INTENT(OUT) :: NUM
     LOGICAL, INTENT(IN)  :: BIT(:)
     END SUBROUTINE BIT_TO_NUMERIC

     SUBROUTINE CHAR_TO_STRING (STR, CHAR)
     USE STRING_MODULE                    ! Contains definition 
                                          !   of type STRING
     TYPE(STRING), INTENT(OUT) :: STR     ! A variable-length string
     CHARACTER(*), INTENT(IN)  :: CHAR
     END SUBROUTINE  CHAR_TO_STRING
   END  INTERFACE

 The following example shows two equivalent ways to reference
 subroutine BIT_TO_NUMERIC:

   CALL BIT_TO_NUMERIC(X, (NUM(I:J)))
   X = NUM(I:J)

 The following example shows two equivalent ways to reference
 subroutine CHAR_TO_STRING:

   CALL CHAR_TO_STRING(CH, '432C')
   CH = '432C'
3 INTRINSIC               
 Allows the specific name of an intrinsic procedure to be used as an
 actual argument.  (Not all specific names can be used as actual
 arguments.  For more information, see your language reference
 manual.)

 The INTRINSIC attribute can be specified in a type declaration
 statement or an INTRINSIC statement, and takes one of the following
 forms:

 Type Declaration Statement:

  type, [att-ls,] INTRINSIC [,att-ls] :: v[,v]...

 Statement:

  INTRINSIC v [,v]...

    type      Is a data type specifier.

    att-ls    Is an optional list of attribute specifiers.

    v         Is the symbolic name of an intrinsic subprogram.

 Subprogram names passed as actual arguments must be identified in
 INTRINSIC statements.  Names of subprograms used as the objects of
 CALL statements or function references do not need to be identified
 by means of INTRINSIC statements; these names are recognized as
 intrinsic implicitly.

 The INTRINSIC attribute is compatible with the PRIVATE and PUBLIC
 attributes.
3 MAP                     
 See STATEMENTS STRUCTURE in this Help file.
3 MODULE                  
 A program unit containing specifications and definitions that can
 be made accessible to other program units.  Format:

    MODULE nam
       [specs]
    [CONTAINS
       mod-sub
       [mod-sub]...]
    END [MODULE [nam]]

    nam      Is the name of the module.

    specs    Is one or more specification statements, 
             except for the following:

             ENTRY 
             FORMAT 
             AUTOMATIC (or its equivalent attribute)
             INTENT (or its equivalent attribute)
             OPTIONAL (or its equivalent attribute)
             Statement functions

             An automatic object must not appear in a 
             specification statement.

    mod-sub  Is a function or subroutine subprogram that 
             defines the the module procedure.  A function 
             must end with END FUNCTION and a subroutine 
             must end with END SUBROUTINE.

             A module subprogram can contain internal 
             procedures.

 If a module name appears following the END statement, it must be
 the same name as the name specified in the MODULE statement.

 The module name cannot be the same as any local name in the main
 program or the name of any other program unit, external procedure,
 or common block in the executable program.

 A module is host to any module procedures it contains, and entities
 in the module are accessible to the module procedures through host
 association.

 A module must not reference itself (either directly or indirectly).

 Although ENTRY statements, FORMAT statements, and statement
 functions are not allowed in the specification part of a module,
 they are allowed in the specification part of a module subprogram.

 Any executable statements in a module can only be specified in a
 module subprogram.

 A module can contain one or more procedure interface blocks, which
 let you specify an explicit interface for an external subprogram or
 dummy subprogram.

 EXAMPLES:

 The following example shows a simple module that can be used to
 provide global data:

   MODULE MOD_A
     INTEGER :: B, C
     REAL E(25,5)
   END MODULE MOD_A
   ...
   SUBROUTINE SUB_Z
     USE MOD_A               ! Makes scalar variables B and C, 
                             ! and array E available to this 
                             ! subroutine
   END SUBROUTINE SUB_Z

 The following example shows a module procedure:

   MODULE RESULTS
   ...
   CONTAINS
     FUNCTION MOD_RESULTS(X,Y)  ! A module procedure
     ...
     END FUNCTION MOD_RESULTS
   END MODULE RESULTS

 The following example shows a module containing a derived type:

   MODULE EMPLOYEE_DATA
     TYPE EMPLOYEE
       INTEGER ID
       CHARACTER(LEN=40) NAME
     END TYPE EMPLOYEE
   END MODULE

 The following example shows a module containing an interface block:

   MODULE ARRAY_CALCULATOR
     INTERFACE
       FUNCTION CALC_AVERAGE(D)
         REAL :: CALC_AVERAGE
         REAL, INTENT(IN) :: D(:)
       END FUNCTION
     END INTERFACE
   END MODULE ARRAY_CALCULATOR
3 MODULE_PROCEDURE       
 See STATEMENTS INTERFACE in this Help file.
3 NAMELIST                
 Defines a list of variables or array names and associates that list
 with a unique group-name, which is used in the namelist I/O
 statement.

    NAMELIST /group/nlist[[,]/group/nlist]...

    group  Is the name of the group.

    nlist  Is the list of (no more than 250) variable 
           names, separated by commas, that are to be 
           associated with the preceding group.

 Dummy arguments can appear in a namelist.

 The following variables cannot appear in a namelist group:

  o  An array dummy argument with nonconstant bounds

  o  A variable with assumed character length

  o  An allocatable array

  o  An automatic object

  o  A Fortran 90 pointer

  o  A variable of a type that has a pointer as an ultimate
     component

  o  A subobject of any of the above objects


 You can use namelist I/O to assign values to elements of arrays or
 substrings of character variables that appear in namelists.

 The namelist entities can have any data type and can be explicitly
 or implicitly typed.

 Only the entities specified in the namelist can be read or written
 in namelist I/O.  It is not necessary for the input records in a
 namelist input statement to define every entity in the associated
 namelist.

 The order of entities in the namelist controls the order in which
 the values are written in the namelist output.  Input of namelist
 values can be in any order.

 A variable can appear in several namelists.
3 NULLIFY                 
 Disassociates a pointer from its target.  It takes the following
 form:

    NULLIFY (ptr-obj [,ptr-obj]...)

    ptr-obj  Is a structure component or the name of a 
             variable; it must be a pointer (have the 
             POINTER attribute).

 The initial association status of a pointer is undefined.  You can
 use NULLIFY to initialize an undefined pointer, giving it
 disassociated status.  Then the pointer can be tested using the
 intrinsic function ASSOCIATED.

 EXAMPLES:

    REAL, TARGET  :: TAR(0:50)
    REAL, POINTER :: PTR_A(:), PTR_B(:)
    PTR_A => TAR
    PTR_B => TAR
    ...
    NULLIFY(PTR_A)

 After these statements are executed, PTR_A will have disassociated
 status, while PTR_B will continue to be associated with variable
 TAR.
3 OPEN                    
 Opens an existing file or creates a new file.  If you do not
 explicitly open a file before accessing it, the file is created
 (for write operations) or opened with default attributes.

    OPEN (par[,par]...)

    par  Is a keyword specification in one of the 
         following forms:

         keywd
         keywd=value

         keywd  Is a keyword.  (See the subtopic headings
                listed at the end of this Help topic.)
         value  Is a keyword value. (Some keywords do not
                have keyword values.)

 If an OPEN statement is executed for a unit that is already open,
 and the file pathname (or specification) is different from that of
 the current open file, the previously opened file is closed and the
 new file is opened.  If the file pathname (or specification) is the
 same for both files, the new value of the BLANK= specifier is in
 effect, but the position of the file is unaffected.

 Keyword specifications can appear in any order.  In most cases,
 they are optional.  Default values apply in their absence.  If the
 logical unit specifier is the first parameter in the list, the UNIT
 keyword is optional.

 You can specify character values at run time by substituting a
 general character expression for a keyword value in the OPEN
 statement.  The character value can contain trailing spaces but not
 leading or embedded spaces; for example:

    CHARACTER*6 FINAL /' '/
    ...
    IF (exp) FINAL = 'DELETE'
    OPEN (UNIT=1, STATUS='NEW', DISP=FINAL)

                                NOTE

         Keyword values that are numeric expressions can  be
         any  integer  or real expression.  The value of the
         expression is converted to integer data type before
         it is used in the OPEN statement.

4 ACCESS           
 Indicates the access method for the connection of the file.  It
 takes the following form:

 ACCESS = acc

 acc  Is a character expression with one of the following 
      values:

 'DIRECT'           Access by record number
 'SEQUENTIAL'       Access sequentially (the default)
 'KEYED' (VMS only) Access by a specified key
 'APPEND'           Access sequentially, after the last record 
                     of the file

 On DIGITAL UNIX systems, there may be limitations on record access
 by file organization and record type (see your user manual).
4 ACTION     
 Indicates the allowed I/O operations for the file connection.  It
 takes the following form:

 ACTION = act

 act  Is a character expression with one of the 
      following values:

 'READ'      Indicates that only READ statements can refer to 
             this connection.
 'WRITE'     Indicates that only WRITE, DELETE, and ENDFILE 
             statements can refer to this connection.
 'READWRITE' Indicates that READ, WRITE, DELETE, and ENDFILE 
             statements can refer to this connection (*DEFAULT*)
4 ASSOCIATEVARIABLE
 Indicates a variable that is updated after each direct access I/O
 operation, to reflect the record number of the next sequential
 record in the file.  It takes the following form:

 ASSOCIATEVARIABLE = asv

 asv  Is an integer variable.  It cannot be a dummy argument
      to the routine in which the OPEN statement appears.
      Use only in direct access mode.  

                                NOTE

         Direct access  READ,  direct  access  WRITE,  FIND,
         DELETE, and REWRITE statements can affect the value
         of the variable.

4 BLANK            
 Indicates how blanks are interpreted in a file.  It takes the
 following form:

 BLANK = blnk

 blnk  Is a character expression with one of the following 
       values:

 'NULL'  Ignore all blanks in a numeric field (unless the field 
         is all blanks, in which case treat blanks as zero).
 'ZERO'  Treat all blanks other than leading blanks as zeros.

 The default is 'NULL' (for explicitly OPENed files, preconnected
 files, and internal files).

 If the BN or BZ edit descriptors are specified for a formatted
 input statement, they supersede the default interpretation of
 blanks.
4 BLOCKSIZE        
 Indicates the physical I/O transfer size for the file.  It takes
 the following form:

 BLOCKSIZE = bks

   bks  Is a numeric expression.

 If you specify a BLOCKSIZE number, it is rounded up to a multiple
 of 512 byte blocks.

 If you do not specify BLOCKSIZE or you specify zero, the filesystem
 default is assumed.
4 BUFFERCOUNT      
 Indicates the number of buffers to be associated with the logical
 unit for multibuffered I/O.  It takes the following form:

 BUFFERCOUNT = bc

 bc  Is a numeric expression.

 The range of values for "bc" is 1 to 127.

 The BLOCKSIZE keyword determines the size of each buffer.  Thus, if
 BUFFERCOUNT=3 and BLOCKSIZE=2048, the total number of bytes
 allocated for buffers is 3*2048, or 6144.

 If you do not specify BUFFERCOUNT or you specify zero, the default
 is 1.
4 CARRIAGECONTROL  
 Indicates the type of carriage control used when a file is
 displayed at a terminal.  It takes the following form:

 CARRIAGECONTROL = cc

 cc  Is a character expression with one of the following 
     values:

 'FORTRAN'   Process with normal FORTRAN interpretation of
             the first character
 'LIST'      Process with single spacing between records
 'NONE'      Do not use implied carriage control

 The default for unformatted files is 'NONE'.  The default for
 formatted files is 'LIST'.  However, if you specify the -vms
 compiler option, and the unit is connected to a terminal, the
 default is 'FORTRAN'.
4 CONVERT          
 Indicates a nonnative numeric format for unformatted data.  It
 takes the following form:

 CONVERT = fm

 fm  Is a character expression with one of the following 
     options:

    'LITTLE_ENDIAN'- Little endian integer data of the 
                     appropriate size (INTEGER*1, INTEGER*2, 
                     INTEGER*4, or INTEGER*8) and IEEE 
                     floating-point data of the appropriate size 
                     and type (REAL*4, REAL*8, REAL*16, COMPLEX*8, 
                     or COMPLEX*16).  INTEGER*1 data is the same 
                     for little endian and big endian.

    'BIG_ENDIAN' -   Big endian integer data of the appropriate
                     size (INTEGER*1, INTEGER*2, INTEGER*4, or
                     INTEGER*8) and IEEE floating-point data of 
                     the appropriate size and type (REAL*4, REAL*8, 
                     REAL*16, COMPLEX*8, or COMPLEX*16).  INTEGER*1 
                     data is the same for little endian and big 
                     endian.

    'CRAY' -         Big endian integer data of the appropriate
                     size (INTEGER*1, INTEGER*2, INTEGER*4, or
                     INTEGER*8) and CRAY floating-point data of 
                     size REAL*8 or COMPLEX*16.

    'FDX' -          Little endian integer data of the appropriate
                     size (INTEGER*1, INTEGER*2, INTEGER*4, or
                     INTEGER*8) and DIGITAL VAX floating-point data
                     of format F_floating for REAL*4 or COMPLEX*8,
                     D_floating for size REAL*8 or COMPLEX*16, and
                     IEEE X_floating for REAL*16.

    'FGX' -          Little endian integer data of the appropriate
                     size (INTEGER*1, INTEGER*2, INTEGER*4, or
                     INTEGER*8) and DIGITAL VAX floating-point data
                     of format F_floating for REAL*4 or COMPLEX*8,
                     G_floating for size REAL*8 or COMPLEX*16, and
                     IEEE X_floating for REAL*16.

    'IBM' -          Big endian integer data of the appropriate
                     size (INTEGER*1, INTEGER*2, INTEGER*4, or
                     INTEGER*8) and IBM System\370 floating-point
                     data of size REAL*4 or COMPLEX*8 (IBM
                     short 4) and size REAL*8 or COMPLEX*16 (IBM
                     long 8).

    'VAXD' -         Little endian integer data of the appropriate
                     size (INTEGER*1, INTEGER*2, INTEGER*4, or
                     INTEGER*8) and DIGITAL VAX floating-point 
                     data of format F_floating for size
                     REAL*4 or COMPLEX*8, D_floating for size
                     REAL*8 or COMPLEX*16, and H_floating for
                     REAL*16.

    'VAXG' -         Little endian integer data of the appropriate
                     size (INTEGER*1, INTEGER*2, INTEGER*4, or
                     INTEGER*8) and DIGITAL VAX floating-point 
                     data of format F_floating for size
                     REAL*4 or COMPLEX*8, G_floating for size 
                     REAL*8 or COMPLEX*16, and H_floating for
                     REAL*16.
     
    'NATIVE' -       No data conversion.  This is the default.

 You can use CONVERT to specify multiple formats in a single
 program, usually one format for each specified unit number.

 When reading a non-native format, the non-native format on disk is
 converted to native format in memory.  If a converted non-native
 value is outside the range of the native data type, a run-time
 message appears.

 There are other ways to specify numeric format for unformatted
 files:  you can specify U*X environment variable or the compiler
 option -convert (or OPTIONS/CONVERT).  The order of precedence is
 U*X environment variable, OPEN (CONVERT=), OPTIONS/CONVERT, and
 then compiler option -convert.  The -convert compiler option and
 OPTIONS/CONVERT affect all unit numbers used by the program, while
 environmental variables and OPEN (CONVERT=) affect specific unit
 numbers.

 The following source code shows how to code the OPEN statement to
 read unformatted CRAY numeric data from unit 15, which might be
 processed and possibly written in little endian format to unit 20:

    OPEN (CONVERT='CRAY', FILE='graph3.dat', FORM='UNFORMATTED', 
   1     UNIT=15)
    ...
    OPEN (FILE='graph3_native.dat', FORM='UNFORMATTED', UNIT=20)
4 DEFAULTFILE      
 Indicates a default file pathname string.  It takes the following
 form:

 DEFAULTFILE = ce

 ce  Is a character expression.

 This specifier supplies a value to the Fortran I/O system that is
 prefixed to the FILE keyword parameter.

 The default file pathname string is used primarily when accepting
 file pathnames interactively.  File pathnames known to a user
 program are normally completely specified in the FILE keyword.

 If the DEFAULTFILE keyword value does not end in a slash (/), then
 one is added.

 If the DEFAULTFILE keyword is not supplied in the OPEN statement,
 the Fortran I/O system uses the current working directory.

 The following example opens the existing file
 /usr/users/someone/test.dat:

    OPEN (unit=10, DEFAULTFILE='/usr/users/someone/', 
   1     FILE='test.dat', FORM='FORMATTED', HISTORY='OLD')
4 DELIM            
 Indicates what characters (if any) are used to delimit character
 constants in list-directed and namelist output.  It takes the
 following form:

 DELIM = del

 del  Is a character expression with one of the 
      following values:

 'APOSTROPHE'  Indicates that apostrophes delimit character 
               constants. All internal apostrophes are doubled.

 'QUOTE'       Indicates that quotation marks delimit character 
               constants.  All internal quotation marks are doubled.

 'NONE'        Indicates that character constants have no 
               delimiters.  No internal apostrophes or quotation 
               marks are doubled. This is the default.

 DELIM is only allowed for files connected for formatted data
 transfer; it is ignored during input.
4 DISPOSE          
 Indicates the status of the file after the unit is closed.  It
 takes one of the following forms:

 DISP = dis
 DISPOSE = dis  

 dis  Is a character expression with one of the following 
      values:

 'KEEP' or 'SAVE'  Retain the file after the unit is closed.
                   (*DEFAULT FOR ALL BUT SCRATCH FILES*)

 'DELETE'          Delete the file after the unit is closed.
                   (*DEFAULT FOR SCRATCH FILES*)

 'PRINT'           Submit the file as a print job and retain it.
                   Use this value only with sequential files.

 'PRINT/DELETE'    Submit the file as a print job and then 
                   delete it.  Use this value only with sequential 
                   files.

 'SUBMIT'          Fork a process to execute the file.

 'SUBMIT/DELETE'   Fork a process to execute the file, and 
                   delete the file after the fork is completed.

 The disposition specified in a CLOSE statement supersedes the
 disposition specified in the OPEN statement, except that a file
 opened as a scratch file cannot be saved, printed, or submitted,
 nor can a file opened for read-only access be deleted.
4 ERR              
 Identifies a branch target statement that receives control if an
 error occurs.  It takes the following form:

 ERR = s

 s  Is the label of an executable statement 

 ERR applies only to the OPEN statement in which it is specified,
 and not in subsequent I/O operations on the unit.  If an error
 occurs, no file is opened or created.  However, you can use IOSTAT
 in subsequent I/O statements to perform a similar function.
4 EXTENDSIZE (VMS only)
 Indicates the number of blocks by which to extend a disk file
 (extent) when additional storage space is needed.  It takes the
 following form:

 EXTENDSIZE = e

    e  Is a numeric expression.

 The space used to extend a file is contiguous if possible.
 Otherwise, noncontiguous space is used.  The default is the system
 default for the device.
4 FILE             
 Indicates the name of the file to be connected to the unit.  It
 takes the following form:

 FILE = name

 name   Is a character or numeric expression.

 The "name" can be any pathname (or specification) allowed by the
 operating system.  (See the appropriate manual in your operating
 system documentation set.)

 Any training blanks in the name are ignored.

 If FILE is omitted and the unit is not connected to a file, the
 OPEN statement must specify STATUS='SCRATCH'.

 If the file name is stored in a numeric scalar or array, the name
 must consist of ASCII characters terminated by an ASCII null
 character (zero byte).  However, if it is stored in a character
 scalar or array, it must not contain a zero byte.
4 FORM             
 Indicates whether the file is being connected for formatted,
 unformatted, or binary data transfer.  It takes the following form:

 FORM = ft

 ft  Is a character expression with one of the following 
     values:

   'FORMATTED'         Formatted *DEFAULT FOR SEQUENTIAL ACCESS*
   'UNFORMATTED'       Unformatted *DEFAULT FOR KEYED (VMS only) 
                         AND DIRECT ACCESS*
   'BINARY' (WNT,W95)  Binary 
4 INITIALSIZE(VMS only)
 Indicates the number of blocks in the initial storage allocation
 (extent) for a disk file.  It takes the following form:

 INITIALSIZE = e

    e  Is a numeric expression.  

 If you do not specify INITIALSIZE or if you specify zero, no
 initial allocation is made.  The system attempts to allocate
 contiguous space for INITIALSIZE.  If not enough contiguous space
 is available, noncontiguous space is allocated.
4 IOFOCUS (WNT,W95)  
 Indicates whether a particular unit is the active window in a
 QuickWin application.  It takes the following form:

 IOFOCUS = iof

 iof   Is a scalar default logical expression with
       one of the following values:

    .TRUE.    Indicates the QuickWin window is the active 
              window
    .FALSE.   Indicates the QuickWin window is not the active 
              window

 If unit '*' is specified, the default is .FALSE; otherwise, the
 default is .TRUE..

 A value of .TRUE.  causes a call to SETFOCUSQQ immediately before
 any READ, WRITE, or PRINT statement to that window.
4 IOSTAT           
 Designates a variable to store a value indicating the status of a
 data transfer operation.  It takes the following form:

 IOSTAT = ios

 ios   Is a scalar default integer variable.

 If no error exists, "ios" is defined as zero.  If an error exists,
 "ios" is defined as a positive integer.

 IOSTAT applies only to the OPEN statement in which it appears and
 not to subsequent I/O operations on the logical unit that is
 opened.  However, you can use the IOSTAT parameter in subsequent
 I/O statements to perform a similar function.
4 KEY (VMS only)  
 Defines the access keys for records in an indexed file.  It takes
 the following form:

 KEY = (kspec[,kspec]...)

 kspec   Takes the following form:

         e1:e2[:dt[:dr]]

         e1   Is the position of the first byte of the 
              key in the record.
         e2   Is the position of the last byte of the 
              key in the record.
         dt   Is the data type of the key: CHARACTER (*DEFAULT*)
              or INTEGER.
         dr   Is the direction of the key: ASCENDING (*DEFAULT*)
              or DESCENDING.

 The length of the key must not exceed 255 bytes.  The first byte
 position of the key must be at least 1 and the last byte position
 must not exceed the length of the record.

 If the key type is INTEGER, the key length must be either 2 or 4.

 Defining Primary and Alternate Keys:

 You must define at least one key in an indexed file.  This is the
 primary key (the default key).  It usually has a unique value for
 each record.

 You can also define alternate keys.  RMS allows up to 254 alternate
 keys.

 If a file requires more keys than the OPEN statement limit, you
 must create it from another language or with the File Definition
 Language (FDL).

 Specifying and Referencing Keys:

 You must specify the KEY parameter when creating an indexed file.
 However, you do not have to respecify it when opening an existing
 file because key attributes are permanent aspects of the file.
 These attributes include key definitions and reference numbers for
 subsequent I/O operations.

 However, if you use the KEY parameter for an existing file, your
 specification must be identical to the established key attributes.

 Subsequent I/O operations use a reference number, called the
 key-of-reference number, to identify a particular key.  You do not
 specify this number; it is determined by the key's position in the
 specification list:  the primary key is key-of-reference number 0;
 the first alternate key is key-of-reference number 1, and so forth.
4 MAXREC           
 Indicates the maximum number of records that can be transferred
 from or to a direct access file while the file is connected.  It
 takes the following form:

 MAXREC = mr

 mr  Is an numeric expression.

 The default is an unlimited number of records.
4 MODE (WNT,W95)  
 MODE is a nonstandard synonym for ACTION.  (See OPEN ACTION.)
4 NAME             
 NAME is a nonstandard synonym for FILE.  (See OPEN FILE.)
4 NOSPANBLOCKS(VMS only)
 NOSPANBLOCKS

 Specifies that records are not to cross disk block boundaries.  If
 a record exceeds the size of a physical block, an error occurs.
4 ORGANIZATION     
 Indicates the internal organization of the file.  It takes the
 following form:

 ORGANIZATION = org

 org  Is a character expression with one of the following 
      values:

 'SEQUENTIAL'          Records are stored in the order that 
                       they are written. Access mode must be 
                       sequential, append, or direct (fixed-length 
                       records only). (*DEFAULT FOR NEW FILES*)

 'RELATIVE'            Records are stored in numbered positions. 
                       Access mode must be direct or sequential.

 'INDEXED'(VMS only)   Records are stored according to the values 
                       of their keys. Access mode must be indexed 
                       or sequential.

 The default for an existing file is its current organization.
4 PAD              
 Indicates whether a formatted input record is padded with blanks
 when an input list and format specification requires more data than
 the record contains.  It takes the following form:

 PAD = pd

 pd   Is a character expression with one of the 
      following values:

 'YES'  Indicates the record will be padded with blanks 
        when necessary (the default).

 'NO'   Indicates the record will not be padded with blanks.  
        The input record must contain the data required by 
        the input list and format specification.

 This behavior is different from FORTRAN 77, which never pads short
 records with blanks.  For example, consider the following:

   READ (5,'(I5)') J

 If you enter 123 followed by a carriage return, FORTRAN 77 will
 turn the I5 into an I3 and J will be assigned 123.

 However, DIGITAL Fortran pads the 123 with 2 blanks unless you
 explicitly open the unit with PAD='NO'.

 You can override blank padding by explicitly specifying the BN edit
 descriptor.

 The PAD specifier is ignored during output.
4 POSITION         
 Indicates the position of a file connected for sequential access.
 It takes the following form:

 POSITION = pos

 pos   Is a character expression with one of the 
       following values:

 'ASIS'   Indicates the file position is unchanged if the file 
          exists and is already connected.  The position is 
          unspecified if the file exists but is not connected.
          This is the default.

 'REWIND' Indicates the file is positioned at its initial point.

 'APPEND' Indicates the file is positioned at its terminal point 
          (or before its end-of-file record, if any).)

 A new file (whether specified as new explicitly or by default) is
 always positioned at its initial point.
4 READONLY         
 READONLY

 Prohibits WRITE access to the file.  Enables users with READ access
 to access the file.

 READONLY is similar to specifying ACTION='READ', but READONLY
 prevents deletion of the file if it is closed with STATUS='DELETE'
 in effect.

 Default file access privileges are READWRITE.  If access is denied,
 the I/O system automatically retries accessing the file for READ
 access.

 However, if you use the compiler option -vms, the I/O system does
 not retry accessing for READ access.  So, run-time I/O errors can
 occur if the file protection does not permit WRITE access.  To
 prevent such errors, if you wish to read a file for which you do
 not have write access, specify READONLY.
4 RECL             
 Indicates the length of logical records in a file connected for
 direct access, or the maximum length of a record in a file
 connected for sequential access.  It takes the following form:

 RECL = rl

 rl  Is an numeric expression.  If necessary, the value is
     converted to integer data type before use.

 If the file is connected for formatted data transfer, the value
 must be expressed in bytes (characters).  Otherwise, the value is
 expressed in 4-byte units (longwords).  If the file is connected
 for unformatted data transfer, the value can be expressed in bytes
 if the appropriate compiler option is specified.

 Except for segmented records, the "rl" is the length for record
 data only, it does not include space for control information.

 The length specified is interpreted depending on the type of
 records in the connected file, as follows:

  o  For segmented records, RECL indicates the maximum length for
     any segment (including the four bytes of control information).

  o  For fixed-length records, RECL indicates the size of each
     record; it must be specified.  If the records are unformatted,
     the size must be expressed as an even multiple of four.

     You can use the RECL specifier in an INQUIRE statement to get
     the record length before opening the file.

  o  For variable-length records, RECL indicates the maximum length
     for any record.


 If you read a fixed-length file with a record length different from
 the one used to create the file, indeterminate results can occur.

 The maximum length for "rl" depends on the record type and the
 setting of the CARRIAGECONTROL specifier, as shown in the following
 table:

 Record Type     CARRIAGECONTROL   Formatted Size in bytes

 Fixed-length    'NONE'            2147483647 (2**31-1) 
                                     (*see Note 1 below*)
 Variable-length 'NONE'            2147483640 (2**31-8)
 Segmented       'NONE'            32764 (2**15-4)
 Stream          'NONE'            2147483647 (2**31-1)
 Stream_CR       'LIST'            2147483647 (2**31-1)
                 'FORTRAN'         2147483646 (2**31-2)
 Stream_LF       'LIST'            2147483647 (2**31-1) 
                 'FORTRAN'         2147483646 (2**31-2)

 Note 1: Subtract 1 if the compiler option -vms is used.

 The default value depends on the setting of the RECORDTYPE
 specifier, as shown in the following table:

 RECORDTYPE          RECL value

 'FIXED'             None; value must be explicitly specified.
 All other settings  132 bytes for formatted records;
                     510 longwords for unformatted records.
4 RECORDSIZE       
 RECORDSIZE is the nonstandard synonym for RECL (see OPEN RECL).
4 RECORDTYPE       
 Indicates the type of records in a file.  It takes the following
 form:

 RECORDTYPE = typ

 typ  Is a character expression with one of the following 
      values:

 'FIXED'      All records are one size. Short records are padded
              with blanks (formatted files) or zeros (unformatted
              files). 
 'VARIABLE'   Records can vary in length. 
 'SEGMENTED'  A record consists of one or more variable length
              records which may exist in different physical blocks. 
              Valid only for unformatted, sequential files with 
              sequential access. 
 'STREAM'     Data is not grouped into records and contains no
              control information.
 'STREAM_CR'  Variable-length records whose length is indicated by
              carriage-returns embedded in the data.
 'STREAM_LF'  Variable-length records whose length is indicated by
              line-feeds (new lines) embedded in the data.

 When you open a file, default record types are as follows:

 +-------------------------------------+---------------------+
 | File Type                           | Default Record Type |
 +-------------------------------------+---------------------+
 | Relative files                      | 'FIXED'             |
 | Direct access sequential files      | 'FIXED'             |
 | Formatted sequential access files   | 'STREAM_LF'         |
 | Unformatted sequential access files | 'VARIABLE'          | 
 +-------------------------------------+---------------------+

 A segmented record is a logical record consisting of segments that
 are physical records.  Since the length of a segmented record can
 be greater than 65,535 bytes, only use segmented records for
 unformatted sequential access to disk or raw magnetic tape files.

 Files containing segmented records can be accessed only by
 unformatted sequential data transfer statements.  You cannot use an
 unformatted READ statement to access such a file, unless you
 specify RECORDTYPE='VARIABLE' in your OPEN statement.

 If an output statement does not specify a full record for a file
 containing fixed-length records, the following occurs:

  o  In formatted files, the record is filled with blanks

  o  In unformatted files, the record is filled with zeros

4 SHARE (WNT,W95)  
 Indicates whether file locking is implemented while the unit is
 open.  It takes the following form:

 SHARE = shr

 shr  Is a scalar default character expression that 
      evaluates to one of the following values:

 'DENYRW'      Indicates deny-read/write mode. No other process 
               can open the file.
 'DENYWR'      Indicates deny-write mode.  No process can open 
               the file with write access.
 'DENYRD'      Indicates deny-read mode.  No process can open 
               the file with read access.
 'DENYNONE'    Indicates deny-none mode.  Any process can open 
               the file in any mode. (*DEFAULT*)
4 SHARED           
 SHARED

 Specifies that the file can be accessed by more than one user at
 the same time.

 Shared access is the default for the Fortran I/O system.
4 STATUS           
 Indicates the status of a file when it is opened.  It takes the
 following form:

 STATUS = sta

 sta  Is a character expression with one of the following 
      values:

 'OLD'       Open an existing file.

 'NEW'       Create a new file; if the file already exists an
             error occurs.

 'SCRATCH'   Create a new file and delete it when the file is 
             closed.

 'REPLACE'   Replace the file with another. If the file to be 
             replaced exists, it is deleted and a new file is 
             created with the same name.  If the file to be replaced 
             does not exist, a new file is created and its status 
             changes to 'OLD'.

 'UNKNOWN'   Open the file as OLD; if it does not exist, then 
             open the file as NEW.

 Scratch files go into a temporary directory and are visible while
 they are open.  (For more information, see your user manual.)

 The default is 'UNKNOWN'.  This is also the default if you
 implicitly open a file by using WRITE.  However, if you implicitly
 open a file using READ, the default is 'OLD'.  If you specify the
 compiler option -f66 (or OPTIONS /NOF77), the default is 'NEW'.

                                NOTE

         The  STATUS  parameter  is  also  used   in   CLOSE
         statements  to  specify  the status of a file after
         the file is closed.  However, in  CLOSE  statements
         the  STATUS values are the same as those listed for
         the DISPOSE specifier (see OPEN DISPOSE).

4 TITLE (WNT,W95)  
 Indicates the name of a child window in a QuickWin application.  It
 takes the following form:

 TITLE = name

 name  Is a character expression.

 If TITLE is specified in a non-QuickWin application, an error
 occurs.
4 TYPE             
 TYPE is a nonstandard synonym for STATUS (see OPEN STATUS).
4 UNIT             
 Indicates the logical unit to which a file is to be connected.  It
 takes the following form:

 [UNIT=] u

 u  Is a numeric expression 

 The unit specification must appear in the parameter list, unless
 the unit specifier is the first element in the list.

 The logical unit may already be connected to a file when an OPEN
 statement is executed.  If this file is not the same as the one to
 be opened, the OPEN statement executes as if a CLOSE statement had
 executed just before it.

 If the file to be opened is already connected to the unit or if the
 file specifier (FILE keyword) is not included in the OPEN
 statement, only the blank specifier (BLANK keyword) can have a
 value different from the one currently in effect.  The position of
 the file is unaffected.
4 USEROPEN         
 Indicates a user-written external function that controls the
 opening of the file.  It takes the following form:

 USEROPEN = func

 func  Is the symbolic name of the USEROPEN function.

 The function must be declared in a previous EXTERNAL statement; if
 it is typed, it must be INTEGER*4.
3 OPTIONAL                
 Permits dummy arguments to be omitted in a procedure reference.

 The OPTIONAL attribute can be specified in a type declaration
 statement or an OPTIONAL statement, and takes one of the following
 forms:

 Type Declaration Statement:

  type, [att-ls,] OPTIONAL [,att-ls] :: d-arg [,d-arg]...

 Statement:

  OPTIONAL [::] d-arg [,d-arg]...

    type      Is a data type specifier.

    att-ls    Is an optional list of attribute specifiers.

    d-arg     Is the name of a dummy argument.

 The OPTIONAL attribute can only appear in the scoping unit of a
 subprogram or an interface body, and can only be specified for
 dummy arguments.

 A dummy argument is "present"if it associated with an actual
 argument.  A dummy argument that is not optional must be present.
 You can use the PRESENT intrinsic function to determine whether an
 optional dummy argument is associated with an actual argument.

 To call a procedure that has an optional argument, you must use an
 explicit interface.

 The OPTIONAL attribute is compatible with the DIMENSION, EXTERNAL,
 INTENT, POINTER, TARGET, and VOLATILE attributes.

 EXAMPLES:

 The following example shows a type declaration statement specifying
 the OPTIONAL attribute:

   SUBROUTINE TEST(A)
   REAL, OPTIONAL, DIMENSION(-10:2) :: A
   END SUBROUTINE

 The following is an example of the OPTIONAL statement:

        SUBROUTINE TEST(A, B, L, X)
        OPTIONAL :: B
        INTEGER A, B, L, X

        IF (PRESENT(B)) THEN        ! Printing of B is conditional
           PRINT *, A, B, L, X      !   on its presence
        ELSE
           PRINT *, A, L, X
        ENDIF
        END SUBROUTINE

        INTERFACE
           SUBROUTINE TEST(ONE, TWO, THREE, FOUR)
            INTEGER ONE, TWO, THREE, FOUR
            OPTIONAL :: TWO
          END SUBROUTINE
        END INTERFACE

        INTEGER I, J, K, L

        I = 1
        J = 2
        K = 3
        L = 4

        CALL TEST(I, J, K, L)            ! Prints:  1  2  3  4
        CALL TEST(I, THREE=K, FOUR=L)    ! Prints:  1  3  4
        END

 Note that in the second call to subroutine TEST, the second
 positional (optional) argument is omitted.  In this case, all
 following arguments must be keyword arguments.
3 OPTIONS                 
 Overrides or confirms the compiler options in effect for a program
 unit.  Statement format:

    OPTIONS option [option...]

    option  Is one of the following:

    /ASSUME=[NO]UNDERSCORE

    /CHECK=(ALL, [NO]BOUNDS, [NO]OVERFLOW, [NO]UNDERFLOW, NONE)
    /NOCHECK

    /CONVERT=(BIG_ENDIAN, CRAY, FDX, FGX, IBM, LITTLE_ENDIAN, 
             NATIVE, VAXD, VAXG)

    /[NO]EXTEND_SOURCE
    /[NO]F77
    /FLOAT=(D_FLOAT (VMS only), G_FLOAT (VMS only), IEEE_FLOAT)
    /[NO]G_FLOATING (VMS only)
    /[NO]I4
    /[NO]RECURSIVE 

 You must place the slash (/) before the option.

 The OPTIONS statement must be the first statement in a program
 unit, preceding the PROGRAM, SUBROUTINE, FUNCTION, MODULE, and
 BLOCK DATA statements.

 OPTIONS statement options have the same syntax and abbreviations as
 their similarly-named VMS compiler options.

 OPTIONS statement options override compiler options, but only until
 the end of the program unit for which they are defined.  Thus, an
 OPTIONS statement must appear before each program unit in which you
 wish to override the compiler options.
3 PARAMETER               
 Associates a symbolic name with a constant value.

 The PARAMETER attribute can be specified in a type declaration
 statement or an PARAMETER statement, and takes one of the following
 forms:

 Type Declaration Statement:

  type, [att-ls,] PARAMETER [,att-ls] :: p=c [,p=c]...

 Statement:

  PARAMETER (p=c [,p=c]...)

    type      Is a data type specifier.

    att-ls    Is an optional list of attribute specifiers.

    p  Is the symbolic name of the constant.

    c  Is a constant, a compile-time expression, or the 
       symbolic name of a constant.

 If the symbolic name is used as the length specifier in a CHARACTER
 declaration, it must be enclosed in parentheses.

 If the symbolic name is used as a numeric item in a FORMAT edit
 description, it must be enclosed in angle brackets.

 The symbolic name of a constant cannot appear as part of another
 constant, although it can appear as either the real or imaginary
 part of a complex constant.

 A symbolic name can be defined only once within the same program
 unit.

 You can only use a symbolic name defined to be a constant within
 the program unit containing the defining PARAMETER statement.

 The data type of a symbolic name associated with a constant is
 determined as follows:

  -  By an explicit type declaration statement preceding the
     defining PARAMETER statement

  -  By the same rules for implicit declarations that determine the
     data type of any other symbolic name

     For example, the following PARAMETER statement is interpreted
     as MU=1 (MU has an integer data type by implication):

        PARAMETER (MU=1.23)

     If the PARAMETER statement is preceded by an appropriate type
     declaration or IMPLICIT statement, it could be interpreted as
     MU=1.23; for example:

        REAL*8 MU
        PARAMETER (MU=1.23)


 Once a symbolic name is associated with a constant, it can appear
 anywhere in a program that any other constant can appear --- except
 in FORMAT statements (where constants can only be used in variable
 format expressions) and as the character count for Hollerith
 constants.  For compilation purposes, writing the name is the same
 as writing the value.

 The PARAMETER attribute is compatible with the PRIVATE and PUBLIC
 attributes.

 For information on an alternate syntax for PARAMETER, see Help
 topic:  COMPATIBILITY_FEATURES PARAMETER.
3 PAUSE                   
 The PAUSE statement displays a message on the terminal and
 temporarily suspends program execution, so that you can take some
 action.  This statement is an obsolescent feature in Fortran 90,
 which is deleted in Fortran 95.  DIGITAL Fortran flags deleted and
 obsolescent features, but fully supports them.

 Statement format:

    PAUSE [disp]
  
    disp  Is an optional character constant or a string of 
          up to six digits.  (Fortran 90 and FORTRAN 77 limit 
          digits to five.)

 If you do not specify a value for "disp", the system displays the
 following default message:

    FORTRAN PAUSE

 The system then displays the system prompt.

 If you specify a value for "disp", this value is displayed instead
 of the default message.

 EFFECT OF PAUSE IN INTERACTIVE MODE:

 In interactive mode, the program is suspended until you enter one
 of the following commands:

  o  CONTINUE - to resume execution at the next executable
     statement.

  o  DEBUG - to resume execution under control of the VMS Debugger.

  o  EXIT - to terminate execution.

     Note that any command, other than CONTINUE or DEBUG, terminates
     execution.


 EFFECT OF PAUSE IN BATCH PROCESS MODE:

 If a program is a batch process, the program is not suspended.  If
 you specify a value for "disp", this value is written to the system
 output file.
3 POINTER                  
 Specifies that an object is a pointer.

 The POINTER attribute can be specified in a type declaration
 statement or an POINTER statement, and takes one of the following
 forms:

 Type Declaration Statement:

  type, [att-ls,] POINTER [,att-ls] :: ptr [(spec)] [,ptr [(spec)]]...

 Statement:

  POINTER [::] ptr [(spec)] [,ptr [(spec)]]...

    type      Is a data type specifier.

    att-ls    Is an optional list of attribute specifiers.

    ptr       Is the name of the pointer.  The pointer 
              cannot be declared with the INTENT or
              PARAMETER attributes.

    spec      Is a deferred-shape specification 
              (: [,:]...). 

 A pointer must not be referenced or defined unless it becomes
 pointer associated (through pointer assignment or an ALLOCATE
 statement) with a target object that can be referenced or defined.
 An object with the POINTER attribute has no initial storage set
 aside for it.

 If the pointer is an array, and it is given the DIMENSION attribute
 elsewhere in the program, it must be declared as a deferred-shape
 array.

 A pointer cannot be specified in an EQUIVALENCE or NAMELIST
 statement.

 The POINTER attribute is compatible with the AUTOMATIC, DIMENSION
 (with deferred shape), OPTIONAL, PRIVATE, PUBLIC, SAVE, STATIC, and
 VOLATILE attributes.

 EXAMPLES:

 The following example shows type declaration statements specifying
 the POINTER attribute:

    TYPE(SYSTEM), POINTER :: CURRENT, LAST
    REAL, DIMENSION(:,:), POINTER :: I, J, REVERSE

 The following is an example of the POINTER statement:

    TYPE(SYSTEM) :: TODAYS
    POINTER :: TODAYS, A(:,:)
3 PRINT                   
 Transfers output data from internal storage to external records
 that are sequentially accessed.
4 Formatted        
 Translates data from binary to character format as specified by f.
 Statement format:

    PRINT f[,iolist]

    f       Is a format specifier not prefaced by FMT=.

    iolist  Are the names of the variables from which the 
            data is transferred, listed in the order of transfer.
4 List-directed    
 Translates data from binary to character format according to the
 data types of the variables in the I/O list.  Statement format:

    PRINT *[,iolist]

    *       Specifies list-directed formatting.

    iolist  Are the names of the variables from which the data 
            is transferred, listed in the order of transfer.
4 Namelist
 Translates data from binary to character format according to the
 data types of the list entities in the corresponding NAMELIST
 statement.  Statement format:

    PRINT n

    n  Is a namelist group name not prefaced by NML=.
3 PRIVATE_and_PUBLIC    
 Specify the accessibility of entities in a module.  (These
 attributes are also called accessibility attributes.)

 The PRIVATE and PUBLIC attributes can be specified in a type
 declaration statement or in a PRIVATE or PUBLIC statement, and take
 one of the following forms:

 Type Declaration Statement:

  type, [att-ls,] PRIVATE [,att-ls] :: ent [,ent]...
  type, [att-ls,] PUBLIC  [,att-ls] :: ent [,ent]...

 Statement:

  PRIVATE [[::] ent [,ent]...]
  PUBLIC  [[::] ent [,ent]...]

   type      Is a data type specifier.

   att-ls    Is an optional list of attribute specifiers.

   ent       Is one of the following:

             A variable name
             A procedure name
             A derived type name
             A named constant
             A namelist group name

             In statement form, an entity can also be
             a generic identifier (a generic name, 
             defined operator, or defined assignment).

 The PRIVATE and PUBLIC attributes can only appear in the scoping
 unit of a module.

 Only one PRIVATE or PUBLIC statement without an entity list is
 permitted in the scoping unit of a module; it sets the default
 accessibility of all entities in the module.

 If no PUBLIC or PRIVATE statements are specified in a module, the
 default is PUBLIC accessibility.  Entities with PUBLIC
 accessibility can be accessed from outside the module by means of a
 USE statement.

 If a derived type is declared PRIVATE in a module, its components
 are also PRIVATE.  The derived type and its components are
 accessible to any subprograms within the defining module through
 host association, but they are not accessible from outside the
 module.

 If the derived type is declared PUBLIC in a module, but its
 components are declared PRIVATE, any scoping unit accessing the
 module though use association (or host association) can access the
 derived-type definition, but not its components.

 If a module procedure has a dummy argument or a function result of
 a type that has PRIVATE accessibility, the module procedure must
 have PRIVATE accessibility.  If the module has a generic
 identifier, it must also be declared PRIVATE.

 If a procedure has a generic identifier, the accessibility of the
 procedure's specific name is independent of the accessibility of
 its generic identifier.  One can be declared PRIVATE and the other
 PUBLIC.

 The PRIVATE attribute is compatible with the ALLOCATABLE,
 DIMENSION, EXTERNAL, INTRINSIC, PARAMETER, POINTER, SAVE, STATIC,
 TARGET, and VOLATILE attributes.

 The PUBLIC attribute is compatible with the ALLOCATABLE, DIMENSION,
 EXTERNAL, INTRINSIC, PARAMETER, POINTER, SAVE, STATIC, TARGET, and
 VOLATILE attributes.

 EXAMPLES:

 The following examples show type declaration statements specifying
 the PUBLIC and PRIVATE attributes:

    REAL,  PRIVATE  :: A, B, C
    INTEGER, PUBLIC :: LOCAL_SUMS

 The following is an example of the PUBLIC and PRIVATE statements:

    MODULE SOME_DATA
      REAL ALL_B
      PUBLIC ALL_B
      TYPE RESTRICTED_DATA
        REAL LOCAL_C
        DIMENSION LOCAL_C(50)
      END TYPE RESTRICTED_DATA
      PRIVATE RESTRICTED_DATA
    END MODULE

 The following derived-type declaration statement indicates that the
 type is restricted to the module:

    TYPE, PRIVATE  :: DATA
      ...
    END TYPE DATA

 The following example shows a PUBLIC type with PRIVATE components:

    MODULE MATTER
      TYPE ELEMENTS
        PRIVATE
        INTEGER C, D
      END TYPE
    ...
    END MODULE MATTER

 In this case, components C and D are private to type ELEMENTS, but
 type ELEMENTS is not private to MODULE MATTER.  Any program unit
 that uses the module MATTER, can declare variables of type
 ELEMENTS, and pass as arguments values of type ELEMENTS.
3 PROGRAM                 
 Begins a main program.  The PROGRAM statement is optional; when
 used, it can only be preceded by comment lines or an OPTIONS
 statement.  Statement format:

    PROGRAM nam

    nam   Is a symbolic name for the program.  The name must 
          be unique among all global names in the program.  

 If no PROGRAM statement begins the program, the program name
 defaults to filename$MAIN, where filename is the name of the file
 containing the program.

 The main program cannot contain the following attributes:  INTENT,
 OPTIONAL, PRIVATE, or PUBLIC.

 A main program can contain an internal subprogram (defines an
 internal procedure).  It must be preceded by a CONTAINS statement.
3 READ                    
 Transfers data from external or internal units to internal storage.

 The meanings of the symbolic abbreviations used to represent the
 parameters in the READ statement syntax are as follows:

    extu     Is the logical unit or internal file optionally 
    or       prefaced by UNIT=.  UNIT= is required if unit is 
    intu     not the first element in the clist.

    fmt      Specifies whether formatting is to be used for 
             data editing, and if it is, the format specification 
             or an asterisk (*) to indicate list-directed formatting. 
             The "fmt" is optionally prefaced by FMT=, if "fmt" is 
             the second parameter in the clist and the first parameter
             is a logical or internal unit specifier without the 
             optional keyword UNIT=.

    nml      Is the namelist group specification for namelist I/O. 
             Optionally prefaced by NML=.  NML= is required
             if namelist is not the second I/O specifier.
    
    rec      Is the cell number of a record to be accessed directly.
             Optionally prefaced by REC= or by an apostrophe (').
    
    iostat   Is the name of a variable to contain the completion 
             status of the I/O operation. Optionally prefaced 
             by IOSTAT=.

    err      Is the label of a statement to which control is 
             transferred in the event of an error. Optionally 
             prefaced by ERR=.

    end      Is the label of a statement to which control is 
             transferred in the event of an end-of-file. 
             Optionally prefaced by END=.

    eor      Is the label of a statement to which control is 
             transferred in the event of an end-of-record. 
             Optionally prefaced by EOR=.  This can only
             be specified for nonadvancing READs.

    adv      Specifies advancing (ADVANCE='YES') or nonadvancing 
             input (ADVANCE='NO').  The default is 'YES'.

    size     Specifies character count (SIZE=int). It can
             only be indicated for nonadvancing READs.

    keyspec  Specifies the key of field value of a record to 
             be accessed.  Optionally prefaced by KEY=, KEYEQ=, 
             KEYGE=, KEYGT=, KEYNXT, KEYNXTNE, KEYLT, or KEYLE.

    keyid    Specifies the key field index that is to be searched 
             for the specified key field value. Optionally in-
             cluded with keyspec and optionally prefaced by KEYID=.

    iolist   Are the names of the variables, arrays, array 
             elements, or character substrings from which or 
             to which data will be transferred.  Optionally 
             an implied-DO list.

 The control-list parameters are "extu" (or "intu"), "fmt", "nml",
 "rec", "iostat", "err", "end", "adv", "size", "keyspec", and
 "keyid".  The I/O list parameter is "iolist".
4 Sequential  
5 Formatted         
 Translates the data from character to binary format as specified by
 format specifications.  Statement formats:

 1. READ (extu, fmt [,adv][,size][,iostat][,err][,end][,eor]) [iolist]

    Reads from a specified external unit.

 2. READ f [,iolist]

    Reads from FOR$READ (normally, the terminal).
5 List-directed     
 List-directed sequential READ statement formats:

 1. READ(extu,*[,iostat][,err][,end])[iolist]
    
    Reads from a specified external unit.  
    Translates the data from character to binary 
    format according to the data types of the
    variables in the I/O list.

 2. READ * [,iolist]

    Reads from FOR$READ (normally, the terminal). 
    Translates the data from character to binary 
    format according to the data types of the 
    variables in the I/O list.
5 Namelist           
 Namelist sequential READ statement formats:

 1. READ (extu,nml [,iostat][,err][,end])
  
    Reads from a specified external unit.  Translates 
    the data from character to binary format according 
    to the data types of the list entities in the 
    corresponding NAMELIST statement.

 2. READ nml

    Reads from FOR$READ (normally, the terminal). 
    Translates the data from character to binary format 
    according to the data types of the entities in the 
    corresponding NAMELIST statement.
5 Unformatted       
 Unformatted sequential READ statement format:

    READ (extu,[,iostat][,err][,end]) [iolist]

 Reads from a specified external unit.  Does not translate the data.
4 Direct      
5 Formatted         
 Formatted direct READ statement format:

    READ (extu,fmt,rec[,iostat][,err]) [iolist]

 Reads from a specified external unit.  Translates the data from
 character to binary format as specified by "fmt".
5 Unformatted       
 Unformatted direct READ statement format:

    READ (extu,rec[,iostat][,err]) [iolist]

 Reads from a specified external unit.  Does not translate the data.
4 Indexed     
5 Formatted    
 Formatted Indexed READ statement format:

    READ (extu,fmt,keyspec[,keyid][,err][,iostat]) [iolist]

 Reads from a specified external unit.  Translates the data from
 character to binary format as specified by "fmt".
5 Unformatted       
 Unformatted Indexed READ statement format:

    READ (extu,keyspec[,keyid][,err][,iostat]) [iolist]

 Reads from a specified external unit.  Does not translate the data.
4 Internal          
 Internal READ statement format:

    READ (intu,fmt[,err][,iostat][,end]) [iolist]

 Reads from a specified character variable.  Translates the data
 from character to binary format as specified by "fmt".
3 RECORD                  
 Creates a record structure consisting of the variables and arrays
 specified in a previous structure declaration.  Statement format:

    RECORD /str/rnlist[,/str/rnlist...]

    str     Is the name of a previously declared structure.

    rnlist  Is a list of one or more variable names, array 
            names, or array declarators, separated by commas.
            All of the records named in this list have the 
            same structure and are allocated separately in 
            memory.

 Record variables can be used in COMMON and DIMENSION statements,
 but not in DATA, EQUIVALENCE, or NAMELIST statements.

 Records initially have undefined values unless you have defined
 their values in structure declarations.

 See also COMPATIBILITY_FEATURES RECORD_STRUCTURE in this Help file.
3 RETURN                  
 Transfers control from a subprogram to the calling program.  You
 can only use RETURN in a subprogram unit.  Statement format:

    RETURN [i]

    i  Is an optional integer constant or expression (such
       as 2 or I+J) indicating the position of an alternate 
       return from the subprogram in the actual argument list.
       The "i" is converted to an integer value if necessary.      

 The argument "i" is valid only for subroutine subprograms.  If no
 alternate return is specified or the specified alternate return
 does not exist in the actual argument list, control returns to the
 statement following the CALL statement.


                                NOTE

         An alternate return is an  obsolescent  feature  in
         Fortran  90  and Fortran 95.  DIGITAL Fortran flags
         obsolescent features, but fully supports them.


 If them subprogram is a function, control returns to the statement
 containing the function reference.  If the subprogram is a
 subroutine, control returns either to the statement following the
 CALL statement, or to the label specified by the alternate return
 argument.
3 REWIND                  
 Repositions a sequential file currently open for sequential or
 append access to the beginning of the file.  Do not use a REWIND
 statement for a file that is open for indexed or direct access.
 Use this statement only for files on disk or magnetic tape.
 Statement format:

     REWIND ([UNIT=]u[,ERR=s][,IOSTAT=ios])
     REWIND u

     u    Is an integer variable or constant specifying the 
          logical unit number of the file, optionally prefaced 
          by UNIT=.  UNIT= is required if unit is not the first 
          I/O specifier.

     s    Is the label of a statement to which control is 
          transferred if an error occurs, prefaced by ERR=.

     ios  Is an integer variable to which the completion status 
          of the I/O operation is returned, prefaced by IOSTAT=.

 The unit number must refer to a file on disk or magnetic tape, and
 the file must be open for sequential or append access.

 A REWIND statement must not be specified for a file that is open
 for direct or keyed access.

 If a file is already positioned at the initial point, a REWIND
 statement has no effect.

 If a REWIND statement is specified for a unit that is not open, it
 has no effect.

 See also STATEMENTS BACKSPACE in this Help file.
3 REWRITE                 
 Transfers data from internal storage and writes the data
 (translated if formatted; untranslated if unformatted) to the
 current record in the following types of files:  an indexed,
 sequential (only if the current record and new record are the same
 length), or relative file.

 The current record is the last record accessed by a preceding,
 successful direct access, indexed, or sequential READ statement.

    Formatted REWRITE statement format:

     REWRITE ([UNIT=]u,[FMT=]f[,ERR=s][,IOSTAT=ios])[iolist]
    
    Translates the data from binary to character format as
    specified by FMT.

    Unformatted REWRITE statement format:

     REWRITE ([UNIT=]u[,ERR=s][,IOSTAT=ios])[iolist]

    Does not translate the binary data.

    Arguments:

    u       Is an integer variable or constant specifying the 
            logical unit number of the file, optionally 
            prefaced by UNIT=.  UNIT= is required if unit is 
            not the first I/O specifier.

    f       Is a format specifier.

    s       Is the label of a statement to which control is 
            transferred if an error condition occurs, prefaced 
            by ERR=.

    ios     Is an integer variable to which the completion 
            status of the I/O operation is returned, prefaced 
            by IOSTAT=.

    iolist  Are the names of the variables from which the data 
            is transferred, listed in the order of transfer.

 Formatted REWRITE Statement Behavior and Errors:

 The formatted REWRITE statement performs the following operations:

  o  It retrieves binary values from internal storage.

  o  It translates those values to character form as specified by
     FORMAT.

  o  It writes the translated data to a current (existing) record in
     a file OPENed with ORGANIZATION='INDEXED', 'RELATIVE', or
     'SEQUENTIAL' (For SEQUENTIAL organization, the new record must
     be the same length as the existing record.)

     The current record is the last record accessed by a preceding,
     successful indexed, direct access, or sequential READ
     statement.


 Errors occur under the following conditions:

  o  If you attempt to rewrite more than one record in a single
     REWRITE statement operation

  o  If a record is too long (Note that unused space in a rewritten,
     fixed-length record is filled with spaces.)

  o  If the primary key value is changed


 In the following example, the REWRITE statement updates the current
 record contained in the relative organization file connected to
 logical unit 3 with the values represented by NAME, AGE, and BIRTH.

          REWRITE (3,10,ERR=99) NAME, AGE, BIRTH
    10    FORMAT (A16,I2,A8)

 Unformatted REWRITE Statement Behavior and Errors:

 The formatted REWRITE statement performs the following operations:

  o  It retrieves binary values from internal storage.

  o  It writes the untranslated data to a current (existing)
     existing record in a file OPENed with ORGANIZATION='INDEXED',
     'RELATIVE', or 'SEQUENTIAL' (For SEQUENTIAL organization, the
     new record must be the same length as the existing record.)

     The current record is the last record accessed by a preceding,
     successful indexed, direct access, or sequential READ
     statement.


 Errors occur under the following conditions:

  o  If you attempt to rewrite more than one record in a single
     REWRITE statement operation

  o  If a record is too long (Note that unused space in a rewritten,
     fixed-length record is filled with zeros.)

  o  If the primary key value is changed

3 SAVE                    
 Causes the values and definition of objects to be saved across
 invocations of a subprogram.

 The SAVE attribute can be specified in a type declaration statement
 or SAVE statement, and takes one of the following forms:

 Type Declaration Statement:

  type, [att-ls,] SAVE [,att-ls] :: [obj [,obj]...]

 Statement:

  SAVE [obj [,obj]...]

    type      Is a data type specifier.

    att-ls    Is an optional list of attribute specifiers.

    obj       Is the name of an object, or the name of a 
              common block enclosed in slashes (such as
              /CBLOCK/).

 In DIGITAL Fortran, the definitions of COMMON variables, and local
 variables of non-recursive subprograms (other than allocatable
 arrays or variables declared AUTOMATIC), are saved by default.  To
 enhance portability and avoid possible compiler warning messages,
 DIGITAL recommends that you use the SAVE statement to name
 variables whose values you want to preserve between subprogram
 invocations.

 When a SAVE statement does not explicitly contain a list, all
 allowable items in the scoping unit are saved.

 A SAVE statement cannot specify the following (their values cannot
 be saved):

  o  A blank common

  o  An object in a common block

  o  A procedure

  o  A dummy argument

  o  A function result

  o  An automatic object

  o  A PARAMETER (named) constant


 Even though a common block can be included in a SAVE statement,
 individual variables within the common block can become undefined
 (or redefined) in another scoping unit.

 If a common block is saved in any scoping unit of a program (other
 than the main program), it must be saved in every scoping unit in
 which the common block appears.

 A SAVE statement has no effect in a main program.

 The SAVE attribute is compatible with the ALLOCATABLE, DIMENSION,
 POINTER, PRIVATE, PUBLIC, STATIC, TARGET, and VOLATILE attributes.
3 Statement_Function      
 Defines a function consisting of a single expression.  The function
 must be invoked from the program unit in which it is defined.
 Format:

    fun([p [,p]...])=e

    fun  Is the symbolic name for the function. You can 
         establish its type explicitly or implicitly. The 
         value of the expression is returned to the function 
         name when the function is invoked.

    p    Is an unsubscripted variable name specifying a 
         dummy argument.  The arguments must agree in order, 
         number, and type with the actual arguments of the 
         statement invoking the function.  

    e    Is an arithmetic, logical, or character expression.  
         If the expression contains a reference to another 
         statement function, the referenced statement 
         function must precede the statement function 
         containing the reference.

 Declarator information does not apply to a dummy argument except
 for type.  For example, you cannot define a dummy argument as an
 array or as part of a common block.

 If you use the name of a dummy argument outside the function
 statement, the name defines another separate data entity.


                                NOTE

         This  statement  is  obsolescent  in  Fortran   95.
         DIGITAL  Fortran  flags  obsolescent  features, but
         fully supports them.

3 SELECT_CASE            
 See STATEMENTS CASE in this Help file.
3 SEQUENCE                
 Permitted for derived types.  Allows derived-type components to be
 used in COMMON and EQUIVALENCE statements.

 See DATA DERIVED_TYPES TYPE_DEFINITIONS in this Help file.
3 STOP                    
 Terminates program execution.  Statement format:

    STOP [disp]

    disp  Is a character constant or a string of up to
          six digits.  (Fortran 90 and FORTRAN 77 limit 
          digits to five.)

 If you specify the optional argument "disp", the STOP statement
 displays the contents of "disp" at your terminal, terminates
 program execution, and returns control to the operating system.

 If you do not specify a value for "disp", no message is displayed.
3 STRUCTURE               
 Indicates the beginning of the record structure declaration and
 defines the name of the structure.  Declaration format:

    STRUCTURE [/str/][fnlist]
      fdcl
      [fdcl]
      ...
      [fdcl]
    END STRUCTURE

    str     Identifies a structure name, which is used in 
            subsequent RECORD statements to refer to the 
            structure. A structure name is enclosed in slashes.

    fnlist  Identifies field names when used in a substructure 
            declaration.(Only allowed in nested structure
            declarations.)

    fdcl    (Also called the declaration body.)  Is any 
            declaration or combination of declarations of 
            substructures, unions, or typed data, or
            PARAMETER statements.

 Subsequent RECORD statements use the structure name to refer to the
 structure.  A structure name must be unique among structure names,
 but structures can share names with variables (scalar or array),
 record fields, PARAMETER constants, and common blocks.

 Structure declarations can be nested (contain one or more other
 structure declarations).  A structure name is required for the
 structured declaration at the outermost level of nesting, and
 optional for the other declarations nested in it.  However, if you
 wish to reference a nested structure in a RECORD statement in your
 program, it must have a name.

 Structure, field, and record names are all local to the defining
 program unit.  When records are passed as arguments, the fields
 must match in type, order, and dimension.

 Unlike type declaration statements, structure declarations do not
 create variables.  Structured variables (records) are created when
 you use a RECORD statement containing the name of a previously
 declared structure.  The RECORD statement can be considered as a
 kind of type declaration statement.  The difference is that
 aggregate items, not single items, are being defined.

 Within a structure declaration, the ordering of both the statements
 and the field names within the statements is important because this
 ordering determines the order of the fields in records.

 In a structure declaration, each field offset is the sum of the
 lengths of the previous fields.  The length of the structure,
 therefore, is the sum of the lengths of its fields.  The structure
 is packed; you must explicitly provide any alignment that is needed
 by including, for example, unnamed fields of the appropriate
 length.

 By default, fields are aligned on natural boundaries; misaligned
 fields are padded as necessary.  To avoid padding of records, you
 should lay out structures so that all fields are naturally aligned.

 To pack fields on arbitrary byte boundaries, you must specify a
 compiler option.  You can also specify alignment for fields by
 using the cDEC$ OPTIONS general directive.

 In the following example, the declaration defines a structure named
 DATE.  This structure contains three scalar fields:  DAY
 (LOGICAL*1), MONTH (LOGICAL*1), and YEAR (INTEGER*2).

    STRUCTURE /DATE/
        LOGICAL*1  DAY, MONTH
        INTEGER*2  YEAR
    END STRUCTURE


 See also COMPATIBILITY_FEATURES RECORD_STRUCTURE in this Help file.
4 Type_declarations
 The syntax of a type declaration within a record structure is
 identical to that of a normal Fortran type declaration statement:
 it includes a data type (for example, INTEGER), one or more names
 of variables or arrays; and optionally, one or more data
 initialization values.

 The following rules and behavior apply to type declarations in
 record structures:

  o  %FILL can be specified in place of a field name to leave space
     in a record for purposes such as alignment.  This creates an
     unnamed field.

     %FILL can have an array declarator; for example:

        INTEGER %FILL (2,2)

     Unnamed fields cannot be initialized.  For example, the
     following statement is invalid and generates an error message:

        INTEGER*4 %FILL /1980/

  o  Initial values can be supplied in field declaration statements.
     These initial values are supplied for all records that are
     declared using this structure.  Fields not initialized will
     have undefined values when variables are declared by means of
     RECORD statements.  Unnamed fields cannot be initialized; they
     are always undefined.

  o  Field names must always be given explicit data types.  The
     IMPLICIT statement has no effect on statements within a
     structure declaration.

  o  All Fortran data types are allowed in field declarations.

  o  Any required array dimensions must be specified in the field
     declaration statements.  DIMENSION statements cannot be used to
     define field names.

  o  Adjustable or assumed sized arrays and passed-length CHARACTER
     declarations are not allowed in field declarations.

  o  Field names within the same declaration level must be unique,
     but an inner structure declaration (substructure declaration)
     can include field names used in an outer structure declaration
     without conflict.

4 Substructure_declarations
 A field within a structure can itself be a structured item composed
 of other fields, other structures, or both.  You can declare a
 substructure in two ways:

  o  By nesting structure declarations within other structure or
     union declarations (with the limitation that you cannot refer
     to a structure inside itself at any level of nesting).

     One or more field names must be defined in the STRUCTURE
     statement for the substructure because all fields in a
     structure must be named.  In this case, the substructure is
     being used as a field within a structure or union.

     Field names within the same declaration nesting level must be
     unique, but an inner structure declaration can include field
     names used in an outer structure declaration without conflict.

     %FILL can be specified in place of a field name to leave space
     in a record for purposes such as alignment.

  o  By using a RECORD statement that specifies another previously
     defined record structure, thereby including it in the structure
     being declared.

4 Union_declarations
 A union declaration is a multistatement declaration defining a data
 area that can be shared intermittently during program execution by
 one or more fields or groups of fields.  A union declaration must
 be within a structure declaration.  A union declaration is
 initiated by a UNION statement and terminated by an END UNION
 statement.  Enclosed within these statements are two or more map
 declarations, initiated and terminated by MAP and END MAP
 statements.  Each unique field or group of fields is defined by a
 separate map declaration.

 A union declaration takes the following form:

    UNION
         mdcl
        [mdcl]
        ...
        [mdcl]
    END UNION

    Where "mdcl" represents:

    MAP
       fdcl
      [fdcl]
      ...
      [fdcl]
    END MAP

    fdcl  Is any declaration or combination of declarations 
          of substructures, unions, or type declarations.

 As with normal Fortran type declarations, data can be initialized
 in field declaration statements in union declarations.  However, if
 fields within multiple map declarations in a single union are
 initialized, the data declarations are initialized in the order in
 which the statements appear.  As a result, only the final
 initialization takes effect and all of the preceding
 initializations are overwritten.

 The size of the shared area established for a union declaration is
 the size of the largest map defined for that union.  The size of a
 map is the sum of the sizes of the fields declared within it.

 As the variables or arrays declared in map fields in a union
 declaration are assigned values during program execution, the
 values are established in a record in the field shared with other
 map fields in the union.  The fields of only one of the map
 declarations are defined within a union at any given point in the
 execution of a program.  However, if you overlay one variable with
 another smaller variable, that portion of the initial variable is
 retained that is not overlaid.  Depending on the application, the
 retained portion of an overlaid variable may or may not contain
 meaningful data and can be utilized at a later point in the
 program.

 Manipulating data using union declarations is similar to the effect
 of using EQUIVALENCE statements.  The difference is that data
 entities specified within EQUIVALENCE statements are concurrently
 associated with a common storage location and the data residing
 there; with union declarations you can use one discrete storage
 location to alternately contain a variety of fields (arrays or
 variables).

 With union declarations, only one map declaration within a union
 declaration can be associated at any point in time with the storage
 location that they share.  Whenever a field within another map
 declaration in the same union declaration is referenced in your
 program, the fields in the prior map declaration become undefined
 and are succeeded by the fields in the map declaration containing
 the newly referenced field.

 In the following example, the structure WORDS_LONG is defined.
 This structure contains a union declaration defining two map
 fields.  The first map field consists of three INTEGER*2 variables
 (WORD_0, WORD_1, and WORD_2), and the second, an INTEGER*4
 variable, LONG:

    STRUCTURE /WORDS_LONG/
        UNION
            MAP
             INTEGER*2    WORD_0, WORD_1, WORD_2
            END MAP
            MAP
             INTEGER*4    LONG
            END MAP
        END UNION
    END STRUCTURE
4 PARAMETER_Statements
 PARAMETER statements:  PARAMETER statements can appear in a
 structure declaration, but cannot be given a data type within the
 declaration block.  Consider the following:

    STRUCTURE /ABC/
        INTEGER*4 P
        PARAMETER (P=4)
        REAL*4 F
    END STRUCTURE
        REAL*4 A(P)

 In this example, the INTEGER*4 statement does not provide the data
 type for PARAMETER constant P, but instead declares a record field
 P in structure ABC.  The subsequent PARAMETER statement declares a
 new, different symbol which is given the implicit data type for
 identifiers beginning with the letter P.

 Type declarations for PARAMETER symbolic names must precede the
 PARAMETER statement and be outside of a STRUCTURE declaration, as
 follows:

        INTEGER*4 P
    STRUCTURE /ABC/
        PARAMETER (P=4)
        REAL*4 F
    END STRUCTURE
        REAL*4 A(P)

 For more information on PARAMETER statements, see STATEMENTS
 PARAMETER in this Help file.
3 SUBROUTINE              
 Begins a subroutine subprogram and names the dummy arguments.  The
 CALL statement transfers control to a subroutine subprogram; a
 RETURN or END statement returns control to the calling program
 unit.  Statement format:

    [prefx] SUBROUTINE nam [([p[,p]...])]

    prefx Is one of the following keywords:

          RECURSIVE    Permits direct recursion to occur.  
          
          PURE         Restricts the procedure from having
                       side effects.

          ELEMENTAL    Specifies PURE with certain constraints
                       on a dummy argument:
                       o It must be scalar and cannot have the 
                         POINTER attribute. 
                       o It cannot appear in a specification 
                         expression, except as an argument to the 
                         BIT_SIZE, KIND, or LEN intrinsic functions 
                         or the numeric inquiry intrinsic functions
                       o It must not be *
                       o It must not be a dummy procedure
                       If ELEMENT is specified, RECURSIVE must not 
                       be specified.

          EXTRINSIC(HPF), EXTRINSIC(HPF_LOCAL), and 
          EXTRINSIC(SCALAR) can also be specified, but they
          have no effect on OpenVMS systems.


    nam  Is a symbolic name for the subroutine.  The name must 
         be unique among all global names in the program.

    p    Is an unsubscripted variable name specifying a dummy 
         argument.  An asterisk (*) as a dummy argument specifies 
         that the actual argument is an alternate return argument.  

 The arguments must agree in order, number, and type with the actual
 arguments of the statement invoking the subroutine.  A dummy
 argument must not be defined as an array with more elements than
 the actual argument holds.  When control transfers to the
 subroutine, the values of any actual arguments in the CALL
 statement are associated with any corresponding dummy arguments in
 the SUBROUTINE statement.  The statements in the subprogram are
 then executed.

 The SUBROUTINE statement must be the first statement of a
 subroutine, unless an OPTIONS statement is specified.

 A subroutine subprogram cannot contain a FUNCTION statement, a
 BLOCK DATA statement, a PROGRAM statement, or another SUBROUTINE
 statement.

 ENTRY statements are allowed to specify multiple entry points in
 the subroutine.

 The array declarator for a dummy argument can itself contain
 integer values that are dummy arguments or are references to a
 common block, providing for adjustable size arrays in subroutines.
 The upper bound of the array declarator for a dummy argument can be
 specified as an asterisk, in which case the upper bound of the
 dummy argument assumes the size of the upper bound of the actual
 argument.  The size in a character string declarator for a dummy
 argument can be specified as an asterisk in parentheses, in which
 case the size of the actual argument is passed to the dummy
 argument.

 The values of the actual arguments in the invoking program unit
 become the values of the dummy arguments in the function.  If you
 modify a dummy argument, the corresponding actual argument in the
 invoking program unit is also modified; the actual argument must be
 a variable if it is to be modified.

 If the actual argument is a character constant, the dummy argument
 can be either character or numeric in type, unless the name of the
 subprogram being invoked is a dummy argument in the invoking
 program unit.  If the actual argument is a Hollerith constant, the
 dummy argument must be numeric.
3 TARGET                  
 Specifies that an object can become the target of a pointer.

 The TARGET attribute can be specified in a type declaration
 statement or TARGET statement, and takes one of the following
 forms:

 Type Declaration Statement:

  type, [att-ls,] TARGET [,att-ls] :: obj [spec] [,obj [spec]]...

 Statement:

  TARGET [::] obj [spec] [,obj [spec]]...

    type      Is a data type specifier.

    att-ls    Is an optional list of attribute specifiers.

    obj       Is the name of an object.  The object must 
              not be declared with the PARAMETER attribute.
    
    spec      Is an array specification.

 A pointer is associated with a target by pointer assignment or by
 an ALLOCATE statement.

 If an object does not have the TARGET attribute or has not been
 allocated (using an ALLOCATE statement), no part of it can be
 accessed by a pointer.

 The TARGET attribute is compatible with the ALLOCATABLE, AUTOMATIC,
 DIMENSION, INTENT, OPTIONAL, PRIVATE, PUBLIC, SAVE, STATIC, and
 VOLATILE attributes.

 EXAMPLES:

 The following example shows type declaration statements specifying
 the TARGET attribute:

    TYPE(SYSTEM), TARGET :: FIRST
    REAL, DIMENSION(20, 20), TARGET :: C, D

 The following is an example of a TARGET statement:

    TARGET :: C(50, 50), D
3 TYPE                    
 Transfers output data from internal storage to external records
 that are sequentially accessed.
4 Formatted        
 Translates data from binary to character format as specified by the
 format specifications.  Statement format:

    TYPE f[,iolist]

    f       Is a format specifier not prefaced by FMT=.

    iolist  Are the names of the variables from which the 
            data is transferred, listed in the order of transfer.
4 List-directed    
 Translates data from binary to character format according to the
 data types of the variables in the I/O list.  Statement format:

    TYPE *[,iolist]

    *       Specifies list-directed formatting.

    iolist  Are the names of the variables from which the data 
            is transferred, listed in the order of transfer.
4 Namelist
 Translates data from binary to character format according to the
 data types of the list entities in the corresponding NAMELIST
 statement.  Statement format:

    TYPE n

    n  Is a namelist group name not prefaced by NML=.
3 Type_declaration        
 Explicitly specifies the properties of data objects or functions.

 Type declarations must precede all executable statements, can be
 declared only once, and cannot be used to change the type of a
 symbolic name that has already been implicitly assumed to be
 another type.

 Type declaration statements can initialize data in the same way as
 the DATA statement:  by having values, bounded by slashes, listed
 immediately after the symbolic name of the entity.
4 Numeric     
 Statement format:

    type[*n] [[,att]...::] v [*n][/clist/][,v [*n][/clist/]]...

    type   Is any of the following data type specifiers:

           BYTE (equivalent to INTEGER*1)  DOUBLE PRECISION
           LOGICAL                         COMPLEX
           INTEGER                         DOUBLE COMPLEX
           REAL

    n      Is an integer that specifies (in bytes) the length 
           of "v".  It overrides the length that is implied by 
           the data type.

           The value of n must specify an acceptable length 
           for the type of "v" (see your language reference 
           manual). BYTE, DOUBLE PRECISION, and DOUBLE COMPLEX 
           data types have one acceptable length; thus, for 
           these data types, the "n" specifier is invalid. 

           If an array declarator is used, the "n" specifier 
           must be positioned immediately after the array name.

    att    Is one of the following attribute specifiers:

           ALLOCATABLE       POINTER
           AUTOMATIC         PRIVATE
           DIMENSION         PUBLIC
           EXTERNAL          SAVE
           INTENT            STATIC
           INTRINSIC         TARGET
           OPTIONAL          VOLATILE
           PARAMETER

    v      Is the name of a data object or function.  It can
           optionally be followed by:

           o An array specification, if the object is an array
           o A character length, if the object is of type 
             character
           o An initialization expression or, for pointer
             objects, =>NULL() 

    clist  Is a list of constants, as in a DATA statement.  If 
           "v" is the symbolic name of a constant, the "clist" 
           cannot be present.

 A numeric data type declaration statement can define arrays by
 including array specifications in the list.

 A numeric type declaration statement can assign initial values to
 variables or arrays if it specifies a list of constants (the
 "clist").  The specified constants initialize only the variable or
 array that immediately precedes them.  The "clist" cannot have more
 than one item unless it initializes an array.  When the "clist"
 initializes an array, it must contain a value for every element in
 the array.

 If =>NULL() appears for a pointer, the pointer's initial
 association status is disassociated.

 In a function declaration, an array must be a deferred-shape array
 if it has the POINTER attribute; otherwise, it must be an
 explicit-shape array.

 The double colon separator (::) is required only if the declaration
 contains an attribute specifier or an initialization expression;
 otherwise it is optional.

 The same attribute must not appear more than once in a given type
 declaration statement, and an entity cannot be given the same
 attribute more than once in a scoping unit.

 If the PARAMETER attribute is specified, the declaration must
 contain an initialization expression.

 The following objects cannot be initialized in a type declaration
 statement:

  o  A dummy argument

  o  A function result

  o  An object in a named common block (unless the type declaration
     is in a block data program unit)

  o  An object in blank common

  o  An allocatable array

  o  A pointer

  o  An external name

  o  An intrinsic name

  o  An automatic object

  o  An object that has the AUTOMATIC attribute

4 Character   
 Format:

    CHARACTER[*len[,] [[,att]...::] v[*len] [/clist/] 
                                    [,v[*len] [/clist/]]...

    len    Is an unsigned integer constant, an integer constant 
           expression enclosed in parentheses, or an asterisk (*)
           enclosed in parentheses.  The value of "len" specifies 
           the length of the character data elements.

    att    Is one of the following attribute specifiers:

           ALLOCATABLE       POINTER
           AUTOMATIC         PRIVATE
           DIMENSION         PUBLIC
           EXTERNAL          SAVE
           INTENT            STATIC
           INTRINSIC         TARGET
           OPTIONAL          VOLATILE
           PARAMETER

    v      Is the symbolic name of a constant, variable, array, 
           statement function or function subprogram, or array 
           specification. The name can optionally be followed by 
           a data type length specifier (*len or *(*)).

    clist  Is a list of constants, as in a DATA statement.  If
           "v" is the symbolic name of a constant, "clist" must 
           not be present.

 If you use CHARACTER*len, "len" is the default length specification
 for that list.  If an item in that list does not have a length
 specification, the item's length is "len".  However, if an item
 does have a length specification, it overrides the default length
 specified in CHARACTER*len.

 When an asterisk length specification *(*) is used for a function
 name or dummy argument, it assumes the length of the corresponding
 function reference or actual argument.  Similarly, when an asterisk
 length specification is used for the symbolic name of a constant,
 the name assumes the length of the actual constant it represents.
 For example, STRING assumes a 9-byte length in the following
 statements:

    CHARACTER*(*) STRING
    PARAMETER (STRING = 'VALUE IS:')

 The length specification must range from 1 to 65535.  If no length
 is specified, a length of 1 is assumed.

 Character type declaration statements can define arrays if they
 include array specifications in their list.  The array
 specification goes first if both an array specification and a
 length are specified.

 A character type declaration statement can assign initial values to
 variables or arrays if it specifies a list of constants (the
 clist).  The specified constants initialize only the variable or
 array that immediately precedes them.  The "clist" cannot have more
 than one element unless it initializes an array.  When the "clist"
 initializes an array, it must contain a value for every element in
 the array.

 In a function declaration, an array must be a deferred-shape array
 if it has the POINTER attribute; otherwise, it must be an
 explicit-shape array.

 The double colon separator (::) is required only if the declaration
 contains an attribute specifier or an initialization expression;
 otherwise it is optional.

 The same attribute must not appear more than once in a given type
 declaration statement, and an entity cannot be given the same
 attribute more than once in a scoping unit.

 If the PARAMETER attribute is specified, the declaration must
 contain an initialization expression.

 The following objects cannot be initialized in a type declaration
 statement:

  o  A dummy argument

  o  A function result

  o  An object in a named common block (unless the type declaration
     is in a block data program unit)

  o  An object in blank common

  o  An allocatable array

  o  A pointer

  o  An external name

  o  An intrinsic name

  o  An automatic object

  o  An object that has the AUTOMATIC attribute



                                NOTE

         The CHARACTER*len form for a CHARACTER  declaration
         is  obsolescent  in  Fortran  95.   DIGITAL Fortran
         flags  obsolescent  features,  but  fully  supports
         them.

3 UNION                   
 See STATEMENTS STRUCTURE (subheads TYPE_DECLARATIONS and
 UNION_DECLARATIONS) in this Help file.
3 UNLOCK                  
 Frees the current record (that is, the last record read) in an
 indexed, relative, or sequential file.  By default, a record is
 locked when it is read.  The lock is normally held until your
 program performs another I/O operation on the unit (for example,
 rewriting the record, reading another record, or closing the file).

 Statement format:

    UNLOCK ([UNIT=]u[,ERR=s][,IOSTAT=ios])
    UNLOCK u

    u    An integer variable or constant specifying the 
         logical unit number of the file, optionally 
         prefaced by UNIT=.  UNIT= is required if unit is
         not the first I/O specifier.

    s    The label of a statement to which control is 
         transferred if an error condition occurs.

    ios  A scalar default integer variable that is 
         defined as a positive integer if an error occurs 
         and zero if no error occurs.
3 USE                     
 Gives a program unit accessibility to public entities in a module.
 It takes one of the following forms:

    USE name [, rename-ls]
    USE name, ONLY : [only-ls]

    name       Is the name of the module.

    rename-ls  Is one or more items having the following 
               form:

       local-name => mod-name

       local-name  Is the name of the entity in the program 
                   unit using the module.

       mod-name    Is the name of a public entity in the module. 

    only-ls   Is the name of a public entity in the module
              or a generic identifier (a generic name, defined
              operator, or defined assignment).
     
              An entity in the "only-ls" can also take the form:

       [local-name =>] mod-name

 If the USE statement is specified without the ONLY option, the
 program unit has access to all public entities in the named module.

 If the USE statement is specified with the ONLY option, the program
 unit has access to only those entities following the option.

 If more than one USE statement for a given module appears in a
 scoping unit, the following rules apply:

  o  If one USE statement does not have the ONLY option, all public
     entities in the module are accessible, and any "rename-ls"s and
     "only-ls"s are interpreted as a single, concatenated
     "rename-ls".

  o  If all the USE statements have ONLY options, all the "only-ls"s
     are interpreted as a single, concatenated "only-ls".  Only
     those entities named in one or more of the "only-ls"s are
     accessible.


 If two or more generic interfaces that are accessible in a scoping
 unit have the same name, the same operator, or are both
 assignments, they are interpreted as a single generic interface.
 Otherwise, multiple accessible entities can have the same name only
 if no reference to the name is made in the scoping unit.

 The local names of entities made accessible by a USE statement must
 not be respecified with any attribute other than PUBLIC or PRIVATE.
 The local names can appear in namelist group lists, but not in a
 COMMON or EQUIVALENCE statement.

 EXAMPLES:

 The following shows examples of the USE statement:

   MODULE MOD_A
     INTEGER :: B, C
     REAL E(25,5), D(100)
   END MODULE MOD_A
   ...
   SUBROUTINE SUB_Y
     USE MOD_A, DX => D, EX => E   ! Array D has been renamed 
                                   ! DX and array E 
     ...                           ! has been renamed EX. Scalar 
                                   ! variables B 
   END SUBROUTINE SUB_Y            ! and C are also available to 
   ...                             ! this subroutine (using their 
                                   ! module names).
   SUBROUTINE SUB_Z
     USE MOD_A, ONLY: B, C         ! Only scalar variables B and 
                                   ! C are
     ...                           ! available to this subroutine
   END SUBROUTINE SUB_Z
   ...

 The following example shows a module containing common blocks:

   MODULE COLORS
     COMMON /BLOCKA/ C, D(15)
     COMMON /BLOCKB/ E, F
     ...
   END MODULE COLORS
   ...
   FUNCTION HUE(A, B)
     USE COLORS
     ...
   END FUNCTION HUE

 The USE statement makes all of the variables in the common blocks
 in module COLORS available to the function HUE.

 To provide data abstraction, a user-defined data type and
 operations to be performed on values of this type can be packaged
 together in a module.  The following example shows such a module:

   MODULE CALCULATION
     TYPE ITEM
       REAL :: X, Y
     END TYPE ITEM

     INTERFACE OPERATOR (+)
       MODULE PROCEDURE ITEM_CALC
     END INTERFACE

   CONTAINS
     FUNCTION ITEM_CALC (A1, A2)
       TYPE(ITEM) A1, A2, ITEM_CALC
       ...
     END FUNCTION ITEM_CALC
     ...
   END MODULE CALCULATION

   PROGRAM TOTALS
   USE CALCULATION
   TYPE(ITEM) X, Y, Z
     ...
     X = Y + Z
     ...
   END

 The USE statement allows program TOTALS access to both the type
 ITEM and the extended intrinsic operator + to perform calculations.
3 VIRTUAL                 
 See COMPATIBILITY_FEATURES in this Help file.
3 VOLATILE                
 Prevents specified variables, arrays, and common blocks from being
 optimized during compilation.

 The VOLATILE attribute can be specified in a type declaration
 statement or VOLATILE statement, and takes one of the following
 forms:

 Type Declaration Statement:

  type, [att-ls,] VOLATILE [,attr-ls] :: obj [,obj]...

 Statement:

  VOLATILE obj [,obj]...

    type      Is a data type specifier.

    attr-ls   Is an optional list of attribute specifiers.

    obj       Is the name of an object or a common block 
              enclosed in slashes.

 A variable or COMMON block must be declared VOLATILE if it can be
 read or written in a way that is not visible to the compiler.  For
 example:

  o  If an operating system feature is used to place a variable in
     shared memory (so that it can be accessed by other programs),
     the variable must be declared VOLATILE.

  o  If a variable is modified by a routine called by the operating
     system when an asynchronous event occurs, the variable must be
     declared VOLATILE.


 Formal (dummy) arguments which can be omitted must be declared
 VOLATILE.

 If an array is declared VOLATILE, each element in the array becomes
 volatile.  If a common block is declared VOLATILE, each variable in
 the common block becomes volatile.

 If an object of derived type is declared VOLATILE, its components
 become volatile.

 If a pointer is declared VOLATILE, the pointer itself becomes
 volatile.

 A VOLATILE statement cannot specify the following:

  o  A procedure

  o  A function result

  o  A namelist group


 The VOLATILE attribute is compatible with the ALLOCATABLE,
 AUTOMATIC, DIMENSION, INTENT, OPTIONAL, POINTER, PRIVATE, PUBLIC,
 SAVE, STATIC, and TARGET attributes.
3 WHERE                   
 Permits masked array assignment, which lets you perform an array
 operation on selected elements.  This kind of assignment masks the
 evaluation of expressions and assignment of values in array
 assignment statements, according to the value of a logical array
 expression.

 WHERE can be specified as a construct or statement.  Format:

 Statement form:

   WHERE (mask-expr1) assign-stmt 

 Construct form:

   [name :] WHERE (mask-expr1) 
      [where-body-stmt]...
   [ELSEWHERE (mask-expr2) [name]
      [where-body-stmt]...]
   [ELSEWHERE [name]
      [where-body-stmt]...]
   END WHERE [name]

   name             Is the name of the WHERE construct.

   mask-expr1       Are logical array expressions (called 
   mask-expr2       mask expressions).

   assign-stmt      Is an assignment statement of the form: 

                    array variable = array expression

   where-body-stmt  Is one of the following:
                    o An "assign-stmt"
                    o A WHERE statement or construct

 If a construct name is specified in a WHERE statement, the same
 name must appear in the corresponding END WHERE statement.  The
 same construct name can optionally appear in any ELSEWHERE
 statement in the construct.  (ELSEWHERE cannot specify a different
 name.)

 In each assignment statement, the mask expression, the variable
 being assigned to, and the expression on the right side, must all
 be conformable.  Also, the assignment statement cannot be a defined
 assignment.

 Each mask expression in the WHERE construct must be conformable.

 Only the WHERE statement (or the first line of the WHERE construct)
 can be labeled as a branch target statement.

 The following is an example of a WHERE statement:

   INTEGER A, B, C
   DIMENSION A(5), B(5), C(5)
   DATA A /0,1,1,1,0/
   DATA B /10,11,12,13,14/
   C = -1

   WHERE(A .NE. 0) C = B / A

 The resulting array C contains:  -1,11,12,13, and -1.

 The assignment statement is only executed for those elements where
 the mask is true.  Think of the mask expression as being evaluated
 first into a logical array which has the value true for those
 elements where A is positive.

 This array of trues and falses is applied to the arrays A, B and C
 in the assignment statement.  The right side is only evaluated for
 elements for which the mask is true; assignment on the left side is
 only performed for those elements for which the mask is true.  The
 elements for which the mask is false do not get assigned a value.

 In a WHERE construct the mask expression is evaluated first and
 only once.  Every assignment statement following the WHERE is
 executed as if it were a WHERE statement with "mask-expr1" and
 every assignment statement following the ELSEWHERE is executed as
 if it were a WHERE statement with ".NOT.  mask-expr1".  If
 ELSEWHERE specifies "mask-expr2", it is executed as "(.NOT.
 mask-expr1) .AND.  mask-expr2".

 You should be careful if the statements have side effects, or
 modify each other or the mask expression.

 The following is an example of the WHERE construct:

   DIMENSION PRESSURE(1000), TEMP(1000), PRECIPITATION(1000)
   WHERE(PRESSURE .GE. 1.0)
     PRESSURE = PRESSURE + 1.0
     TEMP = TEMP - 10.0
   ELSEWHERE
     PRECIPITATION = .TRUE.
   ENDWHERE

 The mask is applied to the arguments of functions on the right side
 of the assignment if they are considered to be elemental functions.
 Only elemental intrinsics are considered elemental functions.
 Transformational intrinsics, inquiry intrinsics, and functions or
 operations defined in the subprogram are considered to be
 nonelemental functions.

 Consider the following example using LOG, an elemental function:

   WHERE(A .GT. 0)  B = LOG(A) 

 The mask is applied to A, and LOG is executed only for the positive
 values of A.  The result of the LOG is assigned to those elements
 of B where the mask is true.

 Consider the following example using SUM, a nonelemental function:

   REAL A, B
   DIMENSION A(10,10), B(10)
   WHERE(B .GT. 0.0)  B = SUM(A, DIM=1)

 Since SUM is nonelemental, it is evaluated fully for all of A.
 Then, the assignment only happens for those elements for which the
 mask evaluated to true.

 Consider the following example:

   REAL A, B, C
   DIMENSION A(10,10), B(10), C(10)
   WHERE(C .GT. 0.0)  B = SUM(LOG(A), DIM=1)/C

 Because SUM is nonelemental, all of its arguments are evaluated
 fully regardless of whether they are elemental or not.  In this
 example, LOG(A) is fully evaluated for all elements in A even
 though LOG is elemental.  Notice that the mask is applied to the
 result of the SUM and to C to determine the right side.  One way of
 thinking about this is that everything inside the argument list of
 a nonelemental function does not use the mask, everything outside
 does.
3 WRITE                   
 Transfers data from internal storage to user-specified external
 logical units (such as disks, printers, terminals, and pipes) or
 internal files.

 The meanings of the symbolic abbreviations used to represent the
 parameters in the WRITE statement syntax are as follows:

    extu    Is the logical unit or internal file optionally 
    or      prefaced by UNIT=.  UNIT= is required if unit is
    intu    not the first element in the clist.

    fmt     Specifies whether formatting is to be used for data 
            editing, and if it is, the format specification or an 
            asterisk (*) to indicate list-directed formatting. 
            The "fmt" is optionally prefaced by FMT=, if "fmt"
            is the second parameter in the clist and the first 
            parameter is a logical or internal unit specifier 
            without the optional keyword UNIT=.

    nml     Is the namelist group specification for namelist I/O. 
            Optionally prefaced by NML=.  NML= is required if 
            namelist is not the second I/O specifier.

    rec     Is the cell number of a record to be accessed directly.
            Optionally prefaced by REC= or by an apostrophe (').

    iostat  Is the name of a variable to contain the completion 
            status of the I/O operation. Prefaced by IOSTAT=.

    err     Is the label of a statement to which control is 
            transferred in the event of an error. Prefaced by 
            ERR=.

    end     Is the label of a statement to which control is 
            transferred in the event of an end of file. Prefaced 
            by END=.

    adv     Specifies advancing (ADVANCE='YES') or nonadvancing 
            input (ADVANCE='NO').  The default is 'YES'.

    iolist  Are the names of the variables, arrays, array elements, 
            or character substrings from which or to which data 
            will be transferred.  Optionally an implied-DO list.

 The control-list parameters are "extu" (or "intu"), "fmt", "nml",
 "rec", "iostat", "err", "end", and "adv".  The I/O list parameter
 is "iolist".
4 Sequential  
5 Formatted         
 Formatted sequential WRITE statement format:

    WRITE (extu,fmt [,adv][,err][,iostat]) [iolist]

 Writes to a specified external unit.  Translates the data from
 binary to character format as specified by "fmt".
5 List-directed     
 List-directed sequential WRITE statement format:

    WRITE (extu,*[,iostat][,err]) [iolist]

 Writes to a specified external unit.  Translates the data from
 binary to character format according to the data types of the
 variables in the I/O list.
5 Namelist          
 Namelist sequential WRITE statement format:

    WRITE (extu,nml[,iostat][,err])

 Writes to a specified external unit.  Translates the data from
 binary to character format according to the data types of the list
 entities in the corresponding NAMELIST statement.
5 Unformatted       
 Unformatted sequential WRITE statement format:

    WRITE (extu[,iostat][,err]) [iolist]

 Writes to a specified external unit.  Does not translate the data.
4 Direct      
5 Formatted         
 Formatted direct WRITE statement format:

    WRITE (extu,rec,fmt[,iostat][,err]) [iolist]

 Writes to a specified external unit.  Translates the data from
 binary to character format as specified by "fmt".
5 Unformatted       
 Unformatted direct WRITE statement format:

   WRITE (extu,rec[,iostat][,err]) [iolist]

 Writes to a specified external unit.  Does not translate the data.
4 Internal    
 Internal WRITE statement format:

    WRITE (intu[,fmt][,err][,iostat]) [iolist]

 Writes to a specified character variable.  Translates the data from
 binary to character format as specified by "fmt".
4 Indexed     
5 Formatted         
 Formatted indexed WRITE statement format:

    WRITE (extu,fmt,[,err][,iostat]) [iolist]

 Writes to a specified external unit.  Translates the data from
 binary to character format as specified by "fmt".
5 Unformatted       
 Unformatted indexed WRITE statement format:

    WRITE (extu,[,err][,iostat]) [iolist]

 Writes to a specified external unit.  Does not translate the data.
