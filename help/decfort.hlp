1 f77
 Invokes the Digital Fortran 77 (FORTRAN-77) compiler.  This command
 can also invoke other software components (such as preprocessors,
 or the ld linker), depending on which files or options are
 specified on the command line.  The f77 command produces object
 code files in ULTRIX RISC or Digital UNIX Alpha extended coff
 format; it is described in detail in your DEC Fortran user manual.
 (See also f77(1).)

 Format:

     f77 [options] filename [options]

 If you specify more than one option or filename, separate each with
 a space.  Some options include keywords.  For more information, see
 Parameters.

 f77 sends its output to "stderr".  Upon program completion, the f77
 driver returns one of the following status values:
     0 - SUCCESS
     1 - FAILURE
     2 - SUBPROCESS_FAILURE (preprocessor, decfort, or ld)
     3 - SIGNAL

 If the environment variable DECFORT is set, the value is used as
 the name of the compiler to invoke.  If the environment variable
 TMPDIR is set, the value is used as the directory for temporary
 files.

 If the environment variable DECFORT_INIT is defined, its value has
 to have the form
     [[pre] [:: [post]]

 where the items in "[...]" are optional and can be empty, and where
 "pre" and "post" are strings to be added to the command line.
 "pre" is added to the front of the command line, before any
 characters the user typed; "post" is added to the end of the
 command line.

 Your Digital Fortran kit contains a Help file in text format.  To
 search for information in this file, enter the following command to
 display the file:

    % more /usr/lib/cmplrs/fort/decfortran.hlp

 To search for a specific item, enter a slash (/) followed by the
 item.  For example, once the Help file is displayed, you can search
 for run-time error message number 138 by entering the following:

    /138
2 Parameters          
 Options

 Indicates either special actions to be performed by the compiler or
 linker, or special properties of input or output files.

 If you specify more than one option, separate each option with a
 space.

 Certain options have the format of -option "keyword", where the
 "keyword" can be abbreviated to its shortest unique prefix.  For
 example, -assume noaccuracy can be abbreviated as -assume noac.

 For more information about command line options, see f77(1).  If
 you are using LSE, you can see f77(1) by entering the following
 command at the LSE prompt:

    LSE> cli man f77

 Filename

 Specifies one (or more) source programs to be compiled.  If you
 specify more than one filename, separate each filename with a
 space.

 The f77 command interprets filename suffixes as follows:

  o  Arguments with the suffix .f, .for, or .FOR are interpreted as
     FORTRAN-77 source programs.  These programs are compiled, and
     the name of the resulting object program is the basename of the
     source file with a .o substituted for the .f, .for, or .FOR.
     (For example, in source file myfile.f, myfile is the basename;
     so, the object program is named myfile.o.) If the source
     program is compiled and loaded, the .o file is deleted.

  o  Arguments with the suffix .F are interpreted as FORTRAN source
     programs, which must be processed by the C preprocessor
     (cpp(1)) before being compiled.

  o  Arguments with the suffixes .r or .e are interpreted as ratfor
     or efl source programs, respectively.  These programs are first
     transformed by the appropriate preprocessor and then compiled.

  o  Arguments with the suffix .i are interpreted as FORTRAN-77
     source programs that have been preprocessed by cpp(1).  They
     are compiled without further preprocessing.

 When a source program requires preprocessing by cpp(1), efl(1),
 ratfor(1), or m4(1), the name of the output file generated by the
 preprocessor consists of the basename of the source input file with
 the appropriate preprocessor suffix.  For example:

     m4     myfile.r =>  myfile.p
     efl    myfile.e =>  myfile.f 
     ratfor myfile.r =>  myfile.f
     cpp    myfile.F =>  myfile.i

 Note that if you have myfile.F and myfile.f as distinct files,
 cpp(1) overwrites myfile.f to produce an output file with the same
 name.

 Depending on which platform you are using, the f77 command defines
 the following cpp(1) macros to cpp(1):

  o  All platforms:  LANGUAGE_FORTRAN, __LANGUAGE_FORTRAN__, unix,
     __unix__

  o  RISC only:  host_mips, __host_mips__

  o  Alpha only:  __alpha

  o  Digital UNIX only:  __osf__

  o  ULTRIX RISC only:  MIPSEL, mips, __mips__


 For example, if you are using an Digital UNIX Alpha system, the
 following cpp(1) macros are defined to cpp(1):  LANGUAGE_FORTRAN,
 __LANGUAGE_FORTRAN__, unix, __unix__, __alpha, and __osf__.
2 Options                          
 Indicate either special actions to be performed by the compiler or
 linker, or special properties of input or output files.

 You can override some options specified on the command line by
 using the OPTIONS statement, the AUTOMATIC and STATIC statements,
 and directives (CDEC$) in your FORTRAN source program.  The options
 specified by the OPTIONS statement affect only the program unit
 where the statement occurs.

 For descriptions of all command line options, see f77(1) by
 entering the following command at the LSE prompt:

    LSE> cli man f77
2 Examples            

 1.  % f77 -V aaa.f bbb.f ccc.f

     This command causes the files aaa.f, bbb.f, and ccc.f to be
     compiled into one temporary object file, which is then passed
     to the ld linker.  The ld linker produces the executable file
     a.out.  The -V option causes the compiler to create the listing
     file aaa.1.

 2.  % f77 -o foo ax.f bx.f cx.f

     This command causes the files ax.f, bx.f, and cx.f to be
     compiled as one program, with the resulting executable file
     foo.

 3.  % f77 -c -O4 ax.f bx.f cx.f

     This command causes the files ax.o, bx.o and cx.o to be
     created.  Inter-procedural optimization is hindered because
     these input files are separately compiled.

 4.  % f77 -c -o foo.o -O4 ax.f bx.f cx.f

     This command causes the files ax.f, bx.f and cx.f to be
     compiled as one program, with the resulting object file foo.o.
     This produces better optimization.

2 Release_Notes

 For Digital Fortran 77 release notes, refer to:

     /usr/lib/cmplrs/fort/relnotes
2 Built-in_Functions
 Built-in functions perform utility operations that are useful in
 communicating with subprograms written in languages other than
 Fortran.

 See also Intrinsic_Functions.
3 %LOC   
 %LOC (arg)
 Returns the internal address of a storage item.  The argument can
 be a variable, an array or record field reference, a procedure, or
 a constant; it can be of any data type.  The result is an INTEGER*8
 data type.

 The %LOC built-in function serves the same purpose as the LOC
 intrinsic.
3 %REF   
 %REF (arg)
 Forces an actual argument in a CALL statement or function reference
 to be passed by reference:  the address of the argument is passed
 to the subprogram.  By default, Fortran passes all numeric values
 by reference.
3 %VAL   
 %VAL (arg)
 Forces an actual argument in a CALL statement or function reference
 to be passed by value:  the actual value of the argument is passed
 to the subprogram.  The argument must be 32 bits in size or less.
 If the argument is less than 32 bits in size, it is sign-extended
 to that size.
2 Character_Sets    
 Digital Fortran 77 supports the following characters:

  o  The Fortran character set, consisting of those ASCII characters
     which can appear in Fortran language syntax and which is a
     superset of the FORTRAN-77 standard character set.  This set
     includes space and tab characters.

  o  Other printable characters, which may appear in comments and
     character and Hollerith constants.

  o  Nonprintable characters.

3 ASCII
 The following table represents the ASCII character set (characters
 with decimal values 0 through 127).  Except for SP and HT, the
 characters with names are nonprintable.

 To determine the hexadecimal value of an ASCII character, combine
 the values in the column (0-7) and the row (0-F) that relate to the
 character.  For example, the value of the character representing
 the equal sign is 3D(hex).





   +------------------------------------------+
   |     0     1     2    3   4   5   6   7   |
   +---+--------------------------------------+
   | 0 | NUL   DLE   SP   0   @   P   `   p   |
   | 1 | SOH   DC1   !    1   A   Q   a   q   |
   | 2 | STX   DC2   "    2   B   R   b   r   |
   | 3 | ETX   DC3   #    3   C   S   c   s   |
   | 4 | EOT   DC4   $    4   D   T   d   t   |
   | 5 | ENQ   NAK   %    5   E   U   e   u   |
   | 6 | ACK   SYN   &    6   F   V   f   v   |
   | 7 | BEL   ETB   '    7   G   W   g   w   |
   | 8 | BS    CAN   (    8   H   X   h   x   |
   | 9 | HT    EM    )    9   I   Y   i   y   |
   | A | LF    SUB   *    :   J   Z   j   z   |
   | B | VT    ESC   +    ;   K   [   k   {   |
   | C | FF    FS    ,    <   L   \   l   |   |
   | D | CR    GS    -    =   M   ]   m   }   |
   | E | SO    RS    .    >   N   ^   n   ~   |
   | F | SI    US    /    ?   O   _   o   DEL |
   +---+--------------------------------------+

 The characters with names are defined as follows:


   NUL   Null             DC1   Device Control 1(XON)
   SOH   Start of         DC2   Device Control 2
           Heading
   STX   Start of Text    DC3   Device Control 3(XOFF)
   ETX   End of Text      DC4   Device Control 4
   EOT   End of           NAK   Negative Acknowledge
           Transmission
   ENQ   Enquiry          SYN   Synchronous Idle
   ACK   Acknowledge      ETB   End of Transmission 
                                  Block
   BEL   Bell             CAN   Cancel
   BS    Backspace        EM    End of Medium
   HT    Horizontal Tab   SUB   Substitute
   LF    Line Feed        ESC   Escape
   VT    Vertical Tab     FS    File Separator
   FF    Form Feed        GS    Group Separator
   CR    Carriage Return  RS    Record Separator
   SO    Shift Out        US    Unit Separator
   SI    Shift In         SP    Space
   DLE   Data Link        DEL   Delete
           Escape
3 DEC_Multinational
 The ASCII character set comprises the first half of the DEC
 Multinational Character Set.  The following table represents the
 second half of the DEC Multinational Character Set (characters with
 decimal values 128 through 255).  These characters cannot be output
 on some older terminals and printers.  Note that the characters
 with names are nonprintable.

 To determine the hexadecimal value of an ASCII character, combine
 the values in the column (8-F) and the row (0-F) that relate to the
 character.  For example, the value of the character representing
 the pound sterling sign is A3(hex).


    +------------------------------------------+
    |     8     9      A   B   C   D   E   F   |
    +---+--------------------------------------+
    | 0 |       DCS        °   À       à       |
    | 1 |       PU1    ¡   ±   Á   Ñ   á   ñ   |
    | 2 |       PU2    ¢   ”   Â   Ò   â   ò   |
    | 3 |       STS    £   “   Ã   Ó   ã   ó   |
    | 4 | IND   CCH            Ä   Ô   ä   ô   |
    | 5 | NEL   MW     ¥   µ   Å   Õ   å   õ   |
    | 6 | SSA   SPA        ¶   Æ   Ö   æ   ö   |
    | 7 | ESA   EPA    §   ·   Ç   ◊   ç   ÷   |
    | 8 | HTS          ¨       È   Ø   è   ø   |
    | 9 | HTJ          ©   ’   É   Ù   é   ù   |
    | A | VTS          ª   º   Ê   Ú   ê   ú   |
    | B | PLD   CSI    «   »   Ë   Û   ë   û   |
    | C | PLU   ST         π   Ì   Ü   ì   ü   |
    | D | RI    OSC        ∏   Í   †   í   ‡   |
    | E | SS2   PM             Î       î       |
    | F | SS3   APC        ¿   Ï   ß   ï       |
    +---+--------------------------------------+

 The characters with names are defined as follows:


   IND   Index            PU1   Private Use 1
   NEL   Next Line        PU2   Private Use 2
   SSA   Start of         STS   Set Transmit State
           Selected Area
   ESA   End of Selected  CCH   Cancel Character
           Area
   HTS   Horizontal Tab   MW    Message Waiting
           Set
   HTJ   Horizontal       SPA   Start of Protected 
           Tab Set with           Area
           Justification
   VTS   Vertical Tab     EPA   End of Protected 
           Set                    Area
   PLD   Partial Line     CSI   Control Sequence 
           Down                   Introducer
   PLU   Partial Line Up  ST    String Terminator
   RI    Reverse Index    OSC   Operating System 
                                  Command
   SS2   Single Shift 2   PM    Privacy Message
   SS3   Single Shift 3   APC   Application
   DCS   Device Control
           String
3 FORTRAN_77_Standard
 The character set specified by the FORTRAN-77 Standard consists of
 the uppercase letters A through Z, the digits 0 through 9, and the
 following special characters:

    SP   (space)                ,    (comma)
    $    (dollar sign)          -    (minus sign)
    '    (apostrophe)           .    (period)
    (    (left parenthesis)     /    (slash)
    )    (right parenthesis)    :    (colon)
    *    (asterisk)             =    (equal sign)
    +    (plus sign)
3 FORTRAN         
 The Fortran character set includes the entire FORTRAN-77 Standard
 set plus the lowercase letters a through z (uppercase and lowercase
 letters are equivalent) and the following special characters:

    !    (exclamation mark)     <Tab> (tab)
    "    (quotation mark)       <     (left angle bracket)
    %    (percent sign)         >     (right angle bracket)
    &    (ampersand)            _     (underscore)

 All printable characters (those in the range 20(hex) through
 7E(hex), or A1(hex) through FE(hex)) can appear in comments,
 character constants, and Hollerith constants.
3 Printable_Characters
 Printable characters include the tab character (09 hex), those
 ASCII characters with codes in the range 20(hex) through 7E(hex),
 and those characters in the DEC Multinational Extension to the
 ASCII Character Set with codes in the range A1(hex) through
 FE(hex).

 Note that printable characters that are not in the Fortran
 character set (see Character_Set subtopic FORTRAN) can only appear
 in comments and character and Hollerith constants.
3 Nonprintable_Characters
 The form-feed character (0C hex) is treated as a blank without
 causing a diagnostic message to be issued.  In addition, a source
 record of length 1 containing a form-feed character causes the
 compilation source listing to begin a new page.

 A source record of length 1 containing a Ctrl-Z character (1A hex)
 is treated as a blank line.  Such a record is created by the
 ENDFILE statement, if the command line option -vms is specified.

 All other control characters are valid, except 00(hex) and 01(hex).

 If you must use a nonprintable character in a character constant,
 use the CHAR intrinsic function, in conjunction with the
 concatenation operator if necessary.  For example:

    CHARACTER*(*) ESC_BRACKET
    PARAMETER (ESC_BRACKET = CHAR(27)//'[')
2 Compatibility_Features
 Digital Fortran 77 provides the following language features to
 facilitate compatibility with other versions of Fortran:

  o  The DEFINE FILE, ENCODE, DECODE, and FIND statements

  o  A NOF77 interpretation of the EXTERNAL statement

  o  Octal forms of integer constants

  o  An alternative syntax for the PARAMETER statement

  o  The VIRTUAL statement

  o  The AND, OR, XOR, IMAG, LSHIFT, and RSHIFT intrinsic functions

  o  An alternative syntax for bit constants

  o  C-style escape sequences

  o  An alternative syntax for a record specifier


 These language features are particularly useful in transporting
 older Fortran programs to systems on Alpha processors.  However,
 you should avoid using them in new programs on these systems, and
 in new programs for which portability to other FORTRAN-77
 implementations is important.
3 DEFINE_FILE           
 The DEFINE FILE statement establishes the size and structure of
 files with relative organization and associates them with a logical
 unit number.  The DEFINE FILE statement is comparable to the OPEN
 statement (in situations where you can use the OPEN statement, it
 is the preferable mechanism for creating and opening files).
 Statement format:

    DEFINE FILE u(m, n, U, asv) [,u(m, n, U, asv)]...

    u    Is an integer constant or variable that specifies the 
         logical unit number.

    m    Is an integer constant or variable that specifies the 
         number of records in the file.

    n    Is an integer constant or variable that specifies the 
         length of each record in 16-bit words (2 bytes).

    U    Specifies that the file is unformatted (binary); this 
         is the only acceptable entry in this position.

    asv  Is an integer variable, called the associated variable 
         of the file.  At the end of each direct access I/O 
         operation, the record number of the next higher numbered 
         record in the file is assigned to "asv"; "asv" must not 
         be a dummy argument.

 The DEFINE FILE statement specifies that a file containing "m"
 fixed-length records, each composed of n 16-bit words, exists (or
 is to exist) on the specified logical unit.  The records in the
 file are numbered sequentially from 1 through "m".

 A DEFINE FILE statement must be executed before the first direct
 access I/O statement referring to the specified file, even though
 the DEFINE FILE statement does not itself open the file.  The file
 is actually opened when the first direct access I/O statement for
 the unit is executed.

 If this I/O statement is a WRITE statement, a direct access
 sequential file is opened, or created if necessary.  If it is a
 READ or FIND statement, an existing file is opened, unless the
 specified file does not exist.  If a file does not exist, an error
 occurs.
3 ENCODE_and_DECODE    
 The ENCODE and DECODE statements transfer data between variables or
 arrays in internal storage.  The ENCODE statement translates data
 from internal (binary) form to character form.  Inversely, the
 DECODE statement translates data from character to internal form.
 These statements are comparable to using internal files in
 formatted sequential WRITE and READ statements, respectively.
 Statement format:

    ENCODE (c,f,b [,IOSTAT=ios] [,ERR=s]) [list]
    DECODE (c,f,b [,IOSTAT=ios] [,ERR=s]) [list]

    c      Is an integer expression.  In the ENCODE statement, 
           "c" is the number of characters (in bytes) to be 
           translated to character form.  In the DECODE statement, 
           "c" is the number of characters to be translated to 
           internal form.
  
    f      Is a format identifier.  An error occurs if more than 
           one record is specified.

    b      Is a scalar or array reference. If b is an array 
           reference, its elements are processed in the 
           order of subscript progression. The data type of "b"
           determines the number of characters that ENCODE or
           DECODE can process.

           In the ENCODE statement, "b" receives the characters 
           after translation to external form.  If less than "c" 
           characters are received, the remaining character
           positions are filled with blank characters. 

           In the DECODE statement, "b" contains the characters 
           to be translated to internal form.

    ios    Is an integer scalar memory reference that is defined 
           as a positive integer if an error occurs, and zero 
           if no error occurs.

    s      Is the label of an executable statement.

    list   Is an I/O list.  

           In the ENCODE statement, the "list" contains the data 
           to be translated to character form.  In the DECODE 
           statement, the "list" receives the data after 
           translation to internal form.

           The interaction between the format specifier and the 
           I/O list is the same as for a formatted I/O statement.
3 FIND                   
 The FIND statement positions a direct access file at a particular
 record and sets the associated variable of the file to that record
 number.  It is comparable to a direct access READ statement with no
 I/O list, and can open an existing file.  No data transfer takes
 place.  Statement format:

    FIND (u'r [,ERR=s] [,IOSTAT=ios])
    FIND ([UNIT=]u, REC=r [,ERR=s] [,IOSTAT=ios])

    u     Is a logical unit number.  It must refer to a
          relative organization file.

    r     Is the direct access record number.  It cannot 
          be less than one or greater than the number of 
          records defined for the file.

    s     Is the label of the executable statement that 
          receives control if an error occurs.

    ios   Is an integer variable or integer array element 
          that is defined as a positive integer if an error 
          occurs, and as a zero if no error occurs.
3 NOF77_EXTERNAL        
 If you specify the -nof77 compiler option, you get an
 interpretation of the EXTERNAL statement that facilitates
 compatibility with older versions of Fortran.  (The ANSI FORTRAN-77
 interpretation is incompatible with the previous standard and
 previous Digital implementations.)

 The NOF77 interpretation combines the functionality of the
 INTRINSIC statement with that of the EXTERNAL statement discussed
 under the Help topic:  Statements EXTERNAL.

 The NOF77 EXTERNAL statement lets you use subprograms as arguments
 to other subprograms.  The subprograms to be used as arguments can
 be either user-supplied procedures or Fortran library functions.
 Statement format:

    EXTERNAL [*]v [,[*]v]...

    v  Is the symbolic name of a subprogram or the name of 
       a dummy argument associated with the symbolic name 
       of a subprogram.

    *  Specifies that a user-supplied function is to be used 
       instead of a Fortran library function having the same 
       name.

 The NOF77 EXTERNAL statement declares that each symbolic name in
 its list is an external procedure name.  Such a name can then be
 used as an actual argument to a subprogram, which in turn can use
 the corresponding dummy argument in a function reference or CALL
 statement.

 However, used as an argument, a complete function reference
 represents a value, not a subprogram name.
3 Octal_Notation        
 Octal forms of integer constants allow compatibility with PDP-11
 FORTRAN.  You must specify the -vms compiler option to use octal
 notation.  Statement format:

    "nn

    nn  Is a string of digits in the range 0 to 7 (for
        example "107).

 Integer constants in octal form have integer data type and are
 treated as integers.
3 PARAMETER              
 This statement is similar to the one discussed in Help topic:
 Statements PARAMETER; they both assign a symbolic name to a
 constant.  However, this PARAMETER statement differs from the other
 one in the following two ways:  its list is not bounded with
 parentheses; and the form of the constant, rather than implicit or
 explicit typing of the symbolic name, determines the data type of
 the variable.  Statement format:

    PARAMETER p=c [,p=c]...

    p  Is a symbolic name.

    c  Is a constant, the symbolic name of a constant, or a 
       compile-time constant expression.
3 VIRTUAL                
 The VIRTUAL statement is included for compatibility with PDP-11
 FORTRAN.  It has the same form and effect as the DIMENSION
 statement (see Help Topic:  Statements DIMENSION).
3 Intrinsic_Functions    
 Digital Fortran 77 allows certain intrinsic functions for
 compatibility with FORTRAN for RISC.  The following list shows
 these functions and their equivalents:

    Function    Equivalent Function
    --------    -------------------
    AND         IAND 
    OR          IOR
    XOR         IEOR
    IMAG        AIMAG and DIMAG
    LSHIFT      ISHFT with a positive second argument
    RSHIFT      ISHFT with a negative second argument
3 Bit_Constant_Syntax      
 Digital Fortran 77 allows the following alternative syntax for
 binary, octal, and hexadecimal constants:

                 Alternative Syntax   Equivalent
                 ------------------   ----------
    Binary       B'0..1'              '0..1'B
    Octal        O'0..7'              '0..7'O
    Hexadecimal  X'0..F' or Z'0..F'   '0..F'X or '0..F'Z

 In all above syntax forms, you can use a quotation mark(") in place
 of an apostrophe (').
3 C-Style_Escape_Sequences
 Digital Fortran 77 allows the following C-style escape sequences in
 character constants, if you do not specify the -vms or -assume
 backslash compiler options:

    Escape Sequence    Represents
    ---------------    ----------
    \n                 A new line
    \t                 A horizontal tab
    \b                 A backspace
    \f                 A formfeed
    \0                 A null character
    \'                 An apostrophe 
    \"                 A quotation mark 
    \\                 A backslash 
    \x                 Any other character (x)
3 Record_Specifier_Syntax
 Digital Fortran 77 allows the following form for a record
 specifier:

    'r

    r  Is a numeric expression with a value that represents 
       the position of the record to be accessed using direct 
       access I/O.  The value must be greater than or equal to 1, 
       and less than or equal to the maximum number of records 
       allowed in the file. If necessary, a record number is 
       converted to integer data type before being used.
2 Data              
 Each constant, variable, array, expression, or function reference
 in a Fortran statement represents typed data.  The data type of
 these items can be inherent in their constructions, implied by
 convention, or explicitly declared.  The data types available in
 Digital Fortran 77 are integer, REAL (REAL*4), DOUBLE PRECISION
 (REAL*8), REAL*16 (Alpha only), COMPLEX (COMPLEX*8), DOUBLE COMPLEX
 (COMPLEX*16), BYTE (equivalent to INTEGER*1), logical, character,
 and Hollerith.

 Constants, variables, arrays, scalar fields, aggregate fields,
 character substrings, and expressions can be specified in many
 places in a Fortran program.  Fortran statements and expressions
 have individual restrictions governing which of these items can
 used in them and in what form.  Thus, to avoid repeatedly
 enumerating lists of the various items that can be specified with
 the various statements and expressions, the items are divided into
 four general categories:  scalar reference, scalar memory
 reference, array name reference, and aggregate reference.  The
 names of these categories are used throughout the DEC Fortran
 Language Reference Manual to identify what can be included in a
 particular statement or expression.
3 Aggregate_Reference  
 An aggregate reference resolves into a reference to a structured
 data item (a record structure or substructure).  For example:

 Data Declarations:

    STRUCTURE /STRA/
        INTEGER  INTFLD, INTFLDARY (10)
    END STRUCTURE
      . . .
    STRUCTURE /STRB/
        CHARACTER*20  CHARFLD
        INTEGER  INTFLD, INTFLDARY (10)
        STRUCTURE STRUCFLD
            COMPLEX  CPXFLD, CPXFLDARY (10)
        END STRUCTURE
        RECORD  /STRA/  RECFLD, RECFLDARY (10)
    END STRUCTURE
      . . .
    RECORD  /STRB/  REC, RECARY (10)

 Reference Examples:

    REC --- A record name
    RECARY(1) --- A record array reference
    REC.RECFLD --- A reference to a substructure
    REC.RECFLDARY(1) --- A reference to a substructure array element
    RECARY(1).RECFLD --- A reference to a substructure in a record
      array element
    RECARY(1).RECFLDARY(1) --- A reference to a substructure array
      element in a record array
3 Arrays               
 An array is a group of contiguous storage locations associated with
 a single symbolic name, the array name.  The individual storage
 locations, called array elements, are referred to by a subscript
 appended to the array name.  An array can have from 1 to 7
 dimensions.  The Fortran statements that establish arrays are:
 type declaration statements, the DIMENSION statement, and the
 COMMON statement.

 The data type of an array is specified in the same way as the data
 type of a variable; either implicitly by the first letter of the
 name or explicitly by a type declaration statement.
4 Declarators        
 An array declarator specifies the symbolic name that identifies an
 array within a program unit and indicates the properties of the
 array.  It has the form:

    a(d[,d]...)   a is the name of the array
                  d specifies the bounds of the array in the form:

                  [dl:]du    dl is the lower bound
                             du is the upper bound
4 Subscripts          
 A subscript qualifies an array name.  A subscript is a list of
 expressions, called subscript expressions, enclosed in parentheses,
 that determine which element in the array is referred to.  The
 subscript is appended to the array name it qualifies.  A subscript
 has the form:

    (s[,s]...)     s is a subscript expression

 A one-dimensional array is stored with its first element in the
 first storage location and its last element in the last storage
 location of the sequence.  A multidimensional array is stored so
 that the leftmost subscripts vary most rapidly.
4 Adjustable_Arrays 
 Adjustable arrays are dummy arguments in subprograms.  The
 dimensions of an adjustable array are determined in the reference
 to the subprogram.

 The array declarator for an adjustable array can contain integer
 variables that are either dummy arguments or variables in a common
 block.

 When the subprogram is entered, each dummy argument used in the
 array declarator must be associated with an actual argument, and
 each variable in a common block used in an array declarator must
 have a defined value.  The dimension declarator is evaluated using
 the values of the actual arguments, variables in common blocks, and
 constants specified in the array declarator.

 Argument association is not retained between one reference to a
 subprogram and the next reference to that subprogram.

 The size of the adjustable array must be less than or equal to the
 size of the array that is its corresponding actual argument.

 You can also declare adjustable arrays in RECORD statements not
 contained within structure declarations.

 To avoid possible errors in subscript evaluation, make sure that
 the bounds expressions used to declare multidimensional adjustable
 arrays match the bounds as declared by the caller.

 In the following example, the function computes the sum of the
 elements of a two-dimensional array.  Notice how the dummy
 arguments M and N control the iteration:

       FUNCTION SUM(A,M,N)
       DIMENSION A(M,N)
       SUM = 0.0
       DO 10 J=1,N
       DO 10 I=1,M
 10    SUM = SUM + A(I,J)
       RETURN
       END

 The following statements are sample calls on SUM:

 DIMENSION A1(10,35), A2(3,56)
 SUM1 = SUM(A1,10,35)
 SUM2 = SUM(A2,3,56)
 SUM3 = SUM(A1,10,10)

 An adjustable array is undefined if a dummy argument array is not
 currently associated with an actual argument array.  It is also
 undefined if any of the variables in the adjustable array
 declarator are either not currently associated with an actual
 argument or not in a common block.

 Digital Fortran 77 also allows the following form for an adjustable
 array:

 SUBROUTINE SUB1(A,B)
 DIMENSION A(B(1))    ! An array element is allowed

 A and B must be dummy arguments; B can be in COMMON.
4 Assumed-Size_Arrays
 An assumed-size array is a dummy array for which the upper bound of
 the last dimension is specified as an asterisk (*), for example:

 SUBROUTINE SUB(A,N)
 DIMENSION A(1:N,1:*)

 If the lower bound of an assumed-size array is not specified, it is
 assumed to be 1.  Therefore, the previous DIMENSION statement is
 equivalent to the following:

 DIMENSION A(1:N,*)

 The size of an assumed-size array and the number of elements that
 can be referenced are determined as follows:

  o  If the actual argument corresponding to the dummy array is a
     name of a noncharacter array, the size of the dummy array is
     the size of the actual-argument array.

  o  If the actual argument corresponding to the dummy argument is a
     name of a noncharacter array element, with a subscript value of
     "s" in an array of size "a", the size of the dummy array is
     "a + 1 - s".

  o  If the actual argument is a name of a character array,
     character array element, or character array element substring
     and begins at character storage unit "b" of an array with n
     character storage units, the size of the dummy array is
     "INT(n + 1 - b)/y", where "y" is the length of an element of
     the dummy array.


 Because the actual size of an assumed-size array is unknown, an
 assumed-size array name cannot be used as any of the following
 items in an I/O statement:

  o  An array name in the I/O list

  o  A unit identifier for an internal file

  o  A run-time format specifier

4 Automatic_Arrays  
 An automatic array is a local array that is created when you enter
 a subprogram.  The dimensions are determined by dummy arguments or
 variables in COMMON when the subprogram is called.  For example:

 SUBROUTINE SUB1(N)
 DIMENSION A(N)      ! Variable A is local

 N must be a dummy argument or it must be in a common block.
3 Array_Name_Reference 
 An array name reference resolves into the name of an array with no
 subscripts after the array name.  For example:

 Data Declarations:

    INTEGER INT, INTARY (10)
      . . .
    STRUCTURE /STRA/
        INTEGER  INTFLD, INTFLDARY (10)
    END STRUCTURE
      . . .
    STRUCTURE /STRB/
        CHARACTER*20  CHARFLD
        INTEGER  INTFLD, INTFLDARY (10)
        STRUCTURE STRUCFLD
            COMPLEX  CPXFLD, CPXFLDARY (10)
        END STRUCTURE
        RECORD  /STRA/  RECFLD, RECFLDARY (10)
    END STRUCTURE
      . . .
    RECORD  /STRB/  REC, RECARY (10)

 Reference Examples:

    INTARY --- Numeric or character array
    RECARY --- Array of records
    REC.INTFLDARY --- Numeric or character array field of a record
    REC.RECFLDARY --- Array of substructures within a record
    RECARY(1).INTFLDARY --- Numeric or character array field of a
      record array element
    RECARY(1).RECFLDARY --- Array of substructures within a record
      array element
3 Constants            
 A constant is a fixed value.  The value of a constant can be a
 numeric value, a logical value, or a character string.  There are
 seven types of constants:  integer, real, complex, bit, logical,
 character, and Hollerith.  Bit and Hollerith constants have no data
 type; they assume a data type that conforms to the context in which
 they are used.
4 Bit             
 A bit constant is a binary, octal, or hexadecimal constant.  You
 can use this type of constant wherever numeric constants are
 allowed and it assumes a numeric data type according to its
 context.

 A binary constant has the form:

   'c1c2c3...cn'B      c is a 0 or 1

 An octal constant has the form:

   'c1c2c3...cn'O      c is a digit in the range 0 - 7

 A hexadecimal constant has the form:

   'c1c2c3...cn'X      c is a digit in the range 0 - 9, or a letter
         or            in the range A - F, or a - f
   'c1c2c3...cn'Z

 Bit constants are "typeless" numeric constants.  They assume data
 types based on their usage, according to the following rules:

  o  When the constant is used with a binary operator, including the
     assignment operator, the data type of the constant is the data
     type of the other operand.

  o  When a specific data type is required, that type is assumed for
     the constant.

  o  When the constant is used as an actual argument, if the bit
     constant is greater than 4 bytes, INTEGER*8 is assumed;
     otherwise, INTEGER*4 is assumed.

  o  When the constant is used in any other context, an INTEGER*4
     data type is assumed (unless the -noi4 or -i8 (Alpha only)
     compiler option specifies otherwise).

4 Character      
 A character constant is a string of printable ASCII characters
 enclosed by delimiters.  It takes one of the following forms:

   'c1,c2,c3...cn'       
   "c1,c2,c3...cn"

    where c is a printable character

 The length of the character constant is the number of characters
 between the delimiters.  In the apostrophe format, two consecutive
 apostrophes represent a single apostrophe.  In the quotation mark
 format, two consecutive quotation marks represent a single
 quotation mark.

 The length of a character constant must be in the range 1 to 2000.
4 Complex        
 A complex constant consists of a pair of real or integer constants.
 The two constants are separated by a comma and enclosed in
 parentheses.  The first constant represents the real part of the
 number and the second constant represents the imaginary part.

 Digital Fortran 77 supports COMPLEX*8 and COMPLEX*16 complex
 constants.

 A COMPLEX (COMPLEX*8) constant has the form:

  (c,c)             c is an integer or REAL (REAL*4) constant

 A DOUBLE COMPLEX (COMPLEX*16) constant has the form:

  (c,c)             c is an integer, REAL (REAL*4), or 
                    DOUBLE PRECISION (REAL*8) constant (at 
                    least one of the pair must be a DOUBLE 
                    PRECISION constant)
4 Hollerith      
 A Hollerith constant is a string of printable characters preceded
 by a character count and the letter H.  It is used only in numeric
 expressions and has the form:

   nHc1c2c3...cn

   n     Is an unsigned, nonzero integer constant stating the
         number of characters in the string (including tabs 
         and spaces)
   c     Is a printable character

 A Hollerith constant can be a string of 1 to 2000 characters and is
 stored as a byte string, one character per byte.

 Hollerith constants have no data type, but assume a numeric data
 type according to the context in which they are used.
4 Integer        
 An integer constant is a whole number with no decimal point.  It
 can have a leading sign and is interpreted as a decimal number.  It
 has the form:

   snn           s  is an optional sign
                 nn is a string of decimal digits (leading
                    zeros are ignored)

 You can use integer constants to assign values to data.  The
 integer data types have the following ranges:

   BYTE         Same range as INTEGER*1

   INTEGER*1    Signed integers: -128 to 127 (-2**7 to 2**7-1)
   (1 byte)     Unsigned integers: 0 to 255 (2**8-1)
   
   INTEGER*2    Signed integers: -32768 to 32767 
   (2 bytes)                     (-2**15 to 2**15-1)
                Unsigned integers: 0 to 65535 (2**16-1)

   INTEGER*4    Signed integers: -2147483648 to 2147483647 
   (4 bytes)                          (-2**31 to 2**31-1)

   INTEGER*8    Signed integers: -9223372036854775808 to 
   (Alpha only)      9223372036854775807 (-2**63 to 2**63-1)
   (8 bytes)
                NOTE: On Alpha processors, the value of an 
                integer constant must be within this range.

 Note that logical data type ranges correspond to their comparable
 integer data type ranges.  For example, the LOGICAL*2 range is the
 same as the INTEGER*2 range.

 The value of an integer constant is normally INTEGER*2, INTEGER*4,
 or INTEGER*8 (Alpha only).  If a value is within INTEGER*2 range,
 it is treated as an INTEGER*2 value; if a value is outside
 INTEGER*2 range, but within INTEGER*4 range, it is treated as an
 INTEGER*4 value, and so forth.
4 Logical        
 The logical constants are .TRUE.  and .FALSE.

 Note that logical data type ranges correspond to their comparable
 integer data type ranges.  For example, the LOGICAL*2 range is the
 same as the INTEGER*2 range.  For more information on integer data
 type ranges, see DATA CONSTANTS INTEGER in this online Help file.
4 REAL            
 A REAL (REAL*4) constant is a basic real constant (with or without
 a decimal exponent) or an integer constant followed by a decimal
 exponent.  A basic real constant has one of these forms:

    s.nn            s is an optional sign
    snn.nn          nn is a string of decimal digits
    snn.

 A decimal exponent has the form:

    Esnn            s is an optional sign
                    nn is an integer constant

 The approximate range of a nonzero REAL constant is 1.175E-38 to
 3.403E38 (S_floating).

 S_floating computational results smaller than 1.17549429E-38 are
 denormalized numbers that gradually underflow and lose precision,
 until they reach approximately 1.40129846E-46.  You cannot write a
 constant for a denormalized number.
4 DOUBLE_PRECISION   
 A DOUBLE PRECISION (REAL*8) constant is a basic real constant or an
 integer constant followed by a decimal exponent.  A decimal
 exponent has the form:

    Dsnnn        s is an optional sign
                 nnn is a string of decimal digits

 NOTE:  Digital Fortran 77 also allows the syntax Qsnnn, if the
 exponent field is within the T_floating double precision range.

 On Digital UNIX systems, the DOUBLE PRECISION data type implements
 the IEEE T_floating format.

 T_floating computational results smaller than
 2.2250738585072012D-308 are denormalized numbers that gradually
 underflow and lose precision, until they reach approximately
 4.9406564584124654D-324.  You cannot write a constant for a
 denormalized number.
4 REAL_16        
 A REAL*16 constant is a basic real constant or an integer constant
 followed by a decimal exponent.  A decimal exponent has the form:

    Qsnn              s is an optional sign
                      nn is a string of decimal digits

 This type of constant is only available on Alpha systems.
3 Expressions          
 An expression represents a single value.  An expression can consist
 of a single constant, variable, record element, array element, or
 function reference; or combinations of these data items plus
 certain other elements, called operators.  Operators specify
 computations to be performed on the values of the data items and a
 single result is obtained.

 Expressions are classified as arithmetic, character, relational, or
 logical.  Arithmetic expressions produce numeric values; character
 expressions produce character values; and relational and logical
 expressions produce logical values.

 The data components of an expression must be compatible and must be
 joined by compatible operators.  Expressions are evaluated one
 operator at a time according to the rules of precedence.  The
 ranking assigned to each data type is as follows:

   Data Type                    Ranking
   ---------                    -------
   BYTE                          1 (lowest)
   LOGICAL*1                     1
   LOGICAL*2                     2
   LOGICAL*4                     3
   LOGICAL*8 (Alpha only)        4
   INTEGER*1                     5
   INTEGER*2                     6
   INTEGER*4                     7
   INTEGER*8 (Alpha only)        8
   REAL (REAL*4)                 9
   REAL*16 (Alpha only)         10
   DOUBLE PRECISION (REAL*8)    11
   COMPLEX (COMPLEX*8)          12
   DOUBLE COMPLEX (COMPLEX*16)  13 (highest)
4 Arithmetic  
 Arithmetic expressions contain numeric data such as variables,
 record elements, array elements, constants, function references,
 and arithmetic expressions enclosed in parentheses.  The expression
 evaluates to a numeric value.  The numeric operators are as
 follows:

      Operator    Ranking     Description
      -------------------------------------------------
         **        1          exponentiation (evaluated
                                  right to left)
         *         2          multiplication
         /         2          division 
         +         3          addition
         -         3          subtraction        

 You can use parentheses to force an order of evaluation.
4 Character   
 Character expressions consist of character elements and character
 operators.  Evaluation of a character expression yields a single
 value of character data type.  A character element may be a
 constant, variable, record element, array element, substring,
 expression (optionally enclosed in parentheses), or a function
 reference.

 A character expression has the form:

   character element[//character element]...

 The concatenation operator (//) is the only character operator.
 Concatenation is from left to right.
4 Logical     
 Logical expressions may contain logical and integer data such as
 variables, record elements, array elements, constants, function
 references, expressions enclosed in parentheses, and relational
 expressions.  The expression evaluates to a logical value using the
 following operators:


       OPERATOR         PRECEDENCE
       **               First (Highest)
       *,/              Second
       +,-,//           Third
       Relational
         Operators      Fourth
       .NOT.            Fifth
       .AND.            Sixth
       .OR.             Seventh
       .XOR.            Eighth (Lowest)
       .NEQV.           Eighth
       .EQV.            Eighth
4 Relational  
 Relational expressions consist of either two arithmetic or two
 character expressions separated by relational operators.  The
 expression is reduced to a logical value (true or false).

       OPERATOR      DESCRIPTION
        .LT.          Less than
        .LE.          Less than or equal to
        .EQ.          Equal to
        .NE.          Not equal to
        .GT.          Greater than
        .GE.          Greater than or equal to

 Expressions of COMPLEX data type can use only .EQ. and .NE.
 operators.
3 Records              
 A record is a named data entity, consisting of one or more fields,
 which you can use when you need to declare and operate on
 multi-field data structures in your programs.

 To create a record, you must have a structure declaration (to
 describe the fields in the record) and a RECORD statement to
 establish the record in memory.
4 Examples            
 Structure APPOINTMENT:

    Structure /APPOINTMENT/       
      RECORD /DATE/             APP_DATE
      STRUCTURE /TIME/          APP_TIME (2)
          LOGICAL*1             HOUR, MINUTE
      END STRUCTURE
      CHARACTER*20              APP_MEMO (4)
      LOGICAL*1                 APP_FLAG
    END STRUCTURE

 The following statement results in the creation of both a variable
 named NEXT_APP and a 10-element array named APP_LIST.  Both the
 variable and each element of the array have the form of the
 structure APPOINTMENT.

    RECORD /APPOINTMENT/ NEXT_APP,APP_LIST(10)

 The following examples illustrate aggregate and scalar field
 references.

 Aggregate:

   NEXT_APP                ! the record NEXT_APP
   NEXT_APP.APP_TIME(1)    ! an array field of the variable
                           ! NEXT_APP
   APP_LIST(3).APP_DATE    ! a 4-byte array field in the record array
                           ! APP_LIST(3)

 Scalar:

   NEXT_APP.APP_FLAG       ! a LOGICAL field of the record
                           ! NEXT_APP

   NEXT_APP.APP_MEMO(1)(1:1)
                           ! The first character of APP_MEMO(1),
                           ! a character*20 field of the record
                           ! NEXT_APP
4 Field_References    
 Fields within a record may be accessed collectively or
 individually.  Record references are either qualified or
 unqualified.

 A qualified reference refers to a typed data item and can be used
 wherever an ordinary variable is allowed.  Type conversion rules
 are the same as for variables.  Its form is:
    rname[.cfname...cfname].afname

 Unqualified references refer to a record structure or substructure
 and can be used (in most cases) like arrays, for example:
    rname[.cfname...cfname]

    rname    Is the name used in the RECORD statement to 
             identify a record.

    cfname   Is a substructure field name within the record 
             identified by record-name.

    afname   Is the name of a typed data item within a structure 
             declaration.
3 Scalar_Reference     
 A scalar reference is a scalar variable, scalar record field, array
 element, constant, character substring, or expression that resolves
 into a single, typed data item.  For example:

 Data Declarations:

    INTEGER INT, INTARY (10)
      . . .
    STRUCTURE /STRA/
        INTEGER  INTFLD, INTFLDARY (10)
    END STRUCTURE
      . . .
    STRUCTURE /STRB/
        CHARACTER*20  CHARFLD
        INTEGER  INTFLD, INTFLDARY (10)
        STRUCTURE STRUCFLD
            COMPLEX  CPXFLD, CPXFLDARY (10)
        END STRUCTURE
        RECORD  /STRA/  RECFLD, RECFLDARY (10)
    END STRUCTURE
      . . .
    RECORD  /STRB/  REC, RECARY (10)

 Reference Examples:

    INT --- Numeric variable
    INTARY(1) --- Numeric array element
    REC.INTFLD --- Numeric field
    REC.INTFLDARY(1) --- Numeric element of an array field
    CHARVAR(5:10) --- Substring expression of a character variable
    REC.CHARFLD(5:10) --- Substring expression of a character field

 Note:  A scalar memory reference is the same as a scalar reference,
 excluding constants, character substrings, and expressions.
3 Substrings           
 A character substring is a contiguous segment of a character
 variable, character array element, or character field reference.
 It has one of the following forms:

    v([e1]:[e2])  OR  a(s[,s]...)([e1]:[e2]) 

    v    Is a character variable name
    a    Is a character array name
    s    Is a subscript expression
    e1   Is a numeric expression specifying the leftmost
         character position of the substring
    e2   Is a numeric expression specifying the rightmost
         character position of the substring
 NOTE:
   1 .LE. e1 .LE. e2 .LE. length-of-v must hold true
3 Types                
 The Fortran data types are as follows:

  o  Integer - a whole number

  o  REAL (REAL*4) - a single-precision floating point number (a
     whole number or a decimal fraction or a combination)

  o  DOUBLE PRECISION (REAL*8) - a double-precision floating point
     number (like REAL*4, but with twice the degree of accuracy in
     its representation)

  o  REAL*16 (Alpha only) - a quad precision floating point number
     (like REAL*4, but with four times the degree of accuracy in its
     representation.)

  o  COMPLEX (COMPLEX*8) - a pair of REAL*4 values representing a
     complex number (the first part of the number is the real part,
     the second is the imaginary part)

  o  COMPLEX*16 (DOUBLE COMPLEX) - like complex, but with twice the
     degree of accuracy in its representation (its real or imaginary
     part must be a REAL*8)

  o  Logical - a logical value, .TRUE.  or .FALSE.

  o  Character - a sequence of characters

  o  BYTE - equivalent to INTEGER*1

4 Character 
 A character string is a contiguous sequence of bytes in memory.  A
 character string is specified by two attributes:  the address of
 the first byte of the string and the length of the string in bytes.
 The length of the string must be in the range 1 through 65535.

 Hollerith constants are stored internally, one character per byte.
4 COMPLEX   
 Real and complex numbers are floating-point representations.

 COMPLEX (COMPLEX*8) data is eight contiguous bytes aligned on an
 arbitrary byte boundary.  The low-order four bytes contain REAL
 (REAL*4) data that represents the real part of the complex number.
 The high-order four bytes contain REAL data that represents the
 imaginary part of the complex number.  For information on the
 ranges of REAL data, see REAL (within the Data Constants section of
 Help).

 DOUBLE COMPLEX (COMPLEX*16) data is 16 contiguous bytes aligned on
 an arbitrary byte boundary.  The low-order bytes contain DOUBLE
 PRECISION (REAL*8) data that represents the real part of the
 complex number.  The high-order eight bytes contain DOUBLE
 PRECISION data that represents the imaginary part of the complex
 data.  For information on the ranges of DOUBLE PRECISION data, see
 DOUBLE_PRECISION (within the Data Constants section of Help).
4 Integer   
 The integer data types have the following ranges:

   BYTE         Same range as INTEGER*1

   INTEGER*1    Signed integers: -128 to 127 (-2**7 to 2**7-1)
   (1 byte)     Unsigned integers: 0 to 255 (2**8-1)
   
   INTEGER*2    Signed integers: -32768 to 32767 
   (2 bytes)                     (-2**15 to 2**15-1)
                Unsigned integers: 0 to 65535 (2**16-1)

   INTEGER*4    Signed integers: -2147483648 to 2147483647 
   (4 bytes)                          (-2**31 to 2**31-1)

   INTEGER*8    Signed integers: -9223372036854775808 to 
   (Alpha only)      9223372036854775807 (-2**63 to 2**63-1)
   (8 bytes)
                NOTE: On Alpha processors, the value of an 
                integer constant must be within this range.

 INTEGER*2, INTEGER*4, and INTEGER*8 values are stored in two's
 complement form.

 Note that logical data type ranges correspond to their comparable
 integer data type ranges.  For example, the LOGICAL*2 range is the
 same as the INTEGER*2 range.

 The value of an integer constant is normally INTEGER*2, INTEGER*4,
 or INTEGER*8 (Alpha only).  If a value is within INTEGER*2 range,
 it is treated as an INTEGER*2 value; if a value is outside
 INTEGER*2 range, but within INTEGER*4 range, it is treated as an
 INTEGER*4 value, and so forth.
4 Logical   
 Logical values start on an arbitrary byte boundary and are stored
 in one, two, or four contiguous bytes.  The low-order bit (bit 0)
 determines the value.  If bit 0 is set, the value is .TRUE.; if bit
 0 is clear, the value is .FALSE.  The remaining bits are undefined.

 When a logical value is stored in memory, all of its bits are
 stored.  For example, consider the following:

    LOGICAL*4 L1, L2, L3
    L1 = L2 .AND. L3

 This example does a full 32-bit AND of L2 and L3, and stores all 32
 resulting bits in L1.
4 REAL      
 Real and complex numbers are floating-point representations.

 The exponent for REAL (REAL*4) (S_floating) and DOUBLE PRECISION
 (REAL*8) (T_floating) formats is stored in binary excess 128
 notation.  Binary exponents from -127 to 127 are represented by the
 binary equivalents of 1 through 255.

 For floating-point format, fractions are represented in
 sign-magnitude notation, with the binary radix point to the left of
 the most significant bit.  Fractions are assumed to be normalized,
 and therefore the most significant bit is not stored.  This bit is
 assumed to be 1 unless the exponent is 0.  in which case the value
 represented is either zero or is a reserved operand.

 REAL (REAL*4) (S_floating) numbers occupy four contiguous bytes and
 the precision is approximately one part in 2**23, that is,
 typically 7 decimal digits.

 DOUBLE PRECISION (REAL*8) (T_floating) numbers occupy eight
 contiguous bytes and the precision is approximately one part in
 2**55, that is, typically 16 decimal digits.

 On Alpha systems, REAL*16 (H_floating) numbers occupy sixteen
 contiguous bytes and the precision is approximately 2**112, that
 is, typically 33 decimal digits.

 For more information on real data type ranges, see DATA CONSTANTS
 REAL and DATA CONSTANTS DOUBLE_PRECISION in this online Help file.
3 Variables            
 A variable is represented by a symbolic name which is associated
 with a storage location.  The value of the variable is the value
 currently stored in that location; the value can be changed by
 assigning a new value to the variable.

 Variables, like constants, are classified by data type.  When data
 of any type is assigned to a variable, it is converted, if
 necessary, to the data type of the variable.  You can establish the
 data type of a variable by type declaration statements, IMPLICIT
 statements, or predefined typing rules.
4 Implication        
 In the absence of either IMPLICIT statements or explicit type
 statements, all variables with names beginning with I, J, K, L, M,
 or N are assumed to be integer variables.  Variables beginning with
 any other letter are assumed to be REAL (REAL*4) variables.
4 Specification       
 Type declaration statements explicitly define the data type of
 variables.

 Numeric type declaration statements have the form:

    type v[/clist][,v[/clist]]...

    type    Is any data type except CHARACTER
    v       Is the name of a constant, variable, array, statement
            function or function subprogram, or array declarator
    clist   Is a list of constants

 Character type declaration statements have the form:

    CHARACTER[*len[,]] v[*len] [/clist/] [,v[*len] [/clist/]]...

    len     An unsigned integer constant, an integer constant 
            expression enclosed in parentheses, or an asterisk 
            enclosed in parentheses.  The value of "len" specifies 
            the length of the character data elements.

    v       The symbolic name of a constant, variable, array, 
            statement function or function subprogram, or array 
            declarator.  The name can optionally be followed by 
            a data type length specifier (*n).  For character 
            entities, the length specifier can be *len or *(*).

    clist   An initial value or values to be assigned to the 
            immediately preceding variable or array element.
2 Error_Messages  
3 Compilation        
 Compiler diagnostic messages have the following format:

   fort: severity: file-line:message_text

   fort          Identifies the source as the Digital Fortran 77 
                 compiler
   severity      Possibilities: fatal, severe, error, warning, or
                 informational
   file-line     Indicates the source file and line number in the 
                 source file
   message_text  Explains the event that caused the message
4 Fatal_Messages
 Must be corrected before the program can be compiled.  Compilation
 stops at the point where the fatal error is encountered.  An object
 file is not produced (linking does not occur).

 The fatal messages follow (in alphabetical order):

  o  MESSAGE:  Adjustable array used in invalid context

     EXPLANATION:  A reference to an adjustable array was made in a
     context where such a reference is not allowed.

  o  MESSAGE:  Aggregate reference where scalar reference required

     EXPLANATION:  An aggregate reference was used where a scalar
     reference was required.

  o  MESSAGE:  Alternate return label used in invalid context

     EXPLANATION:  An alternate return argument cannot be used in a
     function reference.

  o  MESSAGE:  Alternate return specifier invalid in FUNCTION
     subprogram

     EXPLANATION:  The argument list of a FUNCTION declaration
     contains an asterisk, or a RETURN statement in a function
     subprogram specifies an alternate return.  The following
     example shows a FUNCTION declaration that contains an asterisk:

        INTEGER FUNCTION TCB(ARG,*,X)

     The following example shows a RETURN statement in a function
     subprogram that specifies an alternate return.

        FUNCTION IMAX
          .
          .
          .
        RETURN I

  o  MESSAGE:  Arithmetic expression where character value required

     EXPLANATION:  An expression that must be of type CHARACTER was
     of another data type.

  o  MESSAGE:  Assumed size array name used in invalid context

     EXPLANATION:  An assumed-size array name was used in a context
     in which the size of the array was required, for example, in an
     I/O list.

  o  MESSAGE:  Automatic class variable not permitted here

     EXPLANATION:  Specified automatic variable cannot be used in
     this context.

  o  MESSAGE:  Case expression value used previously

     EXPLANATION:  More than one CASE statement has used the logical
     value .TRUE. or .FALSE. in a SELECT CASE construct.  For
     example:

        LOGICAL L
        SELECT CASE (L)
        CASE (.TRUE.)
          J=3
        CASE (.TRUE.)
          K=7
        ENDSELECT

  o  MESSAGE:  CASE or ENDSELECT statement must follow SELECT CASE
     statement

     EXPLANATION:  A statement other than a CASE statement (or END
     SELECT or INCLUDE) directly follows a SELECT CASE statement.
     This usually means that a CASE statement is missing.  For
     example:

        SELECT CASE (I)
          J=5
        CASE (6)
          J=6
        END SELECT

  o  MESSAGE:  CASE value/range overlaps previous CASE value/range

     EXPLANATION:  The value, or range of values, in this CASE
     statement overlaps a previous value, or range of values, within
     the set of CASE statements belonging to the current SELECT CASE
     construct.  The program must be modified so that the values do
     not overlap.  For example:

        SELECT CASE (I)
        CASE (0:20)
          X=3.0
        CASE (15:30)
          Y=5.0
        END SELECT

     The two ranges (0:20) and (15:30) must be modified so they do
     not overlap.

  o  MESSAGE:  Character expression where arithmetic value required

     EXPLANATION:  An expression that must be arithmetic (INTEGER,
     REAL, LOGICAL, or COMPLEX) was of type CHARACTER.

  o  MESSAGE:  Character substring limits out of order

     EXPLANATION:  The first character position of a substring
     expression was greater than the last character position.  For
     example:

        C(5:3)

  o  MESSAGE:  Conflicting values for xxx

     EXPLANATION:  Command line error.  For example:

        $ f77 -convert vaxg -convert ibm  x.f

     Only one -convert value may be specified.

  o  MESSAGE:  Compiler expression stack overflow

     EXPLANATION:  An expression was too complex or too many actual
     arguments were included in a subprogram reference.  A maximum
     of 255 actual arguments can be compiled.  You can subdivide a
     complex expression or reduce the number of arguments.

  o  MESSAGE:  Construct names must match on DO and ENDDO statements

     EXPLANATION:  Either there is a missing construct name, or the
     construct names do not agree for matching DO and ENDDO
     statements.  Several examples:

        FOO: DO I=1,10
        ...
        ENDDO BAR   ! BAR does not match FOO

        DO J=1,20   ! There is no construct name to match 
        ...         !       UNMATCHED (on the ENDDO)
        ENDDO UNMATCHED

        EXTRA: DO K=1,30
        ...
        ENDDO       ! There is no construct name to match EXTRA

  o  MESSAGE:  DO or IF statement incorrectly nested

     EXPLANATION:  One of the following conditions was encountered:

        - A statement label specified in a DO statement was used 
          previously. For example:

            10    I = I + 1
                  J = J + 1
                  DO 10 K=1,10

        - A DO loop contains an incomplete DO loop or IF block.
          For example:

                  DO 10 I=1,10
                      J = J + 1
                      DO 20 K=1,10
                          J = J + K
            10    CONTINUE

          The start of the incomplete IF block can be a block IF, 
          ELSE IF, or ELSE statement:

                  DO 10 I=1,10
                      J = J + I
                      IF (J .GT. 20) THEN J = J - 1
                      ELSE J = J + 1
            10    CONTINUE
                      END IF

  o  MESSAGE:  DO and IF statements nested too deeply

     EXPLANATION:  DO loops and block IF statements cannot be nested
     beyond 128 levels.

  o  MESSAGE:  Duplicated keyword in I/O statement

     EXPLANATION:  Each keyword subparameter in an I/O statement or
     auxiliary I/O statement can be specified only once.

  o  MESSAGE:  END [STRUCTURE|UNION|MAP] must match top

     EXPLANATION:  A STRUCTURE, UNION, or MAP statement did not have
     a corresponding END STRUCTURE, END UNION, or END MAP statement,
     respectively.

  o  MESSAGE:  ENTRY dummy variable previously used in executable
     statement

     EXPLANATION:  The dummy arguments of an ENTRY statement were
     not used in a previous executable statement in the same program
     unit.

  o  MESSAGE:  EQUIVALENCE statement incorrectly expands a common
     block

     EXPLANATION:  An EQUIVALENCE statement cannot cause a common
     block to be extended back past the first element specified in
     the COMMON statement.

  o  MESSAGE:  Error limit exceeded; compilation terminated

     EXPLANATION:  The number of error-level and fatal-error errors
     has reached the limit given in -error_limit nn (or the default
     of 30 errors).  Recompile with a larger -error_limit value or
     correct the errors displayed up to the point of termination and
     then recompile.

  o  MESSAGE:  EXIT or CYCLE statement must be within the scope of
     some DO loop

     EXPLANATION:  A simple CYCLE or EXIT statement occurred outside
     the scope of any DO loop.  Since these statements are used to
     increment or exit the nearest enclosing DO loop, this is an
     error.

  o  MESSAGE:  Fatal BE error

     EXPLANATION:  Internal error related to error code passing
     between the compiler front end and back end.  Submit an SPR.

  o  MESSAGE:  Field name not defined for this structure

     EXPLANATION:  A field name not defined in a structure was used
     in a qualified reference.

  o  MESSAGE:  Format specifier in error

     EXPLANATION:  The format specifier in an I/O statement was
     invalid.  It must be one of the following:

        - Label of a FORMAT statement
        - Asterisk (*) in a list-directed I/O statement
        - Run-time format specifier: variable, array element, 
          or character substring reference
        - Integer variable that was assigned a FORMAT label 
          by an ASSIGN statement

  o  MESSAGE:  INCLUDE files nested too deeply

     EXPLANATION:  A maximum of 10 levels of nested INCLUDE files
     are allowed.

  o  MESSAGE:  Inconsistent function data types

     EXPLANATION:  The function name and entry points in a function
     subprogram must be consistent within one of three groups of
     data types:

        Group 1: All numeric types except COMPLEX*16
        Group 2: COMPLEX*16
        Group 3: Character

        Example:

           CHARACTER*15 FUNCTION I
           REAL*4 G
           ENTRY G

  o  MESSAGE:  Inconsistent use of statement label

     EXPLANATION:  Labels of executable statements were confused
     with labels of FORMAT statements or with labels of
     nonexecutable statements.  For example:

            GO TO 10
        10  FORMAT (I5)

  o  MESSAGE:  Incorrect keyword in OPEN, CLOSE, or INQUIRE
     statement

     EXPLANATION:  An OPEN, CLOSE, or INQUIRE statement contained a
     keyword that was not valid for that statement.

  o  MESSAGE:  Incorrect length modifier in declaration

     EXPLANATION:  An unacceptable length was specified in a data
     type declaration.  For example:

        INTEGER PIPES*8

  o  MESSAGE:  Internal error, xxxxxxxxxxx

     EXPLANATION:  Internal error.  The xxxxxxxxx is replaced by
     information about the error.  Submit an SPR.

  o  MESSAGE:  Invalid argument to %VAL, %REF or %LOC

     EXPLANATION:  The argument specified for one of the built-in
     functions was not valid.  For example:

        %VAL (3.5D0) - Error: Argument cannot be REAL*8,
                       character, or complex. 
        %LOC (X+Y)   - Error: Argument must not be an expression.

  o  MESSAGE:  Invalid ASSIGN variable

     EXPLANATION:  Attempted to use an ASSIGN variable in an invalid
     context, such as trying to assign a value to a pointer
     variable.  For example:

        POINTER (P,A)
        ASSIGN 1 TO P
        GOTO P

  o  MESSAGE:  Invalid control structure using CASE or END SELECT

     EXPLANATION:  A CASE statement or an ENDSELECT statement
     occurred without an initial SELECT CASE statement, or was used
     in some other incomplete context that makes it invalid.  For
     example:

        SELECT CASE (J)
        CASE (5)
          K=2
        IF (I.GT.0) THEN
        ENDSELECT
        ELSE
        CASE (6)
          K=3
        ENDSELECT                       

  o  MESSAGE:  Invalid control structure using ELSE IF, ELSE, or END
     IF

     EXPLANATION:  The order of ELSE IF, ELSE, or END IF statements
     was incorrect.

     ELSE IF, ELSE, and END IF statements cannot stand alone.  ELSE
     IF and ELSE must be preceded by either a block IF statement or
     an ELSE IF statement.  END IF must be preceded by either a
     block IF, ELSE IF, or ELSE statement.  For example:

        DO 10 I=1,10
          J = J + I
          ELSE IF (J .LE. K) THEN

     Error:  The ELSE IF is preceded by a DO statement

        IF (J .LT. K) THEN J = I + J
        ELSE
            J = I - J
        ELSE IF (J .EQ. K) THEN
        END IF

     Error:  The ELSE IF is preceded by an ELSE statement

  o  MESSAGE:  Invalid DO parameters in implied-DO list

     EXPLANATION:  An invalid control parameter was detected in an
     implied-DO list in a DATA statement;for example, an increment
     of zero.

  o  MESSAGE:  Invalid equivalence of two variables in common

     EXPLANATION:  Variables in common blocks cannot be equivalenced
     to each other.

  o  MESSAGE:  Invalid I/O list element for input statement

     EXPLANATION:  An input statement I/O list contained an invalid
     element, such as an expression or a constant.

  o  MESSAGE:  Invalid I/O specification for this type of I/O
     statement

     EXPLANATION:  A syntax error was found in the portion of an I/O
     statement that precedes the I/O list.  For example:

        TYPE (6), J
        WRITE 100, J

  o  MESSAGE:  Invalid keyword for this type of I/O statement

     EXPLANATION:  An I/O statement contained a keyword that cannot
     be used with that type of I/O statement.

  o  MESSAGE:  Invalid NAMELIST element

     EXPLANATION:  A dummy argument or element other than variable
     or array name appeared in a NAMELIST declaration.

  o  MESSAGE:  Invalid operation in implied-DO list

     EXPLANATION:  An invalid operation was attempted in an
     implied-DO list in a DATA statement, for example, a function
     reference in the subscript or substring expression of an array
     or character substring reference.  For example:

        DATA (A(SIN(REAL(I))), I=1,10) /101./

  o  MESSAGE:  Invalid reference to name in implied-DO list

     EXPLANATION:  A control parameter expression in an implied-DO
     list in a DATA statement contained a name that was not the name
     of a control variable within the scope of any implied-DO list.
     For example:

        DATA (A(J), J=1,10),(B(I), I=J,K) /1001./

     Both J and K in the second implied-DO list are invalid names.

  o  MESSAGE:  Invalid use of function name in CALL statement

     EXPLANATION:  A CALL statement referred to a subprogram name
     that was used as a CHARACTER or COMPLEX*16 function.  For
     example:

        IMPLICIT CHARACTER*10(C)
        CSCAL = CFUNC(X)
        CALL CFUNC(X)

  o  MESSAGE:  Invalid use of record or array name

     EXPLANATION:  A statement in the program violated one of the
     following rules:

        - An aggregate cannot be assigned to a nonaggregate or to 
          an aggregate with a structure that is not the same.
        - An array name reference cannot be qualified.
        - Aggregate references cannot be used in I/O lists of 
          formatted I/O statements.

  o  MESSAGE:  Label in ASSIGN statement exceeds INTEGER*2 range

     EXPLANATION:  A label whose value is assigned to an INTEGER*2
     variable by an ASSIGN statement must not be separated by more
     than 32K bytes from the beginning of the code for the program
     unit.

  o  MESSAGE:  Left side of assignment must be variable or array
     element

     EXPLANATION:  The symbolic name to which the value of an
     expression is assigned must be a variable, array element, or
     character substring reference.

  o  MESSAGE:  Low bound exceeds high bound in CASE range

     EXPLANATION:  The INTEGER or CHARACTER CASE statement contains
     a range where the lower bound is greater than the upper bound.
     For example:

        CASE (30:20)

        CASE ('OMEGA':'ALPHA')

  o  MESSAGE:  Missing constant

     EXPLANATION:  A required constant was not found.

  o  MESSAGE:  Missing keyword

     EXPLANATION:  A required keyword, such as TO, was omitted from
     a statement such as ASSIGN 10 TO I.

  o  MESSAGE:  Missing operator or delimiter symbol

     EXPLANATION:  Two terms of an expression were not separated by
     an operator, or a punctuation mark (such as a comma) was
     omitted.  For example:

        CIRCUM = 3.14  DIAM     ! * is missing
        IF  (I   10,20,30       ! ) is missing

  o  MESSAGE:  Missing or invalid use of UNIT or FILE specifier in
     INQUIRE statement

     EXPLANATION:  An INQUIRE statement must have a UNIT specifier
     or a FILE specifier, but not both.

  o  MESSAGE:  Missing statement label

     EXPLANATION:  A required statement label reference was omitted.

  o  MESSAGE:  Missing variable or constant

     EXPLANATION:  An expression or a term of an expression was
     omitted.  For example:

        WRITE ( )
        DIST = *TIME

  o  MESSAGE:  Missing variable or subprogram name

     EXPLANATION:  A required variable name or subprogram name was
     not found.

  o  MESSAGE:  Multiple declaration of name

     EXPLANATION:  A name appeared in two or more inconsistent
     declaration statements or a dummy argument was specified in an
     EQUIVALENCE statement.

  o  MESSAGE:  Multiple use of DEFAULT CASE statement

     EXPLANATION:  There is more than one CASE DEFAULT statement in
     this SELECT CASE construct.  For example:

        SELECT CASE (I)
        CASE DEFAULT 
          J=4
        CASE (5)
          K=5
        CASE DEFAULT
          L=6
        END SELECT

  o  MESSAGE:  Multiply defined field name

     EXPLANATION:  Each field name within the same level of a given
     structure declaration must be unique.

  o  MESSAGE:  Multiply defined STRUCTURE name

     EXPLANATION:  A STRUCTURE name must be unique among STRUCTURE
     names.

  o  MESSAGE:  Name previously used with conflicting data type

     EXPLANATION:  A data type was assigned to a name that had
     already been used in a context that required a different data
     type.

  o  MESSAGE:  No digits in octal (or hex) notation integer constant

     EXPLANATION:  An incorrectly formed octal or hex constant has
     been detected, possibly because the user intended -novms to use
     " as a character constant delimiter instead of an octal
     constant delimiter.  The constant should be corrected or the
     proper switch used.

  o  MESSAGE:  No enclosing DO loop begins with this construct name

     EXPLANATION:  There is a construct name used in either a CYCLE
     or EXIT statement that does not appear on a DO statement for
     any enclosing loop.  In particular, if there are no loops at
     all, the error will be generated for:

        CYCLE FOO

        EXIT BAR

  o  MESSAGE:  Nonconstant subscript where constant required

     EXPLANATION:  Subscript and substring expressions used in DATA
     and EQUIVALENCE statements must be constants.

  o  MESSAGE:  Non-integer expression where integer value required

     EXPLANATION:  An expression that must be of type integer was of
     some other data type.

  o  MESSAGE:  Non-logical expression where logical value required

     EXPLANATION:  An expression that must have a LOGICAL data type
     has another data type.

  o  MESSAGE:  No source file specified

     EXPLANATION:  A command line was entered that specified only
     library file names and no source files to compile.

  o  MESSAGE:  Number of subscripts does not match array declaration

     EXPLANATION:  Too many or too few dimensions than were declared
     for the array were referenced.

  o  MESSAGE:  Only one of:  xxx, xxx, xxx may be specified

     EXPLANATION:  Command line error.  For example:

        $ f77 -call_shared -non_shared x.f

     Only one of the following options can be used at a time:
     -call_shared, -non_shared, or -shared.

  o  MESSAGE:  Open failure on INCLUDE file

     EXPLANATION:  The specified file could not be opened, possibly
     due to an incorrect file specification, nonexistent file,
     unmounted volume, or a protection violation.

  o  MESSAGE:  Operation not permissible on these data types

     EXPLANATION:  An invalid operation was specified, such as an
     .AND.  of two real variables.

  o  MESSAGE:  Passed-length character name used in invalid context

     EXPLANATION:  A reference to a passed-length character array or
     variable was made in a context where such a reference is not
     allowed.

  o  MESSAGE:  Program storage requirements exceed addressable
     memory

     EXPLANATION:  The storage space allocated to the variables and
     arrays of the program unit exceeded the addressing range of the
     machine.

  o  MESSAGE:  Range not allowed for CASE of type logical

     EXPLANATION:  In a CASE statement of type logical, the user has
     specified a "range" of values.  A range is valid only in a CASE
     statement of type INTEGER or CHARACTER.  For example:

        LOGICAL L
        SELECT CASE (L)
        CASE (.TRUE.:.FALSE.)
          I=15
        ENDSELECT

     Possibly the program intended CASE (.TRUE.,.FALSE) instead.

  o  MESSAGE:  Requested source is not available on ULTRIX

     EXPLANATION:  The program attempted to use one of the following
     VAX FORTRAN I/O features that are not available on ULTRIX or
     Digital UNIX systems, such as using the DICTIONARY statement or
     using an INCLUDE statement for a text module from a library
     file.

  o  MESSAGE:  Statement cannot appear in logical IF statement

     EXPLANATION:  A logical IF statement must not contain a DO
     statement or another logical IF, IF THEN, ELSE IF, ELSE, END
     IF, or END statement.

  o  MESSAGE:  Statement not allowed within structure; structure
     definition closed

     EXPLANATION:  A statement not allowed in a structure
     declaration block was encountered.  When this situation occurs,
     the compiler assumes that you omitted one or more END STRUCTURE
     statements.

  o  MESSAGE:  Statement too complex

     EXPLANATION:  A statement was too complex to be compiled.  It
     must be subdivided into two or more statements.

  o  MESSAGE:  Structure field is missing a field name

     EXPLANATION:  Unnamed fields are not allowed.  The effect of an
     unnamed field can be achieved by using %FILL in place of a
     field name in a typed data declaration.

  o  MESSAGE:  Structure name in RECORD statement not defined

     EXPLANATION:  Either a RECORD statement did not contain a
     structure name enclosed within slashes or the structure name
     contained in a RECORD statement was not defined in a structure
     declaration.

  o  MESSAGE:  STRUCTUREs/UNIONs/MAPs nested too deeply

     EXPLANATION:  The combined nesting level limit for structures,
     unions, and maps is 20 levels.

  o  MESSAGE:  Subqualifier not allowed with negated qualifier

     EXPLANATION:  A negated qualifier specified on the command line
     also specified subqualifier values; for example:  -nocheck
     underflow.

  o  MESSAGE:  Subscripted reference to non-array variable

     EXPLANATION:  A variable that is not defined as an array cannot
     appear with subscripts.

  o  MESSAGE:  Syntax error in implied-DO

     EXPLANATION:  Improper syntax was detected in an implied-DO
     list in data initialization, for instance, improperly nested
     parentheses.

  o  MESSAGE:  Syntax error in INCLUDE file specification

     EXPLANATION:  The file-name string was not acceptable (invalid
     syntax, invalid qualifier, undefined device, and so on).

  o  MESSAGE:  Syntax error in I/O list

     EXPLANATION:  Improper syntax was detected in an I/O list.

  o  MESSAGE:  This language feature is not supported on this system

     EXPLANATION:  Attempted to use an unsupported feature.  Such
     features may be supported by Digital Fortran 77 but are not
     available on this platform (for example, the %DESCR built-in
     function).  See your user manual for information about Digital
     Fortran 77 compatibility.

  o  MESSAGE:  Too many named common blocks

     EXPLANATION:  Digital Fortran 77 allows a maximum of 250 named
     common blocks.  You must reduce the number in your program.

  o  MESSAGE:  Unclosed DO loop, IF block, or SELECT CASE

     EXPLANATION:  The terminal statement of a DO, IF, or SELECT
     CASE statement was not found.  For example:

        DO 20 I=1,10
          X = Y
        END

  o  MESSAGE:  Undefined statement label

     EXPLANATION:  A reference was made to a statement label that
     was not defined in the program unit or a nonexecutable
     statement label was used where an executable statement label
     was required.

  o  MESSAGE:  Undimensioned array or statement function definition
     out of order

     EXPLANATION:  Either a statement function definition was found
     among executable statements or an assignment statement
     involving an undimensioned array was found.

  o  MESSAGE:  Unit specifier keyword missing in I/O statement

     EXPLANATION:  An I/O statement must include a unit specifier
     subparameter.

  o  MESSAGE:  Unrecognized statement

     EXPLANATION:  The statement encountered was not recognized as
     valid.

  o  MESSAGE:  Variable inconsistently equivalenced to itself

     EXPLANATION:  EQUIVALENCE statements specified inconsistent
     relationships between variables or array elements.  For
     example:

        EQUIVALENCE (A(1), A(2))

  o  MESSAGE:  Variable name, constant, or expression invalid in
     this context

     EXPLANATION:  An entity was used incorrectly; for example, the
     name of a subprogram was used where an arithmetic expression
     was required.

4 Severe_Messages
 Must be corrected before the program can be compiled.  An object
 file is not produced (linking does not occur).

 The severe messages follow (in alphabetical order):

  o  MESSAGE:  Implied DO loop increment is 0

     EXPLANATION:  The value of the implied DO loop increment was
     zero.

  o  MESSAGE:  This DATA implied-DO list name must be subscripted

     EXPLANATION:  In a DATA statement, an implied DO loop referred
     to a variable missing a subscript.  For example:

        INTEGER A(10)
        DATA (A,I=3,5) /3*20/

     The correct use for this example is DATA (A(I),I=3,5) /3*20/.

4 Error_Messages
 Must be corrected before the program can be compiled.  An object
 file is not produced (linking does not occur).

 The error messages follow (in alphabetical order):

  o  MESSAGE:  Adjustable array bound contains invalid data item

     EXPLANATION:  A dimension declarator expression for an
     adjustable array contained an operand other than a constant,
     variable in a common block, or variable associated with a
     subprogram dummy argument.

  o  MESSAGE:  Alternate return omitted in SUBROUTINE or ENTRY
     statement

     EXPLANATION:  An asterisk was missing in the argument list of a
     subroutine for which an alternate return was specified.  For
     example:

        ENTRY ABC(Q,R)
           .
           .
           .
        RETURN 1

  o  MESSAGE:  Arithmetic error while evaluating constant or
     constant expression

     EXPLANATION:  The specified value of a constant was too large
     or too small to be represented.

  o  MESSAGE:  Character name incorrectly initialized with numeric
     value

     EXPLANATION:  A character data item with a length greater than
     one was initialized with a numeric value in a DATA statement.
     For example:

        CHARACTER*4 A
        DATA A/14/

  o  MESSAGE:  Character scalar memory reference or array required
     for internal files

     EXPLANATION:  Attempted use of internal file I/O using a type
     of variable that is not valid.  For more information, see your
     DEC Fortran user manual.

  o  MESSAGE:  Constant in format item out of range

     EXPLANATION:  A numeric value in a FORMAT statement exceeds the
     allowable range.  See the DEC Fortran Language Reference Manual
     for information about range limits.

  o  MESSAGE:  Declaration of globally visible name conflicts with a
     previous declaration

     EXPLANATION:  The name specified in a PROGRAM, BLOCK DATA,
     COMMON, ENTRY, FUNCTION, or SUBROUTINE statement has already
     been used.  For instance, a COMMON block has the same name as
     an external routine.

  o  MESSAGE:  ENDDO cannot close both labeled (line !UL) and
     unlabeled (line !UL) DO statements.

     EXPLANATION:  A labeled ENDDO statement was found that ended
     both a labeled and an unlabeled DO statement.  This is
     corrected by inserting a separate ENDDO statement before the
     labeled ENDDO to close the innermost unlabeled DO statement.

     For example, consider the following:

           DO 100 I=1, 10 
             DO J=1, 20 
               IARRAY(J,I) = 0 
     100   ENDDO 
     ......^ 
     %FORT-E-INVENDDO, ENDDO cannot close both labeled (line 1) and 
     unlabeled (line 2) DO statements. 
           END

     The code can be corrected as follows:

           DO 100 I=1, 10
        DO J=1, 20
            IARRAY(J,I) = 0
             ENDDO
     100   ENDDO
           END

  o  MESSAGE:  ENTRY within DO loop or IF block

     EXPLANATION:  An ENTRY statement is not allowed within the
     range of a DO loop or IF block.

  o  MESSAGE:  Extra characters following a valid statement

     EXPLANATION:  Superfluous text was found at the end of a
     syntactically correct statement.  Check for typing or syntax
     errors.

  o  MESSAGE:  Extra number in format list

     EXPLANATION:  A format list contained an extraneous number.
     For example:

        FORMAT (I4,3)

  o  MESSAGE:  Feedback file does not match current program, in
     routine !AD

     EXPLANATION:  The information in the feedback file cannot be
     correlated with the current program.  Confirm that the same
     compiler options were passed with this compilation as were
     passed for the -gen_feedback compilation.  Also confirm that
     the program and any included files have not changed.

  o  MESSAGE:  Feedback file not found !AD

     EXPLANATION:  Either no feedback file was named or it cannot be
     found.  Confirm that the syntax of the f77 command was correct.
     Also confirm that the correct file was passed.

  o  MESSAGE:  Format groups nested too deeply

     EXPLANATION:  Format groups cannot be nested beyond eight
     levels.

  o  MESSAGE:  Format item cannot be signed

     EXPLANATION:  A signed constant is valid only with the P format
     code.

  o  MESSAGE:  Format item contains meaningless character

     EXPLANATION:  An invalid character or a syntax error was
     detected in a FORMAT statement.

  o  MESSAGE:  Global offset table is full for module !AD.  Object
     file not created.

     EXPLANATION:  The number of address constants in the module
     exceeded a system threshold.  For more information, see the
     Digital UNIX Assembly Language Guide.

  o  MESSAGE:  Inconsistent statement function reference

     EXPLANATION:  The actual arguments in a statement function
     reference did not agree in either order, number, or data type
     with the formal arguments declared.

  o  MESSAGE:  Intrinsic function !AD not allowed in !AD

     EXPLANATION:  The IARGCOUNT and IARGPTR intrinsic functions are
     not allowed in the MAIN program and BLOCK DATA.  The IARGPTR
     function is also not allowed in statement functions.

  o  MESSAGE:  Invalid ASSOCIATEVARIABLE specification

     EXPLANATION:  An ASSOCIATEVARIABLE specification in an OPEN or
     DEFINE FILE statement was a dummy argument or an array element.

  o  MESSAGE:  Invalid character after a backslash

     EXPLANATION:  In a character literal, the character specified
     after the backslash (\) was not one of the allowable characters
     (such as \n for new line) used to produce a nonprinting
     character.  For information on the allowable characters for
     C-style escape sequences, see the DEC Fortran Language
     Reference Manual.

  o  MESSAGE:  Invalid character used in constant

     EXPLANATION:  An invalid character was detected in a constant.
     Only the characters 0-9, A-F, and a-f are valid for hexadecimal
     constants.  The entire hexadecimal constant is set to zero.

  o  MESSAGE:  Invalid format for feedback file

     EXPLANATION:  The file passed as a feedback file did not have
     the expected format.  Confirm that the correct file was passed.
     Try recreating the file using the steps discussed in the f77(1)
     reference page.

  o  MESSAGE:  Invalid repeat count in data initialization, count
     ignored

     EXPLANATION:  The repeat count in a data initialization was not
     an unsigned, nonzero integer constant.  When this error is
     encountered, the count is ignored.

  o  MESSAGE:  Invalid use of intrinsic function name as actual
     argument

     EXPLANATION:  A generic intrinsic function name was used as an
     actual argument.

  o  MESSAGE:  I/O list not permitted with namelist I/O

     EXPLANATION:  An I/O statement with a namelist specifier
     incorrectly contained an I/O list.

  o  MESSAGE:  Missing apostrophe in character constant

     EXPLANATION:  A character constant must be enclosed in
     apostrophes.

  o  MESSAGE:  Missing exponent after E, D, or Q

     EXPLANATION:  A floating-point constant was specified in E, D,
     or Q notation, but the exponent was omitted.

  o  MESSAGE:  Missing number in format list

     EXPLANATION:  An expected number was missing from a format
     list.  For example:

        FORMAT (F6.)

  o  MESSAGE:  Missing separator between format items

     EXPLANATION:  A required separator character was omitted
     between fields in a FORMAT statement.

  o  MESSAGE:  Missing variable or common name

     EXPLANATION:  A name of a variable or a common block that is
     required by a compiler directive statement or a VOLATILE
     statement was omitted.

  o  MESSAGE:  More than 7 dimensions specified

     EXPLANATION:  An array can be defined as having up to seven
     dimensions.

  o  MESSAGE:  Multiple definition of statement label

     EXPLANATION:  The same label appeared on more than one
     statement.  When this error is encountered, the first
     occurrence of the label is used.

  o  MESSAGE:  Nonstandard operation

     EXPLANATION:  One of the following operations was detected:

        - Logical operand and a nonlogical operand were used 
          in the same operation.
        - Real type expression and a complex type expression 
          were used in the same statement.
        - Character operand and a noncharacter operand were 
          used in the same operation.
        - Nonlogical expression was assigned to a logical 
          variable.
        - Noncharacter expression was assigned to a character 
          variable.
        - Character dummy argument appeared in a concatenation 
          operation and the result of the expression was not 
          assigned to a character variable.
        - Logical operators were used with nonlogical operands.
        - Arithmetic operators were used with nonnumeric operands.

  o  MESSAGE:  Outer level structure is missing a structure name

     EXPLANATION:  An outer level STRUCTURE statement must have a
     structure name in order for a RECORD statement to be able to
     reference the structure declaration.

  o  MESSAGE:  Preprocessor record:  error opening specified file

     EXPLANATION:  Internal information from cpp is not in the
     correct format.  This could be caused by a pound sign (#)
     character in column 1 of the Fortran source code that is not a
     cpp directive or internal information from cpp.

  o  MESSAGE:  Preprocessor record file spec misspelled

     EXPLANATION:  Internal information from cpp is not in the
     correct format, possibly caused by a pound sign (#) character
     in column 1 of the Fortran source code that is not a cpp
     directive or internal information from cpp.

  o  MESSAGE:  Preprocessor record line number not integer

     EXPLANATION:  Internal information from cpp is not in the
     correct format, possibly caused by a pound sign (#) character
     in column 1 of the Fortran source code that is not a cpp
     directive or internal information from cpp.

  o  MESSAGE:  Preprocessor record missing file spec

     EXPLANATION:  Internal information from cpp is not in the
     correct format, possibly caused by a pound sign (#) character
     in column 1 of the Fortran source code that is not a cpp
     directive or internal information from cpp.

  o  MESSAGE:  Preprocessor record missing line number

     EXPLANATION:  Internal information from cpp is not in the
     correct format, possibly caused by a pound sign (#) character
     in column 1 of the Fortran source code that is not a cpp
     directive or internal information from cpp.

  o  MESSAGE:  Recursive routine defined; recursive option required

     EXPLANATION:  An ENTRY point was defined that had been previous
     called within the function or subroutine.  This is only allowed
     when the recursive option is used.  For example:

        INTEGER FUNCTION IFUNC (I)
        IFUNC = IFUNCA(I-1)
        RETURN
        ENTRY IFUNCA (I)        ! This line causes the error
        IFUNCA = I * 100
        RETURN
        END

  o  MESSAGE:  Recursive routine referenced; recursive option
     required

     EXPLANATION:  The function or entry was referenced recursively.
     This is only allowed when the recursive option is used.  For
     example:

        INTEGER FUNCTION FACT (N)
        IF(N .EQ. 1) THEN 
          FACT = N
          RETURN
        ENDIF
        FACT = N*FACT(N-1)        ! This line causes the error
        RETURN

  o  MESSAGE:  Statement not allowed within structure definition

     EXPLANATION:  A statement not allowed in a structure
     declaration block was encountered.  Structure declaration
     blocks can only include the following statements:  typed data
     declaration statements, RECORD statements, UNION/END UNION
     statements, MAP/END MAP statements, and STRUCTURE/END STRUCTURE
     statements.

  o  MESSAGE:  Statement not valid in this program unit

     EXPLANATION:  A program unit contained a statement that is not
     allowed; for example, a BLOCK DATA subprogram containing an
     executable statement.

  o  MESSAGE:  Statement out of order

     EXPLANATION:  The order of statements was invalid.  When this
     error is encountered, the statement found to be out of order is
     ignored.

  o  MESSAGE:  Subscript or substring expression value out of bounds

     EXPLANATION:  An array element beyond the specified dimensions
     or a character substring outside the specified bounds was
     referenced.

  o  MESSAGE:  Substring reference used in invalid context

     EXPLANATION:  A substring reference to a variable or array that
     is not of type character was detected.  For example:

        REAL X(10)
        Y = X(J:K)

  o  MESSAGE:  Syntax error in IMPLICIT statement

     EXPLANATION:  Improper syntax was used in an IMPLICIT
     statement.

  o  MESSAGE:  Too many continuation lines

     EXPLANATION:  You cannot use more than 99 continuation lines.

  o  MESSAGE:  Unbalanced parentheses in format list

     EXPLANATION:  The number of right parentheses must match the
     number of left parentheses.

  o  MESSAGE:  Undimensioned array reference or scalar is
     subscripted

     EXPLANATION:  The variable appearing in a DATA statement or
     namelist has not been dimensioned, yet appears with a
     subscript.

  o  MESSAGE:  Unknown keyword value

     EXPLANATION:  The specified keyword value is not valid.  For
     more information, see the DEC Fortran Language Reference
     Manual.

  o  MESSAGE:  Untyped name, must be explicitly typed

     EXPLANATION:  The displayed name was not defined in any data
     type declaration statement, and an IMPLICIT NONE statement was
     specified.  Check that the name was not accidentally created by
     an undetected syntax error.  For example:

        DO 10 I = 1.10

     The apparent DO statement is really an assignment to the
     accidentally created variable DO10I.

  o  MESSAGE:  %VAL or %REF used in invalid context

     EXPLANATION:  The argument list built-in functions %VAL and
     %REF cannot be used outside an actual argument list.  For
     example:

        X = %REF(Y)

  o  MESSAGE:  Variable cannot be reinitialized (xxxx)

     EXPLANATION:  Attempted to initialize a variable more than
     once, such as in a DATA statement.

  o  MESSAGE:  Zero-length string

     EXPLANATION:  The length specified for a character or Hollerith
     constant must not be zero.

4 Warning_Messages
 Should be investigated by checking the statements to which warning
 diagnostic messages refer.  Warnings are issued for statements that
 use acceptable, but nonstandard, syntax and for statements
 corrected by the compiler.  An object file is produced, but the
 program results may be incorrect.

 Warning messages are produced unless you specify the -w or -nowarn
 option on the f77 command line.

 The warning messages follow (in alphabetical order):

  o  MESSAGE:  Actual argument data type (actual_type) not equal to
     routine's dummy argument type (dummy_type)

     EXPLANATION:  A mismatch was detected between an actual
     parameter type and the dummy type in the called routine.  This
     may be caused by a programming error which needs to be
     corrected.  For example:

        CALL FOO ( 1.5 )
        ...
        SUBROUTINE FOO ( X )
        DOUBLE PRECISION X

     Since the 1.5 is a REAL number (not DOUBLE PRECISION), this can
     result in a variety of problems, depending upon the passing
     mechanism of the system.  In this case the "1.5" should be
     changed to "1.5D0".

  o  MESSAGE:  Alignment of common block is inconsistent with
     previous declaration

     EXPLANATION:  Occurs when using CDEC$ OPTIONS/ALIGN if same
     COMMON is declared in multiple pieces within a single
     compilation unit and /ALIGN has changed between pieces.  For
     example:

        CDEC$ OPTIONS /ALIGN=COMMON=NATURAL
              COMMON /COM1/ A,B    ! common elements are 
                                   !        naturally aligned
        CDEC$ END OPTIONS

        CDEC$ OPTIONS /ALIGN=COMMON=PACKED
              COMMON /COM1/ C,D    ! common elements are packed
        CDEC$ END OPTIONS
        END

  o  MESSAGE:  Argument data type error, not equal to the routine's
     dummy argument type

     EXPLANATION:  A mismatch was detected between an actual
     parameter type and the dummy type in the called routine.  This
     can be caused by a programming error which needs to be
     corrected.

  o  MESSAGE:  Error limit exceeded; compilation terminated

     EXPLANATION:  The number of error-level and fatal-error errors
     has reached the limit given in -errorlimit nn (or the default
     of 30 errors).  Recompile with a larger -errorlimit value or
     correct the errors displayed up to the point of termination and
     then recompile.

  o  MESSAGE:  Alignment of variable or array is inconsistent with
     its data type

     EXPLANATION:  Scalar or array data cannot be naturally aligned
     when alignment had been requested (-align xxxx) option),
     possibly because of an EQUIVALENCE statement.  See your DEC
     Fortran user manual for alignment information.

  o  MESSAGE:  Arguments incompatible with intrinsic function,
     assumed EXTERNAL

     EXPLANATION:  A function reference was made using an intrinsic
     function name, but the argument list does not agree in order,
     number, or type with the intrinsic function requirements.  When
     this error is encountered, the function is assumed to be
     supplied by you as an EXTERNAL function.

  o  MESSAGE:  Assignment to DO variable within loop

     EXPLANATION:  The control variable of a DO loop was altered
     within the range of a DO statement.

  o  MESSAGE:  CDEC$ OPTIONS directives nested too deeply - this one
     ignored

     EXPLANATION:  CDEC$ OPTIONS directives cannot be nested beyond
     100 levels.

  o  MESSAGE:  Constant size exceeds variable size in data
     initialization

     EXPLANATION:  A constant used for data initialization was
     larger than its corresponding variable.

  o  MESSAGE:  Count of Hollerith constant too large, reduced

     EXPLANATION:  The value specified by the integer preceding the
     H was greater than the number of characters remaining in the
     source statement.

  o  MESSAGE:  EQUIVALENCE may not be used to put a SAVE variable
     into COMMON

     EXPLANATION:  You cannot use an EQUIVALENCE statement to put
     variables declared with the SAVE statement into a COMMON data
     block.  For example:

         common/c1/ a,b,c
         dimension x(3)
         save x
         equivalence (x(1),a)
         end

     In this case, the SAVE statement is ignored.

  o  MESSAGE:  Expression does not contribute to result

     EXPLANATION:  Part of a concatenated character string
     expression is beyond the number of characters required to
     completely fill the assignment.  In the following example, TEST
     will not be used:

        CHARACTER NEW, OLD, TEST
        NEW(1:10) = OLD(1:10)//TEST

  o  MESSAGE:  Extra characters in source line were truncated

     EXPLANATION:  The compiler read a source line with a statement
     field that exceeds the maximum column width.  The compiler
     truncates such lines at column 72 or 132, depending on the
     value of -extend_source or the OPTIONS statement option in
     effect.

  o  MESSAGE:  Extra comma in format list

     EXPLANATION:  A format list contained an extra comma.  For
     example:

        FORMAT (I4,)

  o  MESSAGE:  Inconsistent declaration for an AUTOMATIC variable

     EXPLANATION:  Data declared as automatic (AUTOMATIC statement
     or -automatic option) can not be made equivalent to another
     variable using a EQUIVALENCE statement, nor can it be
     initialized using a DATA statement or any data declaration
     statement (such as REAL or INTEGER statement that gives it a
     value).

  o  MESSAGE:  Invalid END= keyword, ignored

     EXPLANATION:  The END keyword was used illegally in a WRITE or
     direct access READ statement.

  o  MESSAGE:  Invalid initialization of variable not in common

     EXPLANATION:  An attempt was made in a BLOCK DATA subprogram to
     initialize a variable that was not in a common block.

  o  MESSAGE:  Invalid statement label ignored

     EXPLANATION:  An improperly formed statement label (namely, a
     label containing letters) was detected in columns 1 to 5 of an
     initial line.  When this error is encountered, the statement
     label is ignored.

  o  MESSAGE:  Length specified must match CHARACTER FUNCTION
     declaration

     EXPLANATION:  The length specifications for all ENTRY names in
     a character function subprogram must be the same.  For example:

        CHARACTER*15 FUNCTION F
        CHARACTER*20 G
        ENTRY G

  o  MESSAGE:  Letter mentioned twice in IMPLICIT statement, last
     type used

     EXPLANATION:  A letter was given an implicit data type more
     than once.  When this error is encountered, the last data type
     given is used.

  o  MESSAGE:  Lower bound greater than upper bound in array
     declaration

     EXPLANATION:  The upper bound of a dimension declarator must be
     equal to or greater than the lower bound.

  o  MESSAGE:  Missing END statement, END is assumed

     EXPLANATION:  An END statement was missing at the end of the
     last input file.  When this error is encountered, an END
     statement is inserted.

  o  MESSAGE:  Multiple declaration of data type for variable, first
     type used

     EXPLANATION:  A variable appeared in more than one data type
     declaration statement.  When this error is encountered, the
     first type declaration is used.

  o  MESSAGE:  Name longer than 31 characters

     EXPLANATION:  A symbolic name cannot exceed 31 characters.
     When this error is encountered, the symbolic name is truncated
     to 31 characters.

  o  MESSAGE:  Name used in INTRINSIC statement is not an intrinsic
     function

     EXPLANATION:  A function name that appeared in the INTRINSIC
     statement was not an intrinsic function.

  o  MESSAGE:  No matching CDEC$ END OPTIONS for CDEC$ OPTIONS

     EXPLANATION:  A CDEC$ OPTIONS directive must be terminated by
     CDEC$ END OPTIONS.

  o  MESSAGE:  No matching CDEC$ OPTIONS for CDEC$ END OPTIONS

     EXPLANATION:  A CDEC$ END OPTIONS directive terminates a CDEC$
     OPTIONS section.

  o  MESSAGE:  Non-blank characters truncated in string constant

     EXPLANATION:  A character or Hollerith constant was converted
     to a data type that was not large enough to contain all of the
     significant characters.

  o  MESSAGE:  Non-zero digits truncated in hex constant

     EXPLANATION:  A hexadecimal constant was converted to a data
     type that was not large enough to contain all the significant
     digits.

  o  MESSAGE:  No value

     EXPLANATION:  A value returned by a function is undefined.

  o  MESSAGE:  Number of names exceeds number of values in data
     initialization

     EXPLANATION:  The number of constants specified in a DATA
     statement must match the number of variables or array elements
     to be initialized.  When a mismatch occurs, any extra variables
     or array elements are not initialized.

  o  MESSAGE:  Number of values exceeds number of names in data
     initialization

     EXPLANATION:  The number of variables or array elements to be
     initialized must match the number of constants specified in
     data initialization.  When a mismatch occurs, any extra
     constant values are ignored.

  o  MESSAGE:  Pointer and integer declarations conflict, using
     pointer declaration

     EXPLANATION:  If a pointer variable is also declared to be an
     integer of specific size (for example, INTEGER*4), and if a
     pointer requires a different size on this platform (for
     example, INTEGER*8 on Digital UNIX on Alpha systems), the
     required pointer size is used instead of the integer size.
     This may affect COMMON sizes and equivalenced variables.

  o  MESSAGE:  Program may contain only one main entry routine

     EXPLANATION:  Two or more main program units were found,
     possibly caused by missing FUNCTION or SUBROUTINE statements.

  o  MESSAGE:  Record contains one or more misaligned fields

     EXPLANATION:  One or more fields are not naturally aligned in a
     RECORD structure because the -vms or -align norecords option
     was specified (causing Digital Fortran 77 to pack records
     instead of naturally aligning them).

  o  MESSAGE:  Record too long - record truncated

     EXPLANATION:  Source file line exceeded the maximum line
     length.

  o  MESSAGE:  Redundant continuation mark ignored

     EXPLANATION:  A continuation mark was detected where an initial
     line is required.  When this error is encountered, the
     continuation mark is ignored.

  o  MESSAGE:  Statement cannot terminate a DO loop

     EXPLANATION:  The terminal statement of a DO loop cannot be a
     GO TO, arithmetic IF, RETURN, block IF, ELSE, ELSE IF, END IF,
     DO, or END statement.

  o  MESSAGE:  String constant truncated to maximum length

     EXPLANATION:  A character or Hollerith constant can contain up
     to 2000 characters.

  o  MESSAGE:  String too long - truncated to 31 characters

     EXPLANATION:  A character constant specified in a CDEC$ TITLE,
     CDEC$ SUBTITLE, or CDEC$ IDENT directive exceeded 31
     characters.  The truncated character value will be used.

  o  MESSAGE:  This feature is unsupported on ULTRIX

     EXPLANATION:  The program attempted to use a VAX FORTRAN I/O
     feature that is not available on ULTRIX or Digital UNIX
     systems.  If the resulting program is run on either system,
     this construct will be ignored.  See your DEC Fortran user
     manual for information on VAX FORTRAN compatibility.

  o  MESSAGE:  This intrinsic routine name is not supported on this
     system, assumed EXTERNAL

     EXPLANATION:  The specified intrinsic name is not known and is
     assumed to be EXTERNAL.

  o  MESSAGE:  Unexpected Hollerith constant in integer context,
     integer value will be used

     EXPLANATION:  A Hollerith constant was specified in a context
     where an integer value was expected.

  o  MESSAGE:  Use of implicit with declaration warnings

     EXPLANATION:  An IMPLICIT statement was used in a program
     compiled with the -warn declarations option.

  o  MESSAGE:  Value for xxx out of range, defaulting to xxx

     EXPLANATION:  Command line error.  For example:

        $ f77 -O15 x.f

     The range of values allowed for -O is 0-4.  15 is out of range.
     The default value of 4 is used instead.

  o  MESSAGE:  Variable is used before its value has been defined

     EXPLANATION:  The specified variable has not been assigned a
     value before it is used in an assignment or similar statement.

     You can disable this message by compiling with -warn
     nouninitialized.

  o  MESSAGE:  Volatile access appears unaligned, but must be
     aligned at run-time

     EXPLANATION:  The compiler found a usage of a volatile data
     item that is an unaligned reference.  This kind of volatile
     unaligned access may cause an unrecoverable alignment fault or
     incorrect results.  For example:

        common /b/ c, s, l
        character c
        integer*2 s
        integer*4 l
        volatile s, l

        l=2

     The store to l is unaligned.  The fix is to change the data
     layout so that l is aligned properly.

4 Informational_Messages
 Not an error message and does not call for corrective action.
 However, the informational message informs you that either a
 correct Digital Fortran 77 statement may have unexpected results or
 you have used a Digital Fortran 77 extension to FORTRAN-77.

 The informational messages follow (in alphabetical order):

  o  MESSAGE:  Character or Hollerith constant continued across
     lines; may be non-portable

     EXPLANATION:  If you need long character strings that don't fit
     conveniently on a single line, use the concatenate operator
     (//) to do it in a portable manner.  For example:

           A = 'ABC' //
          x 'DEF'

  o  MESSAGE:  Default STATUS='UNKNOWN' used in OPEN statement

     EXPLANATION:  The OPEN statement default STATUS='UNKNOWN' may
     cause an old file to be inadvertently modified.

  o  MESSAGE:  Do loop increment is 0

     EXPLANATION:  The value of the DO loop increment was zero.

  o  MESSAGE:  Duplicate IDENT ignored

     EXPLANATION:  Two or more CDEC$ IDENT directives were used in a
     source module to specify the identification field of the object
     module.  The first CDEC$ IDENT directive is used.

  o  MESSAGE:  Extension to FORTRAN-77:  arithmetic expression
     required

     EXPLANATION:  A logical expression was used in an arithmetic IF
     statement.

  o  MESSAGE:  Extension to FORTRAN-77:  CHARACTER*(*) argument used
     as function

     EXPLANATION:  A formal argument used as a function was declared
     as CHARACTER*(*).  The FORTRAN-77 standard requires the length
     to be an integer constant.

  o  MESSAGE:  Extension to FORTRAN-77:  Character required

     EXPLANATION:  A character variable was initialized with a
     noncharacter value by means of a DATA statement.

  o  MESSAGE:  Extension to FORTRAN-77:  COMMON block has same name
     as PARAMETER constant

     EXPLANATION:  A COMMON block was declared to have the same name
     as a PARAMETER constant, or a PARAMETER constant was declared
     to have the same name as a previously declared COMMON block.

  o  MESSAGE:  Extension to FORTRAN-77:  Concatenation of dummy
     argument

     EXPLANATION:  A character dummy argument appeared as an operand
     in a concatenation operation.

  o  MESSAGE:  Extension to FORTRAN-77:  DATA statement out of order

     EXPLANATION:  A DATA statement occurred prior to a declaration
     statement.  All DATA statements must occur after the
     declaration section of a program.

  o  MESSAGE:  Extension to FORTRAN-77:  Function or Entry name
     undefined

     EXPLANATION:  A value was not assigned to either the function
     name or the entry point name within the body of the function.

  o  MESSAGE:  Extension to FORTRAN-77:  Integer expression required

     EXPLANATION:  One of the following items was not of type
     integer:

        - Logical unit number
        - Record specifier, REC=recspec
        - Arithmetic expression of a computed GOTO statement
        - RETURN [I]
        - Subscript expression
        - Array dimension bounds
        - Character substring bounds expressions

  o  MESSAGE:  Extension to FORTRAN-77:  Logical expression required

     EXPLANATION:  One of the following syntax extensions was
     detected:

        - Numeric expression in a logical IF statement
        - Numeric expression in a block IF statement
        - Value other than .TRUE. or .FALSE. assigned to a 
          logical variable
        - Logical variable initialized with a nonlogical value 
          by means of a DATA statement

  o  MESSAGE:  Extension to FORTRAN-77:  Missing array subscripts

     EXPLANATION:  Only one subscript was used to reference a
     multidimensional array in an EQUIVALENCE statement.

  o  MESSAGE:  Extension to FORTRAN-77:  Mixed numeric and character
     elements in COMMON

     EXPLANATION:  A common block must not contain both numeric and
     character data.

  o  MESSAGE:  Extension to FORTRAN-77:  Mixed numeric and character
     elements in EQUIVALENCE

     EXPLANATION:  A numeric variable or numeric array element
     cannot be equivalenced to a character variable or character
     array element.

  o  MESSAGE:  Extension to FORTRAN-77:  More than 19 continuation
     lines

     EXPLANATION:  More than 19 continuation lines were defined for
     the statement.

  o  MESSAGE:  Extension to FORTRAN-77:  Negative implied-DO
     iteration count

     EXPLANATION:  The iteration count of an implied DO was
     negative.

  o  MESSAGE:  Extension to FORTRAN-77:  Nonstandard array bound

     EXPLANATION:  An error was found in a DIMENSION statement
     during standards syntax checking (-stand syntax).  One of the
     bounds of the variable being dimensioned contains something
     that is not allowed by the standard.  For example:

       subroutine foo (a,jjj)
       dimension jjj(10,10)
       dimension a(jjj(2,3), jjj(5,6))

     The bounds for a (jjj(2,3) and jjj(5,6)) are array references,
     and these are not allowed by the standard.

  o  MESSAGE:  Extension to FORTRAN-77:  Nonstandard branch into
     block

     EXPLANATION:  A nonstandard branch into a DO loop or IF block
     was detected.

  o  MESSAGE:  Extension to FORTRAN-77:  nonstandard list directed
     internal I/O

     EXPLANATION:  A nonstandard list-directed internal read or
     write statement was used.

  o  MESSAGE:  Extension to FORTRAN-77:  nonstandard comment

     EXPLANATION:  FORTRAN-77 allows only the characters "C" and "*"
     to begin a comment line; "c", "D", "d", and "!" are extensions
     to FORTRAN-77.

  o  MESSAGE:  Extension to FORTRAN-77:  nonstandard constant

     EXPLANATION:  The following constant forms are extensions to
     FORTRAN-77:

        Form                     Example
        ----                     -------
        Hollerith                nH.....
        Typeless                 'xxxx'X or 'oooo'O
        Hexadecimal              Zxxxx
        Complex with 
           PARAMETER components
        COMPLEX*16              (www.xxxDn, yyy.zzzDn)

  o  MESSAGE:  Extension to FORTRAN-77:  nonstandard continuation
     character

     EXPLANATION:  A nonstandard character was used as a
     continuation indicator.

  o  MESSAGE:  Extension to FORTRAN-77; nonstandard data type
     specification

     EXPLANATION:  The following DATA type specifications are
     extensions to FORTRAN-77.  The FORTRAN-77 equivalent is given
     where available.  This message is issued when these types are
     used in the IMPLICIT statement or in a numeric type statement.

        Extension       Standard
        ---------       --------
        BYTE               --
        LOGICAL*1          --
        LOGICAL*2       LOGICAL (with -noi4 specified)
        LOGICAL*4       LOGICAL
        INTEGER*1          --
        INTEGER*2       INTEGER (with -noi4 specified)
        INTEGER*4       INTEGER
        REAL*4          REAL
        REAL*8          DOUBLE PRECISION
        COMPLEX*8       COMPLEX
        COMPLEX*16         --
        DOUBLE COMPLEX     --

  o  MESSAGE:  Extension to FORTRAN-77:  Nonstandard DATA
     initialization

     EXPLANATION:  An element was initialized in either of the
     following ways:

        - In a blank common block
        - Outside the BLOCK DATA structure (and the element 
          is in a named COMMON block)

  o  MESSAGE:  Extension to FORTRAN-77:  nonstandard FORMAT
     statement item

     EXPLANATION:  The following format field descriptors are
     extensions to FORTRAN-77:

        Descriptor      Aspect
        ----------      ------
            $           All forms
        A,L,I,F,E,G,D   Default field width forms
            P           Without scale factor

  o  MESSAGE:  Extension to FORTRAN-77:  Nonstandard function return
     type

     EXPLANATION:  A function or entry point was declared with a
     nonstandard data type.

  o  MESSAGE:  Extension to FORTRAN-77:  nonstandard intrinsic
     function

     EXPLANATION:  A nonstandard intrinsic function was used.

  o  MESSAGE:  Extension to FORTRAN-77:  nonstandard keyword

     EXPLANATION:  A nonstandard keyword was used.

  o  MESSAGE:  Extension to FORTRAN-77:  nonstandard lexical item

     EXPLANATION:  One of the following nonstandard lexical items
     was used:

        - Alternate return specifier with an ampersand (&)
          in a CALL statement
        - Apostrophe (') form of record specifier in a direct 
          access I/O statement
        - Variable format expression

  o  MESSAGE:  Extension to FORTRAN-77:  Nonstandard loop expression

     EXPLANATION:  The upper-bound expression, lower-bound
     expression, or increment expression of a DO loop was not of
     type integer, real, or double precision.

  o  MESSAGE:  Extension to FORTRAN-77:  nonstandard name

     EXPLANATION:  A name longer than six characters or one that
     contained a dollar sign ($) or an underscore (_) was used.

  o  MESSAGE:  Extension to FORTRAN-77:  nonstandard operator

     EXPLANATION:  The operators .XOR., %VAL, %REF, and %LOC are
     extensions to FORTRAN-77.  The standard form of .XOR.  is
     .NEQV.  The % operators are extensions provided to allow access
     to non-FORTRAN parts of the VMS environment.

  o  MESSAGE:  Extension to FORTRAN-77:  nonstandard sharing of
     ENDDO terminator.

     EXPLANATION:  ENDDO is an extension to FORTRAN-77, although it
     is standard in Fortran 90.  The Fortran 90 standard does not
     include ENDDO as a valid action-statement for terminating
     multiple nested DO-loops.  It should also be noted that Fortran
     90 considers shared DO termination obsolescent.

     Consider the following:

           DO 100 I=1,10
        DO 100 J=1,20
            IARRAY(J,I) = 0
     100   ENDDO
     ......^
     %FORT-I-EXT_ENDDO, Extension to FORTRAN-77: nonstandard sharing of 
     ENDDO terminator. 
           END

     The code can be corrected as follows:

           DO  I=1,10
        DO J=1,20
            IARRAY(J,I) = 0 
             ENDDO 
           ENDDO
           END

  o  MESSAGE:  Extension to FORTRAN-77:  nonstandard statement type

     EXPLANATION:  A nonstandard statement type was used.

  o  MESSAGE:  Extension to FORTRAN-77:  nonstandard syntax

     EXPLANATION:  One of the following syntax extensions was
     specified:

        PARAMETER name = value --> Error: No parentheses
        
        type name/value/       --> Error: Data initialization in
                                          type declaration
        
        DATA (ch(exp1:exp2),i=lb,ub,inc)/values/) 
                               --> Error:Substring initialization with 
                                         implied-DO in DATA statement
        
        CALL name(arg2,,arg3)  --> Error: Null actual argument
        
        READ (...),iolist      --> Error: Comma between I/O control 
                                          and element lists
        
        PARAMETER (name2=ABS(name1)) --> Error: Function use in 
                                                PARAMETER statement
        
        e1 ** -e2              --> Error: Two consecutive operators

  o  MESSAGE:  Extension to FORTRAN-77:  Nonstandard use of array

     EXPLANATION:  One of the following extensions was detected:

        - An array was used as a FILE specification in an 
          OPEN statement.
        - The file name of an INQUIRE statement was a numeric 
          scalar reference or a numeric array name reference.

  o  MESSAGE:  Extension to FORTRAN-77:  nonstandard use of
     character constant

     EXPLANATION:  A character constant was used in an assignment
     statement where a numeric value is required.

  o  MESSAGE:  Extension to FORTRAN-77:  Nonstandard use of field
     reference

     EXPLANATION:  A record reference (for example,
     record-name.field-name) was used in a program compiled with
     -stand syntax.

  o  MESSAGE:  Extension to FORTRAN-77:  nonstandard use of
     intrinsic!/!function as actual argument

     EXPLANATION:  The FORTRAN 77 standard does not allow the use of
     type conversion (INTEGER, REAL, etc.), lexical relationship
     (LGE, LGT, etc.) or minimum and maximum functions (MIN, MAX,
     etc.) as actual arguments.

  o  MESSAGE:  Extension to FORTRAN-77:  statement function
     argument!/!name same as non-variable

     EXPLANATION:  A statement function dummy argument had the same
     name as an entity other than a variable or a common block (for
     example, a PARAMETER constant).

  o  MESSAGE:  Extension to FORTRAN-77:  tab indentation or
     lowercase source

     EXPLANATION:  The use of tab indentation or lowercase letters
     in source code is an extension to FORTRAN-77.

  o  MESSAGE:  Invalid qualifier or qualifier value in OPTIONS
     statement

     EXPLANATION:  An invalid qualifier or qualifier value was
     specified in the OPTIONS statement.  When this error is
     encountered, the qualifier is ignored.

  o  MESSAGE:  Missing CASE statement in SELECT CASE construct

     EXPLANATION:  There are no CASE statements between a SELECT
     CASE and its ENDSELECT statement.  While this is legal, it is
     usually a mistake in the program.

  o  MESSAGE:  No path to this statement

     EXPLANATION:  Program control could not reach this statement.
     When this situation occurs, the statement is deleted.  For
     example:

        10   I = I + 1
             GO TO 10
             STOP

     You can disable this message by compiling with -warn
     nounreachable.

  o  MESSAGE:  Not yet implemented

     EXPLANATION:  The specified feature has not been implemented.

  o  MESSAGE:  Routine xxx does not return a value

     EXPLANATION:  A subroutine which doesn't return a value was
     used where a value is expected.  For example:

        T = SUB(J)
        ...
        SUBROUTINE SUB(I)

  o  MESSAGE:  Statement function xxx is never called

     EXPLANATION:  A statement function (named xxx) was declared but
     never used.  This could be caused by a missing DIMENSION
     statement that caused a variable assignment to be interpreted
     as a statement function.

     You can disable this message by compiling with -warn
     nouncalled.

  o  MESSAGE:  Unrecognized directive ignored

     EXPLANATION:  A directive was detected in the first five
     columns of a source code statement.  The directive was not
     recognized or the remainder of the directive contains illegal
     syntax.

3 Run_Time
 Errors that occur during execution of your program are reported by
 diagnostic messages from the Run-Time Library.  These messages can
 result from hardware conditions, file system errors, errors
 detected by the Digital Fortran 77 I/O system, errors that occur
 during transfer of data between the program and an internal record,
 computations that cause overflow or underflow, incorrect calls to
 the Run-Time Library, problems in array descriptions, and
 conditions detected by the operating system.

 Run-Time diagnostic messages have the following format:

   forrtl: severity: message_text

   forrtl:       Identifies the source as the Digital Fortran 
                 Run-Time Library
   severity:     Possibilities: severe, error, warning, or 
                 informational
   message_text: Explains the event that caused the message
4 Severe_Messages
 Must be corrected.  The program's execution is terminated when the
 error is encountered, unless for I/O statements the program uses
 the END or ERR I/O statement specifiers to transfer control,
 perhaps to a routine that uses the IOSTAT specifier (see your DEC
 Fortran user manual).

 The severe messages follow (in alphabetical order):

  o  MESSAGE:  Adjustable array dimension error

     NUMBER:  93

     EXPLANATION:  Upon entry to a subprogram, one of the following
     errors was detected during the evaluation of dimensioning
     information:

        - An upper-dimension bound was less than a 
          lower-dimension bound.
        - The dimensions implied an array that was larger 
          than addressable memory.

  o  MESSAGE:  Attempt to access non-existent record

     NUMBER:  36

     EXPLANATION:  A direct-access READ or FIND statement attempted
     to access beyond the end of a relative file (or a sequential
     file on disk with fixed-length records) or access a record that
     was previously deleted in a relative file.

  o  Array index out of bounds (SIGTRAP)

     NUMBER:  138

     EXPLANATION:  Break exception generated a SIGTRAP signal
     (described in signal(3)).  Core dump file created.

     The cause is an array subscript that is outside the dimensioned
     boundaries of that array.  Try recompiling using the -check
     bounds option (perhaps with the f77_dump_flag environment
     variable set) or examine the core dump file to determine the
     source code in error.

  o  MESSAGE:  Array index out of bounds for index n (SIGTRAP)

     NUMBER:  139

     EXPLANATION:  Break exception generated a SIGTRAP signal
     (described in signal(3)).  Core dump file created.

     The cause is an array subscript that is outside the dimensioned
     boundaries of the array index n.  Try recompiling using the
     -check bounds option (perhaps with the f77_dump_flag
     environment variable set) or examine the core dump file to
     determine the source code in error.

  o  MESSAGE:  BACKSPACE error

     NUMBER:  23

     EXPLANATION:  An error condition was detected during execution
     of a BACKSPACE statement.

  o  MESSAGE:  Cannot overwrite existing file

     NUMBER:  10

     EXPLANATION:  Specified file xxx already existed when OPEN
     statement specified STATUS='NEW' (create new file) using I/O
     unit x.  Make sure correct file name, directory path, unit, and
     so forth were specified in the source program.  Decide whether
     to:

        - Rename or remove the existing file before rerunning 
          the program.

        - Modify the source file to specify different file 
          specification, I/O unit, or OPEN file STATUS.

  o  MESSAGE:  Cannot stat file

     NUMBER:  108

     EXPLANATION:  Attempted stat operation on the indicated file
     failed.  Make sure correct file and unit were specified.

  o  MESSAGE:  CLOSE error

     NUMBER:  28

     EXPLANATION:  An error condition was detected by the Digital
     Fortran RTL I/O system during execution of a CLOSE statement.

  o  MESSAGE:  DELETE error

     NUMBER:  55

     EXPLANATION:  An error condition was detected by the Digital
     Fortran RTL I/O system during execution of a DELETE statement.

  o  MESSAGE:  Divide by zero check (SIGTRAP)

     NUMBER:  137

     EXPLANATION:  Break exception generated a SIGTRAP signal
     (described in signal(3)).  Core dump file created.

     Examine core dump file for possible cause.

  o  MESSAGE:  Duplicate file specifications

     NUMBER:  21

     EXPLANATION:  Multiple attempts were made to specify file
     attributes without an intervening close operation.  For
     example, a DEFINE FILE statement was followed by another DEFINE
     FILE statement or an OPEN statement.

  o  MESSAGE:  ENDFILE error

     NUMBER:  33

     EXPLANATION:  One of the following conditions occurred:

        - The file was not a sequential organization file with 
          variable-length records.

        - The file was not opened for sequential or append access.

        - An unformatted file did not contain segmented records.

        - The Digital Fortran RTL I/O system detected an error during 
          execution of an ENDFILE statement. 

  o  MESSAGE:  End-of-file during read

     NUMBER:  24

     EXPLANATION:  One of the following conditions occurred:

        - A Digital Fortran RTL I/O system end-of-file condition
          was encountered during execution of a READ statement 
          that did not contain an END, ERR, or IOSTAT specification. 

        - An end-of-file record written by the ENDFILE statement 
          was encountered during execution of a READ statement 
          that did not contain an END, ERR, or IOSTAT specification.

        - An attempt was made to read past the end of an internal 
          file character string or array during execution of a READ 
          statement that did not contain an END, ERR, or IOSTAT 
          specification.

  o  MESSAGE:  Error during read

     NUMBER:  39

     EXPLANATION:  The Digital Fortran RTL I/O system detected an
     error condition during execution of a READ statement.

  o  MESSAGE:  Error during write

     NUMBER:  38

     EXPLANATION:  The Digital Fortran RTL I/O system detected an
     error condition during execution of a WRITE statement.

  o  MESSAGE:  File name specification error

     NUMBER:  43

     EXPLANATION:  The file name was specified erroneously.

  o  MESSAGE:  File not found

     NUMBER:  29

     EXPLANATION:  A file with the specified name could not be found
     during an open operation.

  o  MESSAGE:  FIND error

     NUMBER:  57

     EXPLANATION:  The Digital Fortran RTL I/O system detected an
     error condition during execution of a FIND statement.

  o  MESSAGE:  Floating inexact

     NUMBER:  140

     EXPLANATION:  A floating-point arithmetic or conversion
     operation gave a result that differs from the mathematically
     exact result.  This trap is reported if the rounded result of
     an IEEE operation is not exact.

  o  MESSAGE:  Floating overflow in math library

     NUMBER:  88

     EXPLANATION:  A floating-point overflow condition was detected
     during execution of a math library procedure.

  o  MESSAGE:  Floating underflow in math library

     NUMBER:  89

     EXPLANATION:  A floating-point underflow condition was detected
     during execution of a math library procedure.  The result
     returned was zero.

  o  MESSAGE:  Format/variable-type mismatch

     NUMBER:  61

     EXPLANATION:  An attempt was made either to read or write a
     real variable with an integer field descriptor (I, L, B, O, or
     Z), or to read or write an integer or logical variable with a
     real field descriptor (D, E, F, or G).

  o  MESSAGE:  Formatted I/O to unit open for unformatted transfers

     NUMBER:  257

     EXPLANATION:  Attempted formatted I/O (such as list-directed or
     namelist I/O) to a unit where the OPEN statement indicated the
     file was unformatted (FORM keyword).  Check that the correct
     unit (file) was specified.

     If the FORM keyword was not specified in the OPEN statement and
     the file should contain formatted data, specify
     FORM='FORMATTED' in the OPEN statement.  Otherwise, if
     appropriate, use unformatted I/O.

  o  MESSAGE:  Inconsistent file organization

     NUMBER:  51

     EXPLANATION:  The file organization specified in an OPEN
     statement did not match the organization of the existing file.

  o  MESSAGE:  Inconsistent OPEN/CLOSE parameters

     NUMBER:  46

     EXPLANATION:  Specifications in an OPEN or CLOSE statement were
     inconsistent.  Some invalid combinations follow:

        - READONLY with STATUS='NEW' or STATUS='SCRATCH'

        - ACCESS='APPEND' with READONLY, STATUS='NEW' or
          STATUS='SCRATCH'

        - DISPOSE='SAVE', 'PRINT', or 'SUBMIT' with
          STATUS='SCRATCH'

        - DISPOSE='DELETE' with READONLY

  o  MESSAGE:  Inconsistent record length

     NUMBER:  37

     EXPLANATION:  One of the following conditions occurred:

      o  An attempt was made to create a new relative or direct
         access file without specifying a record length.

      o  An existing file was opened in which the record length did
         not match the record size given in an OPEN or DEFINE FILE
         statement.

      o  An attempt was made to write to a relative or direct access
         file that was not correctly created or opened.


  o  MESSAGE:  Inconsistent record type

     NUMBER:  44

     EXPLANATION:  The RECORDTYPE value in an OPEN statement did not
     match the record type attribute of the existing file that was
     opened.

  o  MESSAGE:  Infinite format loop

     NUMBER:  60

     EXPLANATION:  The format associated with an I/O statement that
     included an I/O list had no field descriptors to use in
     transferring those values.

  o  MESSAGE:  Input conversion error

     NUMBER:  64

     EXPLANATION:  During a formatted input operation, an invalid
     character was detected in an input field, or the input value
     overflowed the range representable in the input variable.  The
     value of the variable was set to zero.

  o  MESSAGE:  Input record too long

     NUMBER:  22

     EXPLANATION:  A record was read that exceeded the explicit or
     default record length specified when the file was opened.  To
     read the file, use an OPEN statement with a RECL value (record
     length) of the appropriate size.  The RECL unit is bytes for
     formatted files and longwords for unformatted files.

  o  MESSAGE:  Input statement requires too much data

     NUMBER:  67

     EXPLANATION:  An unformatted READ statement attempted to read
     more data than existed in the record being read.

  o  MESSAGE:  Insufficient virtual memory

     NUMBER:  41

     EXPLANATION:  The Digital Fortran RTL was unable to acquire
     additional virtual memory from the operating system.  Users of
     the C and Korn shells may be able to overcome this problem by
     increasing the per-process data limit using the limit (C shell)
     or ulimit (Korn shell) commands.  For more information, see the
     csh(1) and ksh(1) reference pages.

     If the maximum per-process data size is already allocated,
     increase the value of the maxdsiz parameter in the system's
     configuration file.  Note that edits to the configuration file
     do not take effect until the operating system kernel has been
     rebuilt, and the system has been rebooted.  For more
     information, see the doconfig(1) reference page and your
     operating system guide to system configuration.

  o  MESSAGE:  Integer overflow

     NUMBER:  70

     EXPLANATION:  During an arithmetic operation, an integer value
     exceeded byte, word, or longword range.  The result of the
     operation was the correct low-order part.  Consider specifying
     a larger integer data size.  (Modify the source program or, for
     an INTEGER declaration, possibly use the f77 flag -integer_size
     nn).

     For ranges of the various integer data types, see your user
     manual.

  o  MESSAGE:  Integer divide by zero

     NUMBER:  71

     EXPLANATION:  During an integer arithmetic operation, an
     attempt was made to divide by zero.  The result of the
     operation was set to the dividend, which is equivalent to
     division by 1.

  o  MESSAGE:  Internal consistency check failure

     NUMBER:  8

     EXPLANATION:  Internal error.  Please check that the program is
     correct.  Recompile if an error exists in the program.

     If this error persists, submit an SPR.

  o  MESSAGE:  Invalid argument to Fortran Run-Time Library

     NUMBER:  48

     EXPLANATION:  The compiler passed an invalid or improperly
     coded argument to the Digital Fortran RTL.  This can occur if
     the compiler is newer than the RTL in use.

  o  MESSAGE:  Invalid argument to math library

     NUMBER:  81

     EXPLANATION:  One of the mathematical procedures detected an
     invalid argument value.

  o  MESSAGE:  Invalid logical unit number

     NUMBER:  32

     EXPLANATION:  A logical unit number greater than 2,147,483,647
     or less than zero was used in an I/O statement.

  o  MESSAGE:  Invalid reference to variable in NAMELIST input

     NUMBER:  19

     EXPLANATION:  One of the following conditions occurred:

        - The variable was not a member of the namelist group.

        - An attempt was made to subscript a scalar variable.

        - A subscript of the array variable was out-of-bounds.

        - An array variable was specified with too many or too 
          few subscripts for the variable. 

        - An attempt was made to specify a substring of a non-
          character variable or array name.

        - A substring specifier of the character variable was 
          out-of-bounds.

        - A subscript or substring specifier of the variable was 
          not an integer constant.

        - An attempt was made to specify a substring using an 
          unsubscripted array variable. 

  o  MESSAGE:  Kernel breakpoint (SIGTRAP)

     NUMBER:  131

     EXPLANATION:  Break exception generated a SIGTRAP signal
     (described in signal(3)).  Core dump file created.

     Examine core dump for possible cause.

  o  MESSAGE:  Keyword value error in OPEN statement

     NUMBER:  45

     EXPLANATION:  An improper value was specified for an OPEN or
     CLOSE statement keyword requiring a value.

  o  MESSAGE:  List-directed I/O syntax error

     NUMBER:  59

     EXPLANATION:  The data in a list-directed input record had an
     invalid format, or the type of the constant was incompatible
     with the corresponding variable.  The value of the variable was
     unchanged.

  o  MESSAGE:  Logarithm of zero or negative value

     NUMBER:  83

     EXPLANATION:  An attempt was made to take the logarithm of zero
     or a negative number.  The result returned was the reserved
     operand, -0.

  o  MESSAGE:  Mixed file access modes

     NUMBER:  31

     EXPLANATION:  An attempt was made to use any of the following
     combinations:

        - Formatted and unformatted operations on the same unit

        - An invalid combination of access modes on a unit, 
          such as direct and sequential

        - A Digital Fortran RTL I/O statement on a logical unit that 
          was opened by a program coded in another language

  o  MESSAGE:  No current record

     NUMBER:  53

     EXPLANATION:  An attempt was made to REWRITE a record when the
     current record was undefined.  To define the current record,
     execute a successful READ statement.  You can optionally
     perform an INQUIRE statement on the logical unit after the READ
     statement and before the REWRITE statement.  No other
     operations on the logical unit can be performed between the
     READ and REWRITE statements.

  o  MESSAGE:  No such device

     NUMBER:  42

     EXPLANATION:  A pathname included an invalid or unknown device
     name when an OPEN operation was attempted.

  o  MESSAGE:  Not a Fortran-specific error

     NUMBER:  1

     EXPLANATION:  An error occurred in the user program or in the
     RTL that was not a Digital Fortran 77-specific error and was
     not reportable through any other Digital Fortran run-time
     messages.

  o  MESSAGE:  Not taken branch delay emulation (SIGTRAP)

     NUMBER:  134

     EXPLANATION:  Break exception generated a SIGTRAP signal
     (described in signal(3)).  Core dump file created.

     Examine core dump for possible cause.

  o  MESSAGE:  OPEN or DEFINE FILE required

     NUMBER:  26

     EXPLANATION:  A direct access READ, WRITE, or FIND, statement
     was attempted for a file when no DEFINE FILE or OPEN statement
     with ACCESS='DIRECT' was performed for that file.

  o  MESSAGE:  Open failure

     NUMBER:  30

     EXPLANATION:  An error was detected by the Digital Fortran RTL
     I/O system while attempting to open a file in an OPEN, INQUIRE,
     or other I/O statement.  This message is issued when the error
     condition is not one of the more common conditions for which
     specific error messages are provided.  It can occur if an OPEN
     operation is attempted for one of the following files:

        - A segmented file that was not on a disk or a raw 
          magnetic tape.
        - A standard I/O file that had been closed.

  o  MESSAGE:  Operation requires seek ability

     NUMBER:  120

     EXPLANATION:  Attempted an operation on a file that requires
     the ability to perform seeks on that file.  Make sure the
     correct unit, directory path, and file were specified.

  o  MESSAGE:  Output statement overflows record

     NUMBER:  66

     EXPLANATION:  An output statement attempted to transfer more
     data than would fit in the maximum record size.

  o  MESSAGE:  Overflow check (SIGTRAP)

     NUMBER:  136

     EXPLANATION:  Break exception generated a SIGTRAP signal
     (described in signal(3)).  Core dump file created.

     The cause is an integer overflow.  Try recompiling using the
     -check overflow option (perhaps with the f77_dump_flag
     environment variable set) or examine the core dump file to
     determine the source code in error.

  o  MESSAGE:  Pathname error

     NUMBER:  43

     EXPLANATION:  A pathname (or file name) given to an OPEN or
     INQUIRE statement was not acceptable to the Digital Fortran RTL
     I/O system.

  o  MESSAGE:  Permission to access file denied, unit x, file xxx

     NUMBER:  9

     EXPLANATION:  Check the mode (protection) of the specified
     file.  Make sure the correct file was being accessed.  Change
     the protection, specified file, or process used before
     rerunning program.

  o  MESSAGE:  Range error

     NUMBER:  150

     EXPLANATION:  An integer value appeared in a context where the
     value of the integer is outside the permissible range.

  o  MESSAGE:  Record number outside range

     NUMBER:  25

     EXPLANATION:  A direct access READ, WRITE, or FIND statement
     specified a record number outside the range specified when the
     file was opened.

  o  MESSAGE:  Recursive I/O operation

     NUMBER:  40

     EXPLANATION:  While processing an I/O statement for a logical
     unit, another I/O operation on the same logical unit was
     attempted, such as a function subprogram that performs I/O to
     the same logical unit was referenced in an expression in an I/O
     list or variable format expression.

  o  MESSAGE:  REWIND error

     NUMBER:  20

     EXPLANATION:  One of the following conditions occurred:

        - The file was not a sequential file.

        - The file was not opened for sequential or append access.

        - The Digital Fortran RTL I/O system detected an error condition  
          during execution of a REWIND statement. 

  o  MESSAGE:  Segmented record format error

     NUMBER:  35

     EXPLANATION:  An invalid segmented record control data word was
     detected in an unformatted sequential file.  The file was
     probably either created with RECORDTYPE='FIXED' or 'VARIABLE'
     in effect, or was created by a program written in a language
     other than Fortran.

  o  MESSAGE:  Significance lost in math library

     NUMBER:  87

     EXPLANATION:  The magnitude of an argument or the magnitude of
     the ratio of the arguments to a math library function was so
     large that all significance in the result was lost.  The result
     returned was the reserved operand, -0.

  o  MESSAGE:  Square root of negative value

     NUMBER:  84

     EXPLANATION:  An argument required the evaluation of the square
     root of a negative value.  The result returned was the reserved
     operand, -0.

  o  MESSAGE:  String length error

     NUMBER:  148

     EXPLANATION:  During a string operation, an integer value
     appeared in a context where the value of the integer is outside
     the permissible string length range.  Try recompiling with the
     -check bounds flag (perhaps with the f77_dump_flag environment
     variable set) or examine the core file to determine the source
     code causing the error.

  o  MESSAGE:  Subscript out of range

     NUMBER:  77

     EXPLANATION:  An array reference was detected outside the
     declared array bounds.

  o  MESSAGE:  Substring error

     NUMBER:  149

     EXPLANATION:  An array subscript is outside the dimensioned
     boundaries of an array.  Try recompiling with the -check bounds
     flag (perhaps with the f77_dump_flag environment variable set)
     or examine the core file to determine the source code causing
     the error.

  o  MESSAGE:  Syntax error in format

     NUMBER:  62

     EXPLANATION:  A syntax error was encountered while the RTL was
     processing a format stored in an array or character variable.

  o  MESSAGE:  Syntax error in NAMELIST input

     NUMBER:  17

     EXPLANATION:  The syntax of input to a namelist READ statement
     was incorrect.

  o  MESSAGE:  Taken branch delay emulation (SIGTRAP)

     NUMBER:  133

     EXPLANATION:  Break exception generated a SIGTRAP signal
     (described in signal(3)).  Core dump file created.

     Examine core dump for possible cause.

  o  MESSAGE:  Too many records in I/O statement

     NUMBER:  27

     EXPLANATION:  An attempt was made to do one of the following:

        - Read or write more than one record with an ENCODE
          or DECODE statement.
        - Write more records than existed.

  o  MESSAGE:  Too many values for NAMELIST variable

     NUMBER:  18

     EXPLANATION:  An attempt was made to assign too many values to
     a variable during a namelist READ statement.

  o  MESSAGE:  Undefined exponentiation

     NUMBER:  82

     EXPLANATION:  An exponentiation that is mathematically
     undefined was attempted, for example, 0.**0.  The result
     returned for floating-point operations was the reserved
     operand, -0, and for integer operations, zero.

  o  MESSAGE:  Unformatted I/O to unit open for formatted transfers

     NUMBER:  256

     EXPLANATION:  Attempted unformatted I/O to a unit where the
     OPEN statement indicated the file was formatted (FORM keyword).
     Check that the correct unit (file) was specified.

     If the FORM keyword was not specified in the OPEN statement and
     the file should contain unformatted data, specify
     FORM='UNFORMATTED' in the OPEN statement.  Otherwise, if
     appropriate, use formatted I/O (such as list-directed or
     namelist I/O).

  o  MESSAGE:  Unit already open

     NUMBER:  34

     EXPLANATION:  A DEFINE FILE statement specified a logical unit
     that was already opened.

  o  MESSAGE:  User breakpoint (SIGTRAP)

     NUMBER:  130

     EXPLANATION:  Break exception generated a SIGTRAP signal
     (described in signal(3)).  Core dump file created.

     Examine core dump for possible cause.

  o  MESSAGE:  User single step (SIGTRAP)

     NUMBER:  135

     EXPLANATION:  Break exception generated a SIGTRAP signal
     (described in signal(3)).  Core dump file created.

     Examine core dump for possible cause.

  o  MESSAGE:  Variable format expression value error

     NUMBER:  68

     EXPLANATION:  The value of a variable format expression was not
     within the range acceptable for its intended use; for example,
     a field width was less than or equal to zero.  A value of 1 was
     assumed, except for a P edit descriptor, for which a value of
     zero was assumed.

  o  MESSAGE:  Write to READONLY file

     NUMBER:  47

     EXPLANATION:  A write operation was attempted to a file that
     was declared READONLY in the OPEN statement that is currently
     in effect.

  o  MESSAGE:  Wrong number of arguments

     NUMBER:  80

     EXPLANATION:  An improper number of arguments was used to call
     a math library procedure.

4 Error_Messages
 Should be corrected.  The program may continue execution, but the
 output from this execution may be incorrect.

 The error messages follow (in alphabetical order):

  o  MESSAGE:  Floating divide by zero

     NUMBER:  73

     EXPLANATION:  During a floating-point arithmetic operation, an
     attempt was made to divide by zero.

  o  MESSAGE:  Floating invalid

     NUMBER:  65

     EXPLANATION:  During an arithmetic operation, the
     floating-point value generated resulted in an invalid format
     (not representable for that data type).

  o  MESSAGE:  Floating overflow

     NUMBER:  72

     EXPLANATION:  During an arithmetic operation, a floating-point
     value exceeded the largest representable value for that data
     type.  For ranges of the various data types, see your user
     manual.

  o  MESSAGE:  Floating point exception

     NUMBER:  75

     EXPLANATION:  A floating-point exception occurred.  Core dump
     file created.  Possible causes include:

      o  Divide by zero

      o  Overflow

      o  An invalid operation, such as subtraction of infinite
         values, multiplication of zero by infinity (without signs),
         division of zero by zero or infinity by infinity

      o  Conversion of floating-point to fixed-point format when an
         overflow prevents conversion


  o  MESSAGE:  Floating underflow

     NUMBER:  74

     EXPLANATION:  During an arithmetic operation, a floating-point
     value became less than the smallest representable value for
     that data type.  On Alpha systems, the underflowed result is
     set to zero.  See your DEC Fortran user manual for ranges of
     the various data types.

  o  MESSAGE:  Fortran abort routine called

     NUMBER:  266

     EXPLANATION:  The program called abort to terminate the
     program.

  o  MESSAGE:  IOT trap signal

     NUMBER:  76

     EXPLANATION:  Core dump file created.  Examine core dump for
     possible cause of this IOT signal.

  o  MESSAGE:  Output conversion error

     NUMBER:  63

     EXPLANATION:  During a formatted output operation, the value of
     a particular number could not be output in the specified field
     length without loss of significant digits.  When this situation
     is encountered, the field is filled with asterisks.

  o  MESSAGE:  Process interrupted (SIGINT)

     NUMBER:  69

     EXPLANATION:  The process received the signal SIGINT.
     Determine source of this interrupt signal (described in
     signal(3)).

  o  MESSAGE:  Process killed (SIGTERM)

     NUMBER:  78

     EXPLANATION:  The process received the signal SIGTERM.
     Determine source of this software termination signal (described
     in signal(3)).

  o  MESSAGE:  Process quit (SIGQUIT)

     NUMBER:  79

     EXPLANATION:  The process received the signal SIGQUIT.  Core
     dump file created.  Determine source of this quit signal
     (described in signal(3)).

4 Warning_Messages
 Should be investigated.  The program continues execution, but the
 output from this execution may be incorrect.

 The warning messages follow (in alphabetical order):

  o  MESSAGE:  Could not open message catalog:  formsg.cat

     NUMBER:  none

     EXPLANATION:  The Digital Fortran 77 message catalog file was
     not found on this system.  For more information, see your user
     manual or installation guide.

4 Informational_Messages
 For informational purposes only.  Unless it accompanies another
 message, the program continues.

 The informational messages follow (in alphabetical order):

  o  MESSAGE:  Check environment variable NLSPATH and protection of
     path-name/for_msg.dat

     NUMBER:  none

     EXPLANATION:  The Digital Fortran 77 message catalog file was
     not found on this system.  For more information, see your user
     manual or your installation guide.

  o  MESSAGE:  Check location/protection of NLS and
     /usr/lib/formsg.dat

     NUMBER:  none

     EXPLANATION:  The Digital Fortran 77 message file was not found
     on this system.  See your DEC Fortran user manual for more
     information.

  o  MESSAGE:  nn floating divide-by-zero traps

     NUMBER:  299

     EXPLANATION:  The total number of floating-point divide-by-zero
     traps encountered during program execution was nn.  This
     summary message appears at program completion.

  o  MESSAGE:  nn floating invalid traps

     NUMBER:  297

     EXPLANATION:  The total number of floating-point invalid data
     traps encountered during program execution was nn.  This
     summary message appears at program completion.

  o  MESSAGE:  nn floating overflow traps

     NUMBER:  298

     EXPLANATION:  The total number of floating-point overflow traps
     encountered during program execution was nn.  This summary
     message appears at program completion.

  o  MESSAGE:  Floating-point conversion failed

     NUMBER:  95

     EXPLANATION:  The attempted unformatted read or write of
     non-native floating-point data failed.  A non-native
     floating-point value either:

      o  Exceeded the allowable maximum value for the equivalent
         native format and was set equal to invalid.

      o  Was infinity (plus or minus) and was set to invalid.

      o  Was Not a Number (NaN) and was set to invalid.

      o  Was otherwise invalid and was set to invalid.


     Very small numbers are set to zero.  This error can be caused
     by the specified non-native floating-point format not matching
     the floating-point format found in the specified file.

     Make sure the correct file was specified.  Make sure the record
     layout matches the format Digital Fortran 77 is expecting.
     Check that the correct non-native floating-point data format
     was specified, as described in your user manual.

  o  MESSAGE:  nn floating underflow traps

     NUMBER:  300

     EXPLANATION:  The total number of floating-point underflow
     traps encountered during program execution was nn.  This
     summary message appears at program completion.

  o  MESSAGE:  Format syntax error at or near xx

     NUMBER:  58

     EXPLANATION:  Check the statement containing xx, a character
     substring from the format string, for a format syntax error.
     For information about FORMAT statements, refer to the DEC
     Fortran Language Reference Manual.

  o  MESSAGE:  Fortran error message number is nnn

     NUMBER:  none

     EXPLANATION:  The Digital Fortran 77 message catalog file was
     not found on this system.  For information about the message
     catalog file location, see your user manual or installation
     guide.

  o  MESSAGE:  Unit not connected

     NUMBER:  11

     EXPLANATION:  The specified unit was not open at the time of
     the attempted I/O operation.  Check to see if the correct unit
     number was specified.  If appropriate, use an OPEN statement to
     explicitly open the file (associates the file with the unit
     number).

2 Format_Specifiers       
 A FORMAT statement specifies the format in which data is to be
 transferred as well as the conversion (editing) required to achieve
 that format.  FORMAT statements are nonexecutable statements used
 with formatted I/O statements and with ASSIGN, ENCODE, and DECODE
 statements.

 Fields defined by a FORMAT statement can contain variable format
 expressions.  A variable format expression is an integer variable
 or expression enclosed in angle brackets that takes the place of an
 integer constant.  The value of the variable or variables can
 change during program execution.
3 Default_Field_Descriptors   

 Default field descriptor values are as follows:

 Field        
 Descriptor  List Element                       w        d    e
 --------------------------------------------------------------
 I,O,Z       BYTE,INTEGER*1,LOGICAL*1           7
 I,O,Z       INTEGER*2,LOGICAL*2                7
 I,O,Z       INTEGER*4,LOGICAL*4               12
 I,O,Z       INTEGER*8(Alpha),LOGICAL*8(Alpha) 23
 O,Z         REAL*4                            12
 O,Z         REAL*8                            23
 O,Z         REAL*16 (Alpha)                   44
 O,Z         CHARACTER*n                       MAX(7,3*n)
 L           LOGICAL*1,LOGICAL*2,               2
             LOGICAL*4,LOGICAL*8(Alpha)
 F,E,G,D     REAL*4,COMPLEX*8                  15        7    2
 F,E,G,D     REAL*8,COMPLEX*16                 25       16    2
 F,E,G,D     REAL*16 (Alpha)                   42       33    3
 A           LOGICAL*1                          1
 A           LOGICAL*2,INTEGER*2                2
 A           LOGICAL*4,INTEGER*4                4
 A           LOGICAL*8(Alpha),INTEGER*8(Alpha)  8
 A           REAL*4,COMPLEX*8                   8
 A           REAL*8,COMPLEX*16                  8
 A           REAL*16 (Alpha)                   16
 A           CHARACTER*n                        n
3 General_Form      
 The general form of a FORMAT statement is as follows:

    FORMAT (q1 f1s1 f2s2 ... fnsn qn)

    qn   Is zero or more slash (/) record terminators.
    fn   Is a field descriptor, an edit descriptor, or
         a group of field and edit descriptors enclosed
         in parentheses.
    sn   Is a field separator (a comma or slash).  A
         comma can be omitted in the following cases:

         o Between a P edit descriptor and an immediately 
           following F, E, D, or G edit descriptor.

         o Before or after a slash (/) record terminator.

         o Before or after a colon (:) edit descriptor.

 The "field descriptor" has one of the following forms:

    [r]c  [r]cw  [r]cw.m  [r]cw.d[Ee]

    r    Is the optional repeat count.  (If you omit "r", 
         the repeat count is assumed to be 1.)
    c    Is a format code (I,O,Z,F,E,D,G,L, or A).
    w    Is the external field width in characters.  Each
         data item in the external medium is called an 
         external field.
    m    Is the minimum number of characters that must appear 
         in the field (including leading zeros).
    d    Is the number of characters to the right of the decimal point.
    E    Is an exponent field.
    e    Is the number of characters in the exponent.

 The ranges for "r", "w", "m", "d", and "e" are as follows:

 Term      Range                 
 ----      __________                 
  r        1 to 2147483647 (2**31-1)  
  w        1 to 2147483647            
  m        0 to 32767 (2**15-1)       
  d        0 to 32767                 
  e        1 to 32767                 

 The terms must all be unsigned integer constants or variable format
 expressions.

 You cannot use PARAMETER constants for "r", "w", "m", "d", or "e".

 The "edit descriptor" has one of the following forms:

    c  [n]c  c[n]
   
    c     Is a format code (X,T,TL,TR,SP,SS,S,BN,BZ,P,H,
          '...', "...", Q, $, or :).
    n     Is the optional number of characters or character
          positions.

 The term "n" must be an unsigned integer constant (for format code
 P, it can be signed or unsigned) or a variable format expression.

 The value of "n" for P must be within the range -128 to 127.

 For all other format codes, the value of "n" must be within the
 range 1 through 2147483647 (2**31-1); actual useful ranges may be
 constrained by record sizes (RECL) and the file system.
3 Format_Descriptors        
 A format descriptor can be one of the following:

    Field descriptor -- Defines the size and format of a data
    item.  Each field descriptor corresponds to the next data
    item in the statement's I/O list.

    Edit descriptor  --  Specifies editing functions to be
    performed on data items.  

 Format descriptors are generally separated by commas, but you can
 also use the slash (/) record terminator to separate them.  A slash
 terminates input or output of the current record and initiates a
 new record; for example:

         WRITE (6,40) K,L,M,N,O,P
    40   FORMAT (3I6.6/I6,2F8.4)

 The preceding statements are equivalent to the following:

         WRITE (6,40) K,L,M
    40   FORMAT (3I6.6)
         WRITE (6,50) N,O,P
    50   FORMAT (I6,2F8.4)

 Multiple slashes cause the system to bypass input records or output
 blank records.  If "n" consecutive slashes appear between two field
 or edit descriptors, (n-1) records are skipped on input, or (n-1)
 blank records are output.  The first slash terminates the current
 record.  The second slash terminates the first skipped or blank
 record, and so on.

 However, "n" slashes at the beginning or end of a format
 specification result in "n" skipped or blank records.  This is
 because the opening and closing parentheses of the format
 specification are themselves a record initiator and terminator,
 respectively.
3 Repeat_Count               
 You can apply the field descriptors I, O, Z, F, E, D, G, L, and A
 to a number of successive data fields by preceding the field
 descriptor with an unsigned integer constant (PARAMETER constants
 are not allowed) specifying the number of repetitions.  This
 constant is called a repeat count.

 For example, the following two statements are equivalent:

    20 FORMAT (E12.4,E12.4,E12.4,I5,I5,I5,I5)
    20 FORMAT (3E12.4,4I5)

 Similarly, you can apply a group of field descriptors repeatedly to
 data fields by enclosing these field descriptors in parentheses and
 preceding them with an unsigned integer constant.  The integer
 constant is called a group repeat count.  For example, the
 following two statements are equivalent:

    50 FORMAT (I8,I8,F8.3,E15.7,F8.3,E15.7,F8.3,E15.7,I5,I5)
    50 FORMAT (2I8,3(F8.3,E15.7),2(I5))

 An H or Q field descriptor, which could not otherwise be repeated,
 can be enclosed in parentheses and treated as a group repeat
 specification.
3 Reversion                  
 When the last closing parenthesis of the format specification is
 reached, format control determines whether more I/O list elements
 are to be processed.  If not, format control terminates.  However,
 if additional list elements remain, part or all of the format
 specification is reused in a process called format reversion.

 In format reversion, the current record is terminated, a new one is
 initiated, and format control reverts to the group repeat
 specification whose opening parenthesis matches the next-to-last
 closing parenthesis of the format specification.  If the format
 does not contain a group repeat specification, format control
 returns to the initial opening parenthesis of the format
 specification.  Format control continues from that point.
3 Variable_Format_Expressions
 By enclosing an expression in angle brackets, you can use it in a
 FORMAT statement wherever you can use an integer (except as the
 specification of the number of characters in the H field).  For
 example:

    20 FORMAT (I<J+1>)

 When the format is scanned, the preceding statement performs an I
 (integer) data transfer with a field width of J+1.  The expression
 is reevaluated each time it is encountered in the normal format
 scan.

 The following rules apply to variable format expressions:

    - If the expression is not of integer data type, it is 
      converted to integer data type before being used.
    - The expression can be any valid Fortran expression, 
      including function calls and references to dummy arguments.
    - The value of a variable format expression must obey the
      restrictions on magnitude applying to its use in the 
      format, or an error occurs.
    - Variable format expressions are not permitted in run-time 
      formats.

 Variable format expressions are evaluated each time they are
 encountered in the scan of the format.  If the value of the
 variable used in the expression changes during the execution of the
 I/O statement, the new value is used the next time the format item
 containing the expression is processed.
3 Field                      
 Field descriptors:
   +-----------------------------------+
   |      Function      |  Format      |
   +--------------------+--------------+
   | Integer            | Iw[.m]       |
   | Octal              | Ow[.m]       |
   | Hexadecimal        | Zw[.m]       |
   | Real number        | Fw.d         |
   | Exponential form   | Ew.d[Ee]     |
   | D exponential form | Dw.d         |
   | G exponential form | Gw.d[Ee]     |
   | Logical            | Lw           |
   | Character          | A[w]         |
   +--------------------+--------------+

 NOTE:  Transfer complex numbers as two real (F, E, D, or G) numbers.
3 Edit                       
 Edit descriptors:
   +--------------------------+--------------+
   |         Function         |    Format    |
   +--------------------------+--------------+
   | Character constant       | 'characters' |
   |                          |      or      |
   |                          | "characters" |
   | Hollerith                | nHchar...    |
   | Scale factor             | nP           |
   | Blanks are null (input)  | BN           |
   | Blanks are zero (input)  | BZ           |
   | Input size               | Q            |
   | Plus sign (always)       | SP           |
   | Plus sign (never)        | SS           |
   | Default plus sign        | S            |
   | Skip spaces (same as TRn)| nX           |
   | Position (Tab)           | Tn           |
   | Relative left tab        | TLn          |
   | Relative right tab       | TRn          |
   | Carriage control         | $            |
   | Terminate list           | :            |
   +--------------------------+--------------+
3 'characters'               
 or "characters"

 You can use a character constant instead of an H field descriptor.
 Both types of format specifiers function identically.

 On input, this specifier transfers the specified characters from
 the external field.

 On output, this specifier transfers the specified characters to the
 record.
3 Carriage_Control         
 When the first character of a formatted record is transferred to an
 output file or printer, it can be interpreted as a carriage control
 character (and not printed) if the file is opened with
 CARRIAGECONTROL='FORTRAN' in effect.

 On U*X systems, this interpretation can also occur if the file is
 processed by the fortpr format utility.

 The I/O system recognizes the characters listed below as carriage
 control characters and does not print them.

    Character    Meaning
    ---------    -----------------------------------------
      '+'        Overprinting: Outputs the record (at the 
                 beginning of the current line) and a 
                 carriage return.

      ' '        One line feed: Outputs the record (at the
                 beginning of the following line) and a
                 carriage return.

      '0'        Two line feeds: Outputs the record (after 
                 skipping a line) and a carriage return.

      '1'        Next page: Outputs the record (at the 
                 beginning of a new page) and a carriage 
                 return.

      '$'        Prompting: Outputs the record (at the 
                 beginning of a new page), but no carriage 
                 return.

    ASCII NULL   Overprinting with no advance: Outputs 
                 the record (at the beginning of the current 
                 line), but no carriage return. (ASCII NULL 
                 is specified as CHAR(0).)

 Any character other than those listed above is interpreted as a
 space and is deleted from the print line.  If you accidentally omit
 a carriage control character, the first character of the record is
 not printed.
3 $                          
 In a format specification, the dollar sign character ($) modifies
 the carriage control specified by the first character of the
 record.  It only affects the files for which the 'FORTRAN' carriage
 control attribute is in effect.

 On U*X systems, it also affects files if 'LIST' is in effect.

 In an input statement, the $ descriptor is ignored.

 In an output statement, the following rules apply:

    - If the first character of the record is 0, 1, or
      ASCII NUL, the $ descriptor is ignored.

    - If the first character of the record is a space or
      plus sign (+), the $ descriptor suppresses carriage 
      return (after printing the record).

 For terminal I/O, whenever trailing carriage return control is
 suppressed by the $ descriptor, a typed response follows output on
 the same line.
3 :                         
 Terminates the I/O operation if no more items remain in the I/O
 list.
3 A                         
 A[w] (Character Editing)

 If the corresponding I/O list element has a character data type,
 character data is transmitted.  If it has any other data type,
 Hollerith data is transmitted.  The value of "w" must be less than
 or equal to 2**31-1.

 On input, transfers "w" characters or Hollerith values from the
 external record and assigns them to the corresponding list element.
 If the input value contains fewer characters than "w", it is padded
 on the right with blanks.  If the input value contains excessive
 characters, it is truncated on the left.

 If the variable is numeric, the ASCII value of each character is
 placed in each byte of the variable, starting at the low-order
 byte.

 On output, transfers the contents of the corresponding I/O list
 element to an external field "w" characters long.  If the output
 value contains fewer characters than "w", it is padded on the left
 with blanks.  If the output value contains excess characters, it is
 truncated on the right (for numbers, the high-order bytes are
 lost).

 If the output value is numeric or untyped, the ASCII value of each
 byte of the variable, starting at the low-order byte, is
 transferred to the record.

 The "w" can be omitted and defaults to the number of characters in
 the character variable or the number of bytes in the numeric
 variable.
3 BN                        
 (Blank Control Editing)

 Causes embedded and trailing blanks to be ignored within a numeric
 input field.  Leading blanks are always ignored, and an all blank
 field is always treated as zero.

 It affects all subsequent I, O, Z, F, E, D, and G editing (in the
 same FORMAT statement) during the execution of an output statement.

 If OPEN (BLANK='ZERO') is specified, blanks are converted to zeros.
 In all other cases, blanks are ignored (they are interpreted as
 null characters).

 The BN and BZ descriptors supersede the default interpretation of
 blanks during execution of a particular formatted input statement.
3 BZ                         
 (Blank Control Editing)

 Causes embedded and trailing blanks to be treated as zeros within a
 numeric input field.  (Leading blanks are always ignored.)

 It affects all subsequent I, O, Z, F, E, D, and G editing (in the
 same FORMAT statement) during the execution of an output statement.

 If OPEN (BLANK='ZERO') is specified, blanks are converted to zeros.
 In all other cases, blanks are ignored (they are interpreted as
 null characters).

 An all blank field is always treated as zero.

 The BN and BZ descriptors supersede the default interpretation of
 blanks during execution of a particular formatted input statement.
3 D                         
 Dw.d
 (Exponential Editing)

 On input, D performs the same as F format.

 On output, D performs the same as E format, except that the letter
 D replaces the letter E preceding the exponent and the size of the
 exponent is fixed at 2.
3 E                         
 Ew.d[Ee] (Exponential Editing)

 On input, E performs the same as F format.

 On output, E transfers the value of the corresponding I/O list
 element, rounded to "d" decimal digits and right-justified to an
 external field "w" characters long.  "d" specifies the size of the
 fraction and "e" specifies the size of the exponent.  If the value
 does not fill the field, leading spaces are inserted; if the value
 is too large for the field, the entire field is filled with
 asterisks.

 The term "w" must be large enough to include all of the following:
 a minus sign (when necessary) or a plus sign (if SP editing is in
 effect), a zero, a decimal point, "d" digits, and an exponent.

 Therefore, to accommodate all possible components of the standard
 form, the term "w" must be greater than or equal to "d"+7; if "e"
 is present, "w" must be greater than or equal to "d"+"e"+5.

 However, "w" can be as small as "d"+5 or "d"+"e"+3 and still allow
 formatting of the value without error, if optional fields are
 omitted.  In this case, the sign is omitted (if the value is
 positive and SP editing is not in effect) and the zero to the left
 of the decimal point is also omitted, if necessary.
3 F                         
 Fw.d (Fixed Floating Editing)

 On input, F transfers "w" characters from the external field and
 assigns them, as a real value, to the corresponding I/O list
 element (which must be real data type).  If the first nonblank
 character of the external field is a minus sign, the field is
 treated as a negative value.  If the first nonblank character is a
 plus sign or if no sign appears in the field, the field is treated
 as a positive value.

 If the field contains neither a decimal point nor an exponent, it
 is treated as a real number of "w" digits, in which the rightmost
 "d" digits are to the right of the decimal point, with leading
 zeros assumed if necessary.  If the field contains an explicit
 decimal point, the location of the decimal point overrides the
 location specified by the field descriptor.  If the field contains
 an exponent, that exponent is used to establish the magnitude of
 the value before it is assigned to the list element.

 On output, F transfers the value of the corresponding I/O list
 element, rounded to "d" decimal positions and right-justified, to
 an external field that is "w" characters long.  If the value does
 not fill the field, leading spaces are inserted; if the value is
 too large for the field, the entire field is filled with asterisks.

 The term "w" must be large enough to include all of the following:
 a minus sign (when necessary) or a plus sign (if SP editing is in
 effect), at least one digit to the left of the decimal point, a
 decimal point, and "d" digits to the right of the decimal.

 Therefore, "w" must be greater than or equal to "d"+3.
3 G                         
 Gw.d[Ee] (General Floating Editing)

 On input, G performs the same as F format.

 On output, G transfers the value of the corresponding I/O list
 element, rounded to "d" decimal positions, and right-justified, to
 an external field that is "w" characters long.  The form in which
 the value is written is a function of the magnitude of the value,
 as given below:

   Data Magnitude                                    Effective Conversion
   --------------                                    --------------------
   m < 0.1                                           Ew.d[Ee]
   m = 0                                             F(w-n).(d-1),n('b')
   0.1 - 0.5x10**-d-1 <= m < 1 - 0.5x10**-d          F(w-n).d, n('b')
   1 - 0.5x10**-d <= m < 10 - 0.5x10**-d+1           F(w-n).(d-1), n('b')
   10 - 0.5x10**-d+1 <= n < 100 - 0.5x10**-d+2       F(w-n).(d-2), n('b')
         .                                               .
         .                                               .
         .                                               .
   10**d-2 - 0.5x10**-2 <= m < 10**d-1 - 0.5x10**-1  F(w-n).1, n('b')
   10**d-1 - 0.5x10**-1 <= m < 10**d - 0.5           F(w-n).0, n('b')
   m >= 10**d                                        Ew.d[Ee]

 The 'b' is a blank following the numeric data representation.  For
 Gw.d, n('b') is 4 blanks.  For Gw.dEe, n('b') is "e"+2 blanks.

 The term "w" must be greater than or equal to d+7 to allow for the
 following:  a sign (optional if the value is positive and
 descriptor SP is not in effect), one digit to the left of the
 decimal point, a decimal point, "d" digits to the right of the
 decimal point, and either a 4-digit or an "e"+2-digit exponent.

 If "e" is specified, "w" must be greater than or equal to
 "d"+"e"+5.
3 H                         
 nHc1c2c2...cn (Hollerith Editing)

 On input, transfers "n" characters from the external record to the
 field descriptor itself.  The first character appears immediately
 after the H.  Any characters in the field descriptor prior to the
 input operation are replaced by the input characters.

 On output, transfers "n" characters following the letter H from the
 field descriptor to the external field.
3 I                         
 Iw[.m] (Integer Editing)

 On input, I transfers "w" characters from the external field and
 assigns them, as an integer value, to the corresponding I/O list
 element (which must be integer or logical data type).  The external
 data must have the form of an integer constant; it cannot contain a
 decimal point or exponent field.

 If the first nonblank character of the external field is a minus
 sign, the field is treated as a negative value.  If the first
 nonblank character is a plus sign or if no sign appears in the
 field, the field is treated as a positive value.

 On output, I transfers the value of the corresponding I/O list
 element, right-justified, to an external field that is "w"
 characters long.  If the value does not fill the field, leading
 spaces are inserted; if the value is too large for the field, the
 entire field is filled with asterisks.  "w" must be large enough to
 include a possible minus sign.  If "m" is present, the external
 field consists of at least "m" digits and, if necessary, is zero
 filled on the left.
3 L                         
 Lw (Logical Editing)

 On input, L transfers "w" characters from the external field and
 assigns a logical value to the corresponding I/O list element
 (which must be integer or logical data type).  If the first
 nonblank characters of the field are T, t, .T, or .t, the value
 .TRUE. is assigned to the corresponding I/O list element; if the
 first nonblank characters are F, f, .F, or .f, the value .FALSE. is
 assigned.  An all blank field is assigned the value .FALSE.  Any
 other value in the external field produces an error.  The logical
 constants .TRUE. and .FALSE. are acceptable input forms.

 On output, L transfers either the letter T (if the value of the
 corresponding I/O list element is .TRUE.) or the letter F (if the
 value is .FALSE.) to an external field that is "w" characters long.
 The letter T or F is in the rightmost position of the field,
 preceded by w-1 spaces.
3 O                         
 Ow[.m] (Octal Editing)

 On input, O transfers "w" characters from the external field and
 assigns them, as an octal value, to the corresponding I/O list
 element (which can be any data type).  The external field can
 contain only the numerals 0 though 7; it cannot contain a sign, a
 decimal point, or exponent field.  An all blank field is treated as
 a value of zero.  If the value of the external field exceeds the
 range of the corresponding list element, an error occurs.

 On output, O transfers the octal value of the corresponding I/O
 list element, right-justified, to an external field that is "w"
 characters long.  No signs are transmitted; a negative value is
 transmitted in internal form.  If the value does not fill the
 field, leading spaces are inserted; if the value is too large for
 the field, the entire field is filled with asterisks.  If "m" is
 present, the external field consists of at least "m" digits and, if
 necessary, is zero filled on the left.

 "w" must be large enough to include a possible minus sign.  If "m"
 is present, the external field consists of at least "m" digits and,
 if necessary, is zero filled on the left.
3 P                         
 nP (Scale Factor Editing)

 The scale factor lets you alter, during input or output, the
 location of the decimal point both in real values and in the two
 parts of complex values.

 The "n" is a signed or unsigned integer constant, in the range -128
 to 127, that specifies the number of positions to the left or right
 that the decimal point is to move.

 A scale factor can appear anywhere in a format specification, but
 must precede the first F, E, D, or G field descriptor that is to be
 associated with it and affects all subsequent real field
 descriptors in the same FORMAT statement (unless another scale
 factor appears.

 On input the scale factor of any of the F, E, D, and G field
 descriptors multiplies the data by 10**-n and assigns it to the
 corresponding I/O list element.  For example a 2P scale factor
 multiplies an input value by .01; a -2P multiplies an input value
 by 100.  However, if the external field contains an explicit
 exponent, the scale factor has no effect.

 E, D, or G field descriptors alter the form in which data is
 transferred.  On input a positive scale factor moves the decimal
 point to the left and a negative scale factor moves the decimal
 point to the right; on output, the effect is the reverse.
4 F_field_descriptor
 nPFw.d

 On output, the value of the I/O list element is multiplied by 10**n
 before transfer to the external record.  Thus, a positive scale
 factor moves the decimal point to the right; a negative scale
 factor moves the decimal point to the left.  Thus, the F field
 descriptor alters the magnitude of the data.
4 E_field_descriptor
 nPEw.d

 On output, the basic real constant part of the I/O list element is
 multiplied by 10**n, and "n" is subtracted from the exponent.  For
 a positive scale factor, "n" must be less than d+2 or an output
 conversion error occurs.  Thus, a positive scale factor moves the
 decimal point to the right and decreases the exponent; a negative
 scale factor moves the decimal point to the left and increases the
 exponent.
4 D_field_descriptor
 nPDw.d

 On output, the basic real constant part of the I/O list element is
 multiplied by 10**n, and "n" is subtracted from the exponent.  For
 a positive scale factor, "n" must be less than d+2 or an output
 conversion error occurs.  Thus, a positive scale factor moves the
 decimal point to the right and decreases the exponent; a negative
 scale factor moves the decimal point to the left and increases the
 exponent.
4 G_field_descriptor
 nPGw.d

 On output, the effect for the G field descriptor is suspended if
 the magnitude of the data to be output is within the effective
 range of the descriptor (because the G field descriptor supplies
 its own scaling function).  It functions as an E field descriptor
 if the magnitude of the data is outside its range.  In this case,
 the scale factor has the same effect as for the E field descriptor.
3 Q                         
 (Query Remaining Character Count)

 On input, Q obtains the number of characters remaining in the input
 record to be transferred during a read operation.  The following
 example uses the Q descriptor to determine the size of the input
 record:

    READ(5,'(Q,A)') LEN, REC(1:LEN)

 On output, the Q descriptor has no effect, except that the
 corresponding I/O item is skipped.
3 S                         
 (Normal Signing)

 Restores the option of producing plus characters (+) in numeric
 output fields.  The S descriptor counters the action of either the
 SP or SS descriptor by restoring to the processor the discretion of
 producing plus characters on an optional basis.

 This descriptor affects fields all that follow it, until an SP or
 SS is encountered.  The S descriptor affects all subsequent I, F,
 E, D, and G editing (in the same FORMAT statement) during the
 execution of an output statement.
3 SP                        
 (Always + Signs)

 Causes the processor to produce a leading plus character (+) in any
 position where this character would otherwise be optional.

 This descriptor affects all (suppress + signs) fields that follow
 it, until an S or SS is encountered.  The SP descriptor affects all
 subsequent I, F, E, D, and G editing (in the same FORMAT statement)
 during the execution of an output statement.
3 SS                        
 (Suppress Sign)

 Causes the processor to suppress a leading plus character from any
 position where this character would otherwise be optional.  It has
 the opposite effect of the SP field descriptor.

 The SS descriptor affects all subsequent I, F, E, D, and G editing
 (in the same FORMAT statement) during the execution of an output
 statement.  This descriptor affects all fields that follow it,
 until an S or SS is encountered.
3 T                         
 Tn (Tab to Position n)

 On input, starts the next read operation at the character position
 (within the record) indicated by position n.  For example, if an
 input statement reads a record containing:

    ABC   XYZ

 and this record is under the control of the FORMAT statement:

    10 FORMAT (T7,A3,T1,A3)

 On execution, the input statement would first read the characters
 XYZ and then read the characters ABC.

 On output, starts the next write operation at the character
 position n in the external record.

 The position specified must be an integer in the range 1 through
 the size of the record.
3 TL                        
 TLn (Tab Left n Positions)

 Indicates that the next character to be transferred to or from a
 record is the "n"th character to the left of the current character.

 The value of "n" must be greater than or equal to 1.

 If the value of "n" is greater than or equal to the current
 character position, the first character in the record is specified.
3 TR                        
 TRn (Tab Right n Positions)

 Indicates that the next character to be transferred to or from a
 record is the "n"th character to the right of the current
 character.

 The value of "n" must be greater than or equal to 1.
3 X                         
 nX (Skip Right n Positions)

 The X field descriptor functions the same as the TR field
 descriptor.

 On input, X starts the next read operation after skipping "n"
 character positions.  If X is the last format item, it will have no
 effect.

 On output, X starts the next write operation after skipping the "n"
 character positions.  Intervening characters are not written over.
 If X is the last format code executed, it will have no effect.

 The position specified must be in integer in the range 1 through
 the size of the record.
3 Z                         
 Zw[.m] (Hexadecimal Editing)

 On input, Z transfers "w" characters from the external field and
 assigns them, as a hexadecimal value, to the corresponding I/O list
 element (which can be any data type).  The input value must be in
 the form of a hexadecimal constant.  Each input character
 corresponds to four bits in the variable, high order to low order.
 If the input value contains more characters than specified by "w",
 an error occurs.  If the input value contains fewer characters, it
 is padded with zeros on the left before being converted.

 On output, Z transfers the number of hexadecimal characters
 specified by "w" from a variable or constant to the record.  The
 rightmost characters represent the low-order bits.  If the variable
 or constant contains more characters than "w" specifies, the value
 is set to all asterisks (an error occurs).  If the variable or
 constant contains fewer characters, the value is padded on the left
 with spaces.  "m" specifies the minimum number of characters (with
 zero padding) that the value can contain.  "m" must be an integer
 in the range 1 through 255.  "w" must be large enough to include a
 possible minus sign.  If "m" is present, the external field
 consists of at least "m" digits and, if necessary, is zero filled
 on the left.
2 Intrinsic_Procedures
3 ABS     
 ABS (number)

 A function that returns the absolute value of the argument.  The
 absolute value of a complex number, (X,Y), is the real value:
    (X**2 + Y**2)**(1/2).

 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  1   |  ABS    |  --      | INTEGER*1  | INTEGER*1   |
 |      |         | IIABS    | INTEGER*2  | INTEGER*2   |
 |      |         | JIABS    | INTEGER*4  | INTEGER*4   |
 |      |see note | KIABS    | INTEGER*8  | INTEGER*8   |
 |      |         | ABS      | REAL*4     | REAL*4      |
 |      |         | DABS     | REAL*8     | REAL*8      |
 |      |see note | QABS     | REAL*16    | REAL*16     |
 |      |         | CABS     | COMPLEX*8  | REAL*4      |
 |      |         | CDABS    | COMPLEX*16 | REAL*8      |
 |      |         | ZABS     | COMPLEX*16 | REAL*8      |
 +------+---------+----------+------------+-------------+

 NOTE: KIABS and QABS are only available on Alpha systems.

 See also the IABS intrinsic function.
3 ACOS    
 ACOS (number)

 A function that returns the arc cosine of the argument in radians.
 The absolute value of the argument must be less than or equal to 1.

 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  1   | ACOS    | ACOS     | REAL*4     | REAL*4      |
 |      |         | DACOS    | REAL*8     | REAL*8      |
 |      |see note | QACOS    | REAL*16    | REAL*16     |
 +------+---------+----------+------------+-------------+

 NOTE: QACOS is only available on Alpha systems.
3 ACOSD   
 ACOSD (real-number)

 A function that returns the arc cosine of the argument in degrees.
 The value of the argument must be between 0 (exclusive) and 1
 (inclusive).

 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  1   |  ACOSD  |  ACOSD   | REAL*4     | REAL*4      |
 |      |         |  DACOSD  | REAL*8     | REAL*8      |
 |      |see note |  QACOSD  | REAL*16    | REAL*16     |
 +------+---------+----------+------------+-------------+

 NOTE: QACOSD is only available on Alpha systems.
3 AIMAG   
 AIMAG (complex-number)

 A function that returns the imaginary part of a complex number.
 The argument must be a COMPLEX*8 data type.  The result is a REAL*4
 data type.

 The setting of -r8 affects AIMAG.
3 AINT    
 AINT (real-number)

 A function that returns the largest integer whose absolute value
 does not exceed the absolute value of the argument and has the same
 sign as the argument.

 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  1   |  AINT   | AINT     | REAL*4     | REAL*4      |
 |      |         | DINT     | REAL*8     | REAL*8      |
 |      |see note | QINT     | REAL*16    | REAL*16     |
 +------+---------+----------+------------+-------------+

 NOTE: QINT is only available on Alpha systems.

 See also the INT intrinsic function.
3 AMAX0   
 AMAX0 (number, number, ...)

 A function that returns the greatest of the values specified in the
 argument list.  There must be at least two arguments.

 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |   n  | AMAX0   |   --     | INTEGER*1  | REAL*4      |
 |      |         | AIMAX0   | INTEGER*2  | REAL*4      |
 |      |         | AJMAX0   | INTEGER*4  | REAL*4      |
 |      |see note | AKMAX0   | INTEGER*8  | REAL*4      |
 +------+---------+----------+------------+-------------+

 NOTE: AKMAX0 is only available on Alpha systems.
 See also the MAX intrinsic function.
3 AMIN0   
 AMIN0 (number, number, ...)

 A function that returns the lowest of the values specified in the
 argument list.  There must be at least two arguments.

 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  n   |  AMIN0  |   --     | INTEGER*1  | REAL*4      |
 |      |         | AIMIN0   | INTEGER*2  | REAL*4      |
 |      |         | AJMIN0   | INTEGER*4  | REAL*4      |
 |      |see note | AKMIN0   | INTEGER*8  | REAL*4      |
 +------+---------+----------+------------+-------------+

 NOTE: AKMIN0 is only available on Alpha systems.
 See also the MIN intrinsic function.
3 ANINT   
 ANINT (real-number)

 A function that returns the value of the integer nearest to the
 value of the argument.

 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  1   | ANINT   | ANINT    | REAL*4     | REAL*4      |
 |      |         | DNINT    | REAL*8     | REAL*8      |
 |      |see note | QNINT    | REAL*16    | REAL*16     |
 +------+---------+----------+------------+-------------+

 NOTE: QNINT is only available on Alpha systems.

 [x] is defined as the largest integer whose magnitude does not
 exceed the magnitude of x and whose sign is the same as that of x.

 See also the NINT intrinsic function.
3 ASIN    
 ASIN (real-number)

 A function that returns the arc sine of the argument in radians.
 The absolute value of the argument must be less than or equal to 1.

 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  1   |  ASIN   | ASIN     | REAL*4     | REAL*4      |
 |      |         | DASIN    | REAL*8     | REAL*8      |
 |      |see note | QASIN    | REAL*16    | REAL*16     |
 +------+---------+----------+------------+-------------+

 NOTE: QASIN is only available on Alpha systems.
3 ASIND   
 ASIND (real-number)

 A function that returns the arc sine of the argument in degrees.
 The value of the argument must be between 0 (exclusive) and 1
 (inclusive).

 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |   1  |  ASIND  | ASIND    | REAL*4     | REAL*4      |
 |      |         | DASIND   | REAL*8     | REAL*8      |
 |      |see note | QASIND   | REAL*16    | REAL*16     |
 +------+---------+----------+------------+-------------+

 NOTE: QASIND is only available on Alpha systems.
3 ATAN    
 ATAN (real-number)

 A function that returns the arc tangent of the argument in radians.

 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  1   |   ATAN  | ATAN     | REAL*4     | REAL*4      |
 |      |         | DATAN    | REAL*8     | REAL*8      |
 |      |see note | QATAN    | REAL*16    | REAL*16     |
 +------+---------+----------+------------+-------------+

 NOTE: QATAN is only available on Alpha systems.
3 ATAND   
 ATAND (real-number)

 A function that returns the arc tangent of the argument in degrees.
 The value of the argument must be greater than 0.

 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |   1  |  ATAND  | ATAND    | REAL*4     | REAL*4      |
 |      |         | DATAND   | REAL*8     | REAL*8      |
 |      |see note | QATAND   | REAL*16    | REAL*16     |
 +------+---------+----------+------------+-------------+

 NOTE: QATAND is only available on Alpha systems.
3 ATAN2   
 ATAN2 (real-number, real-number)

 A function that returns the arc tangent of the quotient of the two
 arguments in radians.  If both arguments are zero, the result is
 undefined.  If the first argument is positive, the result is
 positive.  If the first argument is negative, the result is
 negative.  If the first argument is zero, the result is zero.  If
 the second argument is zero, the absolute value of the result is
 pi/2.

 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  2   |  ATAN2  | ATAN2    | REAL*4     | REAL*4      |
 |      |         | DATAN2   | REAL*8     | REAL*8      |
 |      |see note | QATAN2   | REAL*16    | REAL*16     |
 +------+---------+----------+------------+-------------+

 NOTE: QATAN2 is only available on Alpha systems.

 The range of the result is -pi < result <= pi.
3 ATAN2D  
 ATAN2D (real-number, real-number)

 A function that returns the arc tangent of the quotient of the two
 arguments in degrees.  If both arguments are zero, the result is
 undefined.  If the first argument is positive, the result is
 positive.  If the first argument is negative, the result is
 negative.  If the first argument is zero, the result is zero.  If
 the second argument is zero, the absolute value of the result is 90
 degrees.  The value of the argument must be greater than zero.

 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |   2  | ATAN2D  | ATAN2D   | REAL*4     | REAL*4      |
 |      |         | DATAN2D  | REAL*8     | REAL*8      |
 |      |see note | QATAN2D  | REAL*16    | REAL*16     |
 +------+---------+----------+------------+-------------+

 NOTE: QATAN2D is only available on Alpha systems.

 The range of the result is -180 degrees < result <= 180 degrees.
3 BTEST   
 BTEST (integer, position)

 A function that returns a logical value of true if the bit within
 the integer specified by position is set to 1 (bit test).  The
 low-order bit is position 0.

 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |   2  |  BTEST  |   --     | INTEGER*1  | LOGICAL*4   |
 |      |         | BITEST   | INTEGER*2  | LOGICAL*2   |
 |      |         | BJTEST   | INTEGER*4  | LOGICAL*4   |
 |      |see note | BKTEST   | INTEGER*8  | LOGICAL*8   |
 +------+---------+----------+------------+-------------+

 NOTE: BKTEST is only available on Alpha systems.
3 CHAR    
 CHAR (integer)

 A function that returns the character that has the numeric value
 specified by the argument.  The input value must be in the range 0
 to 255.

 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  1   |   --    | CHAR     | LOGICAL*1  | CHARACTER   |
 |      |         |  --      | INTEGER*1  | CHARACTER   |
 |      |         |  --      | INTEGER*2  | CHARACTER   |
 |      |         |  --      | INTEGER*4  | CHARACTER   |
 |      |see note |  --      | INTEGER*8  | CHARACTER   |
 +------+---------+----------+------------+-------------+

 NOTE: INTEGER*8 is only available on Alpha systems.
3 CMPLX   
 CMPLX (number [,number])

 A function that converts the argument(s) into a COMPLEX*8 value.
 If one argument is specified, the argument is converted into the
 real part of the complex value and the imaginary part becomes zero.
 If two arguments are specified, the first argument is converted
 into the real part of the complex value and the second argument is
 converted into the imaginary part of the complex value.  If two
 arguments are specified, they must have the same data type.

 +------+-----------+----------+------------+-------------+       
 | Args | Generic   | Specific |  Argument  | Result Type |
 +------+-----------+----------+------------+-------------+
 | 1,2  |  CMPLX    |   --     | INTEGER*1  | COMPLEX*8   |
 | 1,2  |           |   --     | INTEGER*2  | COMPLEX*8   |
 | 1,2  |           |   --     | INTEGER*4  | COMPLEX*8   |
 | 1,2  |see note   |   --     | INTEGER*8  | COMPLEX*8   |
 | 1,2  |           |   --     | REAL*4     | COMPLEX*8   |
 | 1,2  |           |   --     | REAL*8     | COMPLEX*8   |
 | 1,2  |see note   |   --     | REAL*16    | COMPLEX*8   |
 |  1   |           |   --     | COMPLEX*8  | COMPLEX*8   |
 |  1   |           |   --     | COMPLEX*16 | COMPLEX*8   |
 +------+-----------+----------+------------+-------------+

 NOTE: This argument type is only available on Alpha systems.

 The setting of -r8 affects CMPLX.
3 CONJG   
 CONJG (complex-number)

 A function that returns the complex conjugate of the argument.  If
 the argument is (X,Y), its complex conjugate is (X,-Y).

 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |   1  |  CONJG  | CONJG    | COMPLEX*8  | COMPLEX*8   |
 |      |         | DCONJG   | COMPLEX*16 | COMPLEX*16  |
 +------+---------+----------+------------+-------------+
3 COS     
 COS (number)

 A function that returns the cosine of the argument.  The argument
 must be in radians; it is treated modulo 2*pi.

 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |   1  |  COS    | COS      | REAL*4     | REAL*4      |
 |      |         | DCOS     | REAL*8     | REAL*8      |
 |      |see note | QCOS     | REAL*16    | REAL*16     |
 |      |         | CCOS     | COMPLEX*8  | COMPLEX*8   |
 |      |         | CDCOS    | COMPLEX*16 | COMPLEX*16  |
 |      |         | ZCOS     | COMPLEX*16 | COMPLEX*16  |
 +------+---------+----------+------------+-------------+

 NOTE: QCOS is only available on Alpha systems.
3 COSD    
 COSD (number)

 A function that returns the cosine of the argument.  The argument
 must be in degrees; it is treated modulo 360.

 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  1   |   COSD  | COSD     | REAL*4     | REAL*4      |
 |      |         | DCOSD    | REAL*8     | REAL*8      |
 |      |see note | QCOSD    | REAL*16    | REAL*16     |
 +------+---------+----------+------------+-------------+

 NOTE: QCOSD is only available on Alpha systems.
3 COSH    
 COSH (real-number)

 A function that returns the hyperbolic cosine of the argument.

 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |   1  | COSH    | COSH     | REAL*4     | REAL*4      |
 |      |         | DCOSH    | REAL*8     | REAL*8      |
 |      |see note | QCOSH    | REAL*16    | REAL*16     |
 +------+---------+----------+------------+-------------+

 NOTE: QCOSH is only available on Alpha systems.
3 DATE    
 CALL DATE (buf)

 buf  Is a 9-byte variable, array, array element, 
      or character substring.

 A subroutine that gets the current date as set within the system.
 The date is returned as a 9-byte ASCII character string as follows:

   dd-mmm-yy

 If "buf" is numeric type and smaller than 9 bytes, data corruption
 can occur.

 If "buf" is character type, its associated length is passed to the
 subroutine.  If "buf" is smaller than 9 bytes, the subroutine
 truncates the date to fit in the specified length.  Note that if a
 CHARACTER array is passed, the subroutine stores the date in the
 first array element, using the element length, not the length of
 the entire array.  For example, consider the following:

 CHARACTER*1 DAY(9)
    .
    .
    .
 CALL DATE(DAY)

 The length of the first array element in CHARACTER array DAY is
 passed to the DATE subroutine.  The subroutine then truncates the
 date to fit into the one-character element, producing an incorrect
 result.
3 DBLE    
 DBLE (number)

 A function that converts the argument into a REAL*8 value.

 +------+-----------+----------+------------+-------------+        
 | Args | Generic   | Specific |  Argument  | Result Type |
 +------+-----------+----------+------------+-------------+
 |  1   |  DBLE     |   --     | INTEGER*1  | REAL*8      |
 |      |           |   --     | INTEGER*2  | REAL*8      |
 |      |           |   --     | INTEGER*4  | REAL*8      |
 |      |see note 1 |   --     | INTEGER*8  | REAL*8      |         
 |      |           |  DBLE    | REAL*4     | REAL*8      |
 |      |           |   --     | REAL*8     | REAL*8      |
 |      |see note 2 |  DBLEQ   | REAL*16    | REAL*8      |
 |      |           |   --     | COMPLEX*8  | REAL*8      |
 |      |           |   --     | COMPLEX*16 | REAL*8      |
 +------+-----------+----------+------------+-------------+

 NOTE 1: This argument type is only available on Alpha systems.
 NOTE 2: DBLEQ is only available on Alpha systems.
3 DCMPLX  
 DCMPLX (number [,number])

 A function that converts the argument(s) into a COMPLEX*16 value.
 If one argument is specified, the argument is converted into the
 real part of the complex value and the imaginary part becomes zero.
 If two arguments are specified, the first argument is converted
 into the real part of the complex value and the second argument is
 converted into the imaginary part of the complex value.  If two
 arguments are specified, they must have the same data type.

 +-------+----------+----------+------------+-------------+       
 | Args  | Generic  | Specific |  Argument  | Result Type |
 +-------+----------+----------+------------+-------------+
 | 1,2   | DCMPLX   |   --     | INTEGER*1  | COMPLEX*16  |
 | 1,2   |          |   --     | INTEGER*2  | COMPLEX*16  |
 | 1,2   |          |   --     | INTEGER*4  | COMPLEX*16  |
 | 1,2   |see note  |   --     | INTEGER*8  | COMPLEX*16  |
 | 1,2   |          |   --     | REAL*4     | COMPLEX*16  |
 | 1,2   |          |   --     | REAL*8     | COMPLEX*16  |
 | 1,2   |see note  |   --     | REAL*16    | COMPLEX*16  |
 |  1    |          |   --     | COMPLEX*8  | COMPLEX*16  |
 |  1    |          |   --     | COMPLEX*16 | COMPLEX*16  |
 +-------+----------+----------+------------+-------------+

 NOTE: This argument type is only available on Alpha systems.
3 DFLOAT  
 DFLOAT (integer)

 A function that converts the argument into a REAL*8 value.

 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  1   |  DFLOAT |   --     | INTEGER*1  | REAL*8      |
 |      |         | DFLOTI   | INTEGER*2  | REAL*8      |
 |      |         | DFLOTJ   | INTEGER*4  | REAL*8      |
 |      |see note | DFLOTK   | INTEGER*8  | REAL*8      |
 +------+---------+----------+------------+-------------+

 NOTE: DFLOTK is only available on Alpha systems.
3 DIM     
 DIM (number, number)

 A function that returns the value of the first argument minus the
 minimum (MIN) of the two arguments.

 +------+----------+----------+------------+-------------+        
 | Args | Generic  | Specific |  Argument  | Result Type |
 +------+----------+----------+------------+-------------+
 |   2  |  DIM     |   --     | INTEGER*1  | INTEGER*1   |
 |      |          | IIDIM    | INTEGER*2  | INTEGER*2   |
 |      |          | JIDIM    | INTEGER*4  | INTEGER*4   |
 |      |see note  | KIDIM    | INTEGER*8  | INTEGER*8   |
 |      |          | DIM      | REAL*4     | REAL*4      |
 |      |          | DDIM     | REAL*8     | REAL*8      |
 |      |see note  | QDIM     | REAL*16    | REAL*16     |
 +------+----------+----------+------------+-------------+

 NOTE: KIDIM and QDIM are only available on Alpha systems.

 See also the IDIM intrinsic function.
3 DIMAG   
 DIMAG (imaginary)

 A function that returns the imaginary part of a complex number.
 The argument must be a COMPLEX*16 data type.  The result is a
 REAL*8 data type.
3 DPROD   
 DPROD (real-number, real-number)

 A function that returns the product of two REAL values as a DOUBLE
 PRECISION value.

 +------+----------+----------+------------+-------------+        
 | Args | Generic  | Specific |  Argument  | Result Type |
 +------+----------+----------+------------+-------------+
 |   2  |  DPROD   |  DPROD   | REAL*4     | REAL*8      |
 |      |          |   --     | REAL*8     | REAL*16     |
 +------+----------+----------+------------+-------------+
3 DREAL   
 DREAL (complex-number)

 A function that returns the real part of a complex number.  The
 argument must be a COMPLEX*16 data type.  The result is a REAL*8
 data type.
3 EXIT    
 CALL EXIT [(exit-status)]

 A subroutine that terminates the program, closes all files, and
 returns control to the operating system.  The optional argument
 specifies the exit-status value of the program.
3 EXP     
 EXP (exponent)

 A function that returns e**X, where X is the value of the argument.

 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  1   |  EXP    | EXP      | REAL*4     | REAL*4      |
 |      |         | DEXP     | REAL*8     | REAL*8      |
 |      |see note | QEXP     | REAL*16    | REAL*16     |
 |      |         | CEXP     | COMPLEX*8  | COMPLEX*8   |
 |      |         | CDEXP    | COMPLEX*16 | COMPLEX*16  |
 |      |         | ZEXP     | COMPLEX*16 | COMPLEX*16  |
 +------+---------+----------+------------+-------------+

 NOTE: QEXP is only available on Alpha systems.
3 FLOAT   
 FLOAT (integer)

 A function that converts the argument to a REAL*4 value.

 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  1   |  FLOAT  |   --     | INTEGER*1  | REAL*4      |
 |      |         | FLOATI   | INTEGER*2  | REAL*4      |
 |      |         | FLOATJ   | INTEGER*4  | REAL*4      |
 |      |see note | FLOATK   | INTEGER*8  | REAL*4      |
 +------+---------+----------+------------+-------------+

 NOTE: FLOATK is only available on Alpha systems.

 The setting of -r8 affects FLOAT.
3 FP_CLASS
 FP_CLASS (real-number)

 A function that returns the class of an IEEE real (S_floating,
 T_floating, or X_floating) argument.  This function is only
 available on Alpha systems.

 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  1   | FP_CLASS|          | REAL*4     | INTEGER*4   |
 |      |         |          | REAL*8     | INTEGER*4   |
 |      |         |          | REAL*16    | INTEGER*4   |
 +------+---------+----------+------------+-------------+

 Return values are defined in $FOR_FP_CLASS in FORSYSDEF.TLB.  For
 more information, see your user manual.
3 IABS    
 IABS (number)

 A function that returns the absolute value of the argument.  The
 absolute value of a complex number, (X,Y), is the real value
 SQRT(X**2 + Y**2).

 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  1   |  IABS   |  --      | INTEGER*1  | INTEGER*1   |
 |      |         | IIABS    | INTEGER*2  | INTEGER*2   |
 |      |         | JIABS    | INTEGER*4  | INTEGER*4   |
 |      |see note | KIABS    | INTEGER*8  | INTEGER*8   |
 +------+---------+----------+------------+-------------+

 NOTE: KIABS is only available on Alpha systems.
 See also the ABS intrinsic function.
3 IAND    
 IAND (integer, integer)

 A function that performs a logical AND of the arguments on a bit by
 bit basis (bitwise AND).

 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  2   |  IAND   |  --      | INTEGER*1  | INTEGER*1   |
 |      |         | IIAND    | INTEGER*2  | INTEGER*2   |
 |      |         | JIAND    | INTEGER*4  | INTEGER*4   |
 |      |see note | KIAND    | INTEGER*8  | INTEGER*8   |
 +------+---------+----------+------------+-------------+

 NOTE: KIAND is only available on Alpha systems.
3 IARGPTR 
 IARGPTR ()

 A function that returns a pointer to the actual argument list for
 the current routine.  IARGPTR takes no arguments and returns an
 INTEGER*8 address of the calling-standard defined "argument block".

 The address of the first actual argument is one quadword past the
 beginning of the "argument block".

 The following example shows the IARGPTR intrinsic:

 C      Test IARGPTR intrinsic function.
        EXTERNAL test_argptr
        INTEGER*4 x,y,z,foo
        x = 10
        y = 20
        z = 100
        foo = 4
  
        print 80, %LOC(x), %LOC(y), %LOC(z), %LOC(foo)
 80     format (' Argument addresses: ',4(1x, Z16))
        CALL test_argptr (4, x, y, z, foo)
        END

        OPTIONS /EXTEND_SOURCE
        SUBROUTINE test_argptr (N_ARGS)
        POINTER (II, I_ARGN)
        INTEGER*8 I_ARGN
        POINTER (I_PTR, I_VAL)
        INTEGER I_VAL
               
        II = IARGPTR()             ! Get address of arg block
        II = II + SIZEOF (II)      ! Get address of address of first arg

        DO I = 1, N_ARGS+1
         I_PTR = I_ARGN            ! Get address of actual from homed
                                   !   arg list
         print 90, I, I_PTR, I_VAL
 90      format ( ' Argument ',I2, ' address = ',Z16, ', contents = ',Z16)
         II = II + SIZEOF (II)  ! Get address of address of next arg
        END DO
        RETURN
        END
3 IBCLR   
 IBCLR (integer, position)

 A function that returns the value of the first argument with the
 specified bit set to 0 (bit clear).  The low-order bit is position
 0.

 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  2   |  IBCLR  |   --     | INTEGER*1  | INTEGER*1   |
 |      |         | IIBCLR   | INTEGER*2  | INTEGER*4   |
 |      |         | JIBCLR   | INTEGER*4  | INTEGER*4   |
 |      |see note | KIBCLR   | INTEGER*8  | INTEGER*8   |
 +------+---------+----------+------------+-------------+

 NOTE: KIBCLR is only available on Alpha systems.
3 IBITS   
 IBITS (integer, start-position, length)

 A function that returns the value of the bits of the first argument
 specified by start-position and number of bits.  The low-order bit
 is position 0.

 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  3   |  IBITS  |   --     | INTEGER*1  | INTEGER*1   |
 |      |         | IIBITS   | INTEGER*2  | INTEGER*4   |
 |      |         | JIBITS   | INTEGER*4  | INTEGER*4   |
 |      |see note | KIBITS   | INTEGER*8  | INTEGER*8   |
 +------+---------+----------+------------+-------------+

 NOTE: KIBITS is only available on Alpha systems.
3 IBSET   
 IBSET (integer, position)

 A function that returns the value of the first argument with the
 specified bit set to 1 (bit set).  The low-order bit is position 0.

 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  2   |  IBSET  |   --     | INTEGER*1  | INTEGER*1   |
 |      |         | IIBSET   | INTEGER*2  | INTEGER*2   |
 |      |         | JIBSET   | INTEGER*4  | INTEGER*4   |
 |      |see note | KIBSET   | INTEGER*8  | INTEGER*8   |
 +------+---------+----------+------------+-------------+

 NOTE: KIBSET is only available on Alpha systems.
3 ICHAR   
 ICHAR (character)

 A function that returns the ASCII value of the argument.  The
 argument must be a character expression with a length of one.

 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  1   |   --    | ICHAR    | CHARACTER  | INTEGER*2   |
 |      |         |  --      | CHARACTER  | INTEGER*4   |
 |      |see note |  --      | CHARACTER  | INTEGER*8   |
 +------+---------+----------+------------+-------------+

 NOTE: INTEGER*8 is only available on Alpha systems.
3 IDATE   
 CALL IDATE (month,day,year)

 A subroutine that returns three values representing the current
 date.  The arguments must be defined as integers or integer array
 elements.  The month is represented as the number of the month (1 -
 12).  The day is represented as the day of the month.  The year is
 represented as the last two digits of the year.
3 IDIM    
 IDIM (number, number)

 A function that returns the value of the first argument minus the
 minimum (MIN) of the two arguments.

 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  2   |  IDIM   |   --     | INTEGER*1  | INTEGER*1   |
 |      |         | IIDIM    | INTEGER*2  | INTEGER*2   |
 |      |         | JIDIM    | INTEGER*4  | INTEGER*4   |
 |      |see note | KIDIM    | INTEGER*8  | INTEGER*8   |
 +------+---------+----------+------------+-------------+

 NOTE: KIDIM is only available on Alpha systems.
 See also the DIM intrinsic function.
3 IDINT   
 IDINT (number)

 A function that returns the largest integer whose absolute value
 does not exceed the absolute value of the argument and has the same
 sign as the argument.

 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  1   | IDINT   | IIDINT   | REAL*8     | INTEGER*2   |
 |      |         | JIDINT   | REAL*8     | INTEGER*4   |
 |      |see note | KIDINT   | REAL*4     | INTEGER*8   |
 +------+---------+----------+------------+-------------+

 NOTE: KIDINT is only available on Alpha systems.

 The setting of -noi4 or -i8 (Alpha only) affects IDINT.

 See also the INT intrinsic function.
3 IDNINT  
 IDNINT (real-number)

 A function that returns the value of the integer nearest to the
 value of the argument.

 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  1   | IDNINT  | IIDNNT   | REAL*8     | INTEGER*2   |
 |      |         | JIDNNT   | REAL*8     | INTEGER*4   |
 |      |see note | KIDNNT   | REAL*8     | INTEGER*8   |
 +------+---------+----------+------------+-------------+

 NOTE: KIDNNT is only available on Alpha systems.

 The setting of -noi4 or -i8 (Alpha only) affects IDNINT.

 See also the NINT intrinsic function.
3 IEOR    
 IEOR (integer, integer)

 A function that performs an exclusive OR of the arguments on a bit
 by bit basis (bit exclusive OR).

 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  2   | IEOR    |   --     | INTEGER*1  | INTEGER*1   |
 |      |         | IIEOR    | INTEGER*2  | INTEGER*2   |
 |      |         | JIEOR    | INTEGER*4  | INTEGER*4   |
 |      |see note | KIEOR    | INTEGER*8  | INTEGER*8   |
 +------+---------+----------+------------+-------------+

 NOTE: KIEOR is only available on Alpha systems.
3 IFIX    
 IFIX (real4-number)

 A function that converts a real number to an integer.

 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  1   |  IFIX   | IIFIX    | REAL*4     | INTEGER*2   |
 |      |         | JIFIX    | REAL*4     | INTEGER*4   |
 |      |see note | KIFIX    | REAL*4     | INTEGER*8   |
 +------+---------+----------+------------+-------------+

 NOTE: KIFIX is only available on Alpha systems.
 The function returns an INTEGER*4 value if the -i4 command option
 is in effect; otherwise it returns an INTEGER*2 value.

 IIFIX can also be spelled HFIX (to comply with the MIA standard).

 The setting of -noi4 or -i8 (Alpha only) affects IFIX.
3 IMAG    
 IMAG (complex-number)

 A function that returns the imaginary part of a complex number.
 +------+-----------+----------+------------+-------------+        
 | Args | Generic   | Specific |  Argument  | Result Type |
 +------+-----------+----------+------------+-------------+
 |  1   |  IMAG     |  AIMAG   | COMPLEX*8  | REAL*4      |
 |      |           |  DIMAG   | COMPLEX*16 | REAL*8      |
 +--------------------------------------------------------+

 The setting of -r8 affects AIMAG.
3 INDEX   
 INDEX (string, substring)

 A function that searches a string for the first occurrence of a
 substring and returns the starting position of the substring as an
 INTEGER*4 or INTEGER*8 (Alpha only) value.
3 INT     
 INT (number)

 A function that returns the largest integer whose absolute value
 does not exceed the absolute value of the argument and has the same
 sign as the argument.
 +------+-----------+----------+------------+-------------+        
 | Args | Generic   | Specific |  Argument  | Result Type |
 +------+-----------+----------+------------+-------------+
 |  1   |  INT      |  --      | INTEGER*1  | INTEGER*2   |
 |      |           |  --      | INTEGER*1  | INTEGER*4   |
 |      |see note 1 |  --      | INTEGER*1  | INTEGER*8   |
 |      |           |  --      | INTEGER*2  | INTEGER*4   |
 |      |see note 1 |  --      | INTEGER*2  | INTEGER*8   |
 |      |           |  --      | INTEGER*4  | INTEGER*4   |
 |      |see note 1 |  --      | INTEGER*4  | INTEGER*8   |
 |      |see note 1 |  --      | INTEGER*8  | INTEGER*8   |
 |      |           | IINT     | REAL*4     | INTEGER*2   |
 |      |           | JINT     | REAL*4     | INTEGER*4   |
 |      |see note 2 | KINT     | REAL*4     | INTEGER*8   |
 |      |           | IIDINT   | REAL*8     | INTEGER*2   |
 |      |           | JIDINT   | REAL*8     | INTEGER*4   |
 |      |see note 2 | KIDINT   | REAL*4     | INTEGER*8   |
 |      |see note 2 | IIQINT   | REAL*16    | INTEGER*2   |
 |      |see note 2 | JIQINT   | REAL*16    | INTEGER*4   |
 |      |see note 2 | KIQINT   | REAL*16    | INTEGER*8   |
 |      |           |  --      | COMPLEX*8  | INTEGER*2   |
 |      |           |  --      | COMPLEX*8  | INTEGER*4   |
 |      |see note 1 |  --      | COMPLEX*8  | INTEGER*8   |
 |      |           |  --      | COMPLEX*16 | INTEGER*2   |
 |      |           |  --      | COMPLEX*16 | INTEGER*4   |
 |      |see note 1 |  --      | COMPLEX*16 | INTEGER*8   |
 +------+-----------+----------+------------+-------------+

 NOTE 1: INTEGER*8 is only available on Alpha systems.
 NOTE 2: KINT, KIDINT, IIQINT, JIQINT, and KIQINT are only 
         available on Alpha systems.

 The setting of -noi4 or -i8 (Alpha only) affects INT.

 See also AINT, IDINT, and IQINT.
3 IOR     
 IOR (integer, integer)

 A function that performs a logical OR of the arguments on a bit by
 bit basis (bitwise inclusive OR).
 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  2   |  IOR    |  --      | INTEGER*1  | INTEGER*1   |
 |      |         | IIOR     | INTEGER*2  | INTEGER*2   |
 |      |         | JIOR     | INTEGER*4  | INTEGER*4   |
 |      |see note | KIOR     | INTEGER*8  | INTEGER*8   |
 +------+---------+----------+------------+-------------+

 NOTE: KIOR is only available on Alpha systems.
3 IQINT   
 IQINT (number)

 This function is only available on Alpha systems.

 A function that returns the largest integer whose absolute value
 does not exceed the absolute value of the argument and has the same
 sign as the argument.
 +------+---------+----------+------------+-------------+      
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |   1  |  IQINT  | IIQINT   | REAL*16    | INTEGER*2   |
 |      |         | JIQINT   | REAL*16    | INTEGER*4   |
 |      |         | KIQINT   | REAL*16    | INTEGER*8   |
 +------+---------+----------+------------+-------------+
 The function returns an INTEGER*4 value if the /I4 command
 qualifier is in effect; otherwise, it returns an INTEGER*2 value.

 See also the INT intrinsic function.
3 IQNINT  
 IQNINT (number)

 This function is only available on Alpha systems.

 A function that returns the value of the integer nearest to the
 value of the argument.
 +------+---------+----------+------------+-------------+      
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  1   | IQNINT  | IIQNNT   | REAL*16    | INTEGER*2   |
 |      |         | JIQNNT   | REAL*16    | INTEGER*4   |
 |      |         | KIQNNT   | REAL*16    | INTEGER*8   |
 +------+---------+----------+------------+-------------+
 The function returns an INTEGER*4 value if the /I4 command
 qualifier is in effect; otherwise, it returns an INTEGER*2 value.

 See also the NINT intrinsic function.
3 ISHFT   
 ISHFT (a1,a2)

 Bitwise logical shift - a1 is an integer, a2 is the no-of-positions

 A function that logically shifts a1 left (if a2 is positive) or
 right (if a2 is negative) by ABS(a2) bits.  If ABS(a2) is greater
 than or equal to the length in bits of a1, the result is 0.
 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  2   |  ISHFT  |   --     | INTEGER*1  | INTEGER*1   |
 |      |         | IISHFT   | INTEGER*2  | INTEGER*2   |
 |      |         | JISHFT   | INTEGER*4  | INTEGER*4   |
 |      |see note | KISHFT   | INTEGER*8  | INTEGER*8   |
 +------+---------+----------+------------+-------------+

 NOTE: KISHFT is only available on Alpha systems.
3 ISHFTC  
 ISHFTC (a1,a2,a3)

 Bitwise circular shift - a1 is an integer, a2 is no-of-positions,
 and a3 is no-of-bits

 A function that circularly shifts the rightmost a3 bits of a1 by a2
 places; bits in a1 beyond the value specified by a3 are unaffected.
 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  3   | ISHFTC  | IISHFTC  | INTEGER*2  | INTEGER*4   |
 |      |         | JISHFTC  | INTEGER*4  | INTEGER*4   |
 |      |see note | KISHFTC  | INTEGER*8  | INTEGER*8   |
 +------+---------+----------+------------+-------------+
 NOTE: KISHFTC is only available on Alpha systems.
3 ISIGN   
 ISIGN (value, sign)

 A function that assigns the sign of the second argument to the
 absolute value of the first.
 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  2   |  ISIGN  |   --     | INTEGER*1  | INTEGER*1   |
 |      |         | IISIGN   | INTEGER*2  | INTEGER*2   |
 |      |         | JISIGN   | INTEGER*4  | INTEGER*4   |
 |      |see note | KISIGN   | INTEGER*8  | INTEGER*8   |
 +------+---------+----------+------------+-------------+

 NOTE: KISIGN is only available on Alpha systems.
 See also the SIGN intrinsic function.
3 ISNAN   
 ISNAN (real-number)

 A function that tests whether IEEE REAL*4 (S_floating) and REAL*8
 (T_floating) numbers are Not-a-Number (NaN) values.

 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  1   |  ISNAN  |   --     | REAL*4     | LOGICAL*4   |
 |      |         |          | REAL*8     | LOGICAL*4   |
 +------+---------+----------+------------+-------------+
3 LEN     
 LEN (character)

 A function that returns the number of characters in the argument.
 The argument must be a character expression.  The result is an
 INTEGER*4 or INTEGER*8 (Alpha only) value.
3 LGE     
 LGE (character, character)

 A function that returns a value of true if the first character
 string is greater than or equal to the second character string.
 The ASCII collating sequence determines the relationship between
 the arguments.  The arguments must be character expressions.  The
 result is a LOGICAL*4 value.
3 LGT     
 LGT (character, character)

 A function that returns a value of true if the first character
 string is greater than the second character string.  The arguments
 must be character expressions.  The ASCII collating sequence
 determines the relationship between the arguments.  The result is a
 LOGICAL*4 value.
3 LLE     
 LLE (character, character)

 A function that returns a value of true if the first character
 string is less than or equal to the second character string.  The
 arguments must be character expressions.  The ASCII collating
 sequence determines the relationship between the arguments.  The
 result is a LOGICAL*4 value.
3 LLT     
 LLT (character, character)

 A function that returns a value of true if the first character
 string is less than the second character string.  The arguments
 must be character expressions.  The ASCII collating sequence
 determines the relationship between the arguments.  The result is a
 LOGICAL*4 value.
3 LOC     
 LOC (arg)

 Returns the internal address of a storage item.  The argument can
 be a variable, an array or record field reference, a procedure, or
 a constant; it can be of any valid data type.  The result type is
 INTEGER*4.

 The LOC intrinsic serves the same purpose as the %LOC built-in
 function.
3 LOG     
 LOG (number)

 A function that returns the natural log (base e) of the argument.
 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  1   |  LOG    | ALOG     | REAL*4     | REAL*4      |
 |      |         | DLOG     | REAL*8     | REAL*8      |
 |      |see note | QLOG     | REAL*16    | REAL*16     |
 |      |         | CLOG     | COMPLEX*8  | COMPLEX*8   |
 |      |         | CDLOG    | COMPLEX*16 | COMPLEX*16  |
 |      |         | ZLOG     | COMPLEX*16 | COMPLEX*16  |
 +------+---------+----------+------------+-------------+

 NOTE: QLOG is only available on Alpha systems.

 The argument for ALOG and DLOG must be greater than zero.  The
 argument for CLOG and CDLOG must not be (0.,0.).
3 LOG10   
 LOG10 (number)

 A function that returns the common log (base 10) of the argument.
 The argument must be greater than zero.
 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  1   |  LOG10  | ALOG10   | REAL*4     | REAL*4      |
 |      |         | DLOG10   | REAL*8     | REAL*8      |
 |      |see note | QLOG10   | REAL*16    | REAL*16     |
 +------+---------+----------+------------+-------------+

 NOTE: QLOG10 is only available on Alpha systems.

 The argument for ALOG10, DLOG10, and QLOG10 must be greater than
 zero.
3 MAX     
 MAX (number, number, ...)

 A function that returns the greatest of the values specified in the
 argument list.
 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  n   |  MAX    |   --     | INTEGER*1  | INTEGER*1   |
 |      |         | IMAX0    | INTEGER*2  | INTEGER*2   |
 |      |         | JMAX0    | INTEGER*4  | INTEGER*4   |
 |      |see note | KMAX0    | INTEGER*8  | INTEGER*8   |
 |      |         | AMAX1    | REAL*4     | REAL*4      |
 |      |         | DMAX1    | REAL*8     | REAL*8      |
 |      |see note | QMAX1    | REAL*16    | REAL*16     |
 +------+---------+----------+------------+-------------+

 NOTE: KMAX0 and QMAX1 are only available on Alpha systems.

 See also the AMAX0, MAX0, and MAX1 intrinsic functions.
3 MAX0    
 MAX0 (number, number, ...)

 A function that returns the greatest of the values specified in the
 argument list.
 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  n   | MAX0    |   --     | INTEGER*1  | INTEGER*1   |
 |      |         | IMAX0    | INTEGER*2  | INTEGER*2   |
 |      |         | JMAX0    | INTEGER*4  | INTEGER*4   |
 |      |see note | KMAX0    | INTEGER*8  | INTEGER*8   |
 +------+---------+----------+------------+-------------+

 NOTE: KMAX0 is only available on Alpha systems.
 See also the MAX intrinsic function.
3 MAX1    
 MAX1 (number, number, ...)

 A function that returns the greatest of the values specified in the
 argument list.
 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  n   |  MAX1   | IMAX1    | REAL*4     | INTEGER*2   |
 |      |         | JMAX1    | REAL*4     | INTEGER*4   |
 |      |see note | KMAX1    | REAL*4     | INTEGER*8   |
 +------+---------+----------+------------+-------------+

 NOTE: KMAX1 is only available on Alpha systems.

 The setting of -noi4 or -i8 (Alpha only) affects MAX1.

 See also the MAX intrinsic function.
3 MIN     
 MIN (number, number, ...)

 A function that returns the lowest of the values specified in the
 argument list.
 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  n   |  MIN    |   --     | INTEGER*1  | INTEGER*1   |
 |      |         | IMIN0    | INTEGER*2  | INTEGER*2   |
 |      |         | JMIN0    | INTEGER*4  | INTEGER*4   |
 |      |see note | KMIN0    | INTEGER*8  | INTEGER*8   |
 |      |         | AMIN1    | REAL*4     | REAL*4      |
 |      |         | DMIN1    | REAL*8     | REAL*8      |
 |      |see note | QMIN1    | REAL*16    | REAL*16     |
 +------+---------+----------+------------+-------------+

 NOTE: KMIN0 and QMIN1 are only available on Alpha systems.

 See also the AMIN0, MIN0, and MIN1 intrinsic functions.
3 MIN0    
 MIN0

 A function that returns the lowest of the values specified in the
 argument list.
 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  n   |  MIN0   |  --      | INTEGER*1  | INTEGER*1   |
 |      |         | IMIN0    | INTEGER*2  | INTEGER*2   |
 |      |         | JMIN0    | INTEGER*4  | INTEGER*4   |
 |      |see note | KMIN0    | INTEGER*8  | INTEGER*8   |
 +------+---------+----------+------------+-------------+

 NOTE: KMIN0 is only available on Alpha systems.
 See also the MIN intrinsic function.
3 MIN1    
 MIN1

 A function that returns the lowest of the values specified in the
 argument list.
 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  n   |  MIN1   | IMIN1    | REAL*4     | INTEGER*2   |
 |      |         | JMIN1    | REAL*4     | INTEGER*4   |
 |      |see note | KMIN1    | REAL*4     | INTEGER*8   |
 +------+---------+----------+------------+-------------+

 NOTE: KMIN1 is only available on Alpha systems.

 The setting of -noi4 or -i8 (Alpha only) affects MIN1.

 See also the MIN intrinsic function.
3 MOD     
 MOD (dividend, divisor)

 A function that divides the first argument by the second and
 returns the remainder.
 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  2   |  MOD    |  --      | INTEGER*1  | INTEGER*1   |
 |      |         | IMOD     | INTEGER*2  | INTEGER*2   |
 |      |         | JMOD     | INTEGER*4  | INTEGER*4   |
 |      |see note | KMOD     | INTEGER*8  | INTEGER*8   |
 |      |         | AMOD     | REAL*4     | REAL*4      |
 |      |         | DMOD     | REAL*8     | REAL*8      |
 |      |see note | QMOD     | REAL*16    | REAL*16     |
 +------+---------+----------+------------+-------------+

 NOTE: KMOD and QMOD are only available on Alpha systems.
3 MVBITS  
 CALL MVBITS (integer1, start1, len, integer2, start2)

 A subroutine that moves bits from one location to another.  The
 following arguments can be of any integer data type:

    integer1   Is an integer variable or array element that 
               contains the bits to be transferred.

    start1     Is an integer expression that identifies the 
               position of the first bit within "integer1" 
               to be transferred.

    len        Is an integer expression that specifies the 
               number of bits to be transferred.

    integer2   Is an integer variable or array element that 
               identifies the location to which the bits are 
               being transferred.

    start2     Is an integer expression that identifies the 
               starting position within "integer2" for the bits 
               being transferred.

 The low-order bit in either integer is position 0.  The values of
 start1+len must be < 32, and start2+len must be <= 32.

 You can also specify the following specific subroutines:

   IMVBITS   All arguments must be INTEGER*2.
   JMVBITS   Arguments can be INTEGER*2 or INTEGER*4; at least 
             one must be INTEGER*4.
   KMVBITS   Arguments can be INTEGER*2, INTEGER*4, or INTEGER*8; 
             at least one must be INTEGER*8.
3 NINT    
 NINT (real-number)

 A function that returns the value of the integer nearest to the
 value of the argument.
 +------+-----------+----------+------------+-------------+        
 | Args | Generic   | Specific |  Argument  | Result Type |
 +------+-----------+----------+------------+-------------+
 |   1  |  NINT     | ININT    | REAL*4     | INTEGER*2   |
 |      |           | JNINT    | REAL*4     | INTEGER*4   |
 |      |see note   | KNINT    | REAL*4     | INTEGER*8   |
 |      |           | IIDNNT   | REAL*8     | INTEGER*2   |
 |      |           | JIDNNT   | REAL*8     | INTEGER*4   |
 |      |see note   | KIDNNT   | REAL*8     | INTEGER*8   |
 |      |see note   | IIQNNT   | REAL*16    | INTEGER*2   |
 |      |see note   | JIQNNT   | REAL*16    | INTEGER*4   |
 |      |see note   | KIQNNT   | REAL*16    | INTEGER*8   |
 +------+-----------+----------+------------+-------------+

 NOTE: KNINT, KIDNNT, IIQNNT, JIQNNT, and KIQNNT are only 
       available on Alpha systems.

 The setting of -noi4 or -i8 (Alpha only) affects NINT.

 See also the ANINT, IDNINT, and IQNINT intrinsic functions.
3 NOT     
 NOT (integer)

 A function that complements each bit of the argument (bitwise
 complement).
 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  1   |  NOT    |  --      | INTEGER*1  | INTEGER*1   |
 |      |         | INOT     | INTEGER*2  | INTEGER*2   |
 |      |         | JNOT     | INTEGER*4  | INTEGER*4   |
 |      |see note | KNOT     | INTEGER*8  | INTEGER*8   |
 +------+---------+----------+------------+-------------+

 NOTE: KNOT is only available on Alpha systems.
3 NWORKERS
 The intrinsic function NWORKERS requires no arguments and returns
 an INTEGER*4 value that represents the total number of processes
 executing an application.  However, since Digital Fortran 77 only
 does serial processing, NWORKERS always returns 1.
3 QEXT    
 QEXT (number)

 This function is only available on Alpha systems.

 A function that converts the argument to a REAL*16 value.
 +------+---------+----------+------------+-------------+      
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  1   |  QEXT   | QEXT     | INTEGER*1  | REAL*16     |
 |      |         | QEXT     | INTEGER*2  | REAL*16     |
 |      |         | QEXT     | INTEGER*4  | REAL*16     |
 |      |         | QEXT     | INTEGER*8  | REAL*16     |
 |      |         | QEXT     | REAL*4     | REAL*16     |
 |      |         | QEXTD    | REAL*8     | REAL*16     |
 |      |         | QEXT     | REAL*16    | REAL*16     |
 |      |         | QEXT     | COMPLEX*8  | REAL*16     |
 |      |         | QEXT     | COMPLEX*16 | REAL*16     |
 +------+---------+----------+------------+-------------+
3 QFLOAT  
 QFLOAT (integer)

 This function is only available on Alpha systems.

 A function that converts an integer value to a REAL*16 value.
 +------+---------+----------+------------+-------------+      
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  1   | QFLOAT  | QFLOAT   | INTEGER*1  | REAL*16     |
 |      |         | QFLOAT   | INTEGER*2  | REAL*16     |
 |      |         | QFLOAT   | INTEGER*4  | REAL*16     |
 |      |         | QFLOAT   | INTEGER*8  | REAL*16     |
 +------+---------+----------+------------+-------------+
3 RAN     
 RAN (seed)

 A function that is a general random number generator of the
 multiplicative congruential type.  This function returns a
 different REAL*4 number between 0.0 (inclusive) and 1.0 (exclusive)
 each time it is invoked.  The argument must be an INTEGER*4
 variable or array element.

 For best results, you should initialize the argument to a large,
 odd value before invoking RAN the first time.  To generate
 different sets of random values, initialize the seed to a different
 value on each run.  Do not modify the seed during a run.
3 REAL    
 REAL (number)

 A function that converts the argument to a real value.
 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  1   |  REAL   |  --      | INTEGER*1  | REAL*4      |
 |      |         | FLOATI   | INTEGER*2  | REAL*4      |
 |      |         | FLOATJ   | INTEGER*4  | REAL*4      |
 |      |see note | FLOATK   | INTEGER*8  | REAL*4      |
 |      |         |  --      | REAL*4     | REAL*4      |
 |      |         | SNGL     | REAL*8     | REAL*4      |
 |      |see note | SNGLQ    | REAL*16    | REAL*4      |
 |      |         |  --      | COMPLEX*8  | REAL*4      |
 |      |         |  --      | COMPLEX*16 | REAL*4      |
 +------+---------+----------+------------+-------------+

 NOTE: FLOATK and SNGLQ are only available on Alpha systems.

 REAL is also a specific name for a function that returns the real
 part of a complex number.  The argument must be a COMPLEX*8 data
 type.  The result is a REAL*4 data type.

 The setting of -r8 affects REAL.
3 SECNDS  
 SECNDS (real-number)

 A function that returns the number of seconds since midnight minus
 the value of the argument.  The argument must be a REAL*4 data
 type.  The return value is a REAL*4 data type.  The time returned
 is accurate to .01 seconds.
3 SIGN    
 SIGN (value, sign)

 A function that assigns the sign of the second argument to the
 absolute value of the first.
 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  2   |  SIGN   |  --      | INTEGER*1  | INTEGER*1   |
 |      |         | IISIGN   | INTEGER*2  | INTEGER*2   |
 |      |         | JISIGN   | INTEGER*4  | INTEGER*4   |
 |      |see note | KISIGN   | INTEGER*8  | INTEGER*8   |
 |      |         | SIGN     | REAL*4     | REAL*4      |
 |      |         | DSIGN    | REAL*8     | REAL*8      |
 |      |see note | QSIGN    | REAL*16    | REAL*16     |
 +------+---------+----------+------------+-------------+

 NOTE: KISIGN and QSIGN are only available on Alpha systems.

 See also the ISIGN intrinsic function.
3 SIN     
 SIN (number)

 A function that returns the sine of the argument.  The argument
 must be in radians; it is treated modulo 2*pi.
 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  1   |  SIN    | SIN      | REAL*4     | REAL*4      |
 |      |         | DSIN     | REAL*8     | REAL*8      |
 |      |see note | QSIN     | REAL*16    | REAL*16     |
 |      |         | CSIN     | COMPLEX*8  | COMPLEX*8   |
 |      |         | CDSIN    | COMPLEX*16 | COMPLEX*16  |
 |      |         | ZSIN     | COMPLEX*16 | COMPLEX*16  |
 +------+---------+----------+------------+-------------+

 NOTE: QSIN is only available on Alpha systems.
3 SIND    
 SIND (number)

 A function that returns the sine of the argument.  The argument
 must be in degrees; it is treated modulo 360.
 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  1   |  SIND   | SIND     | REAL*4     | REAL*4      |
 |      |         | DSIND    | REAL*8     | REAL*8      |
 |      |see note | QSIND    | REAL*16    | REAL*16     |
 +------+---------+----------+------------+-------------+

 NOTE: QSIND is only available on Alpha systems.
3 SINH    
 SINH (number)

 A function that returns the hyperbolic sine of the argument.
 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  1   |  SINH   | SINH     | REAL*4     | REAL*4      |
 |      |         | DSINH    | REAL*8     | REAL*8      |
 |      |see note | QSINH    | REAL*16    | REAL*16     |
 +------+---------+----------+------------+-------------+

 NOTE: QSINH is only available on Alpha systems.
3 SIZEOF  
 SIZEOF (arg)

 A function that returns the number of bytes of storage used by the
 argument.
 +------+---------+----------+------------------+-------------+   
 | Args | Generic | Specific |    Argument      | Result Type |
 +------+---------+----------+------------------+-------------+
 |   1  |   --    | SIZEOF   | Anything with a  | INTEGER*4   |
 |      |         |   --     | valid data type, | INTEGER*8   |
 |      |         |          | except assumed-  |             |
 |      |         |          | size arrays or   |             |
 |      |         |          | passed-length    |             |
 |      |         |          | characters.      |             |
 +------+---------+----------+------------------+-------------+

 NOTE: A result type of INTEGER*8 is only available on Alpha 
       systems.
3 SNGL    
 SNGL (number)

 A function that converts the argument to a real value.
 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  1   |  REAL   |  --      | INTEGER*1  | REAL*4      |
 |      |         | FLOATI   | INTEGER*2  | REAL*4      |
 |      |         | FLOATJ   | INTEGER*4  | REAL*4      |
 |      |see note | FLOATK   | INTEGER*8  | REAL*4      |
 |      |         | REAL     | REAL*4     | REAL*4      |
 |      |         |  --      | REAL*8     | REAL*4      |
 |      |see note | SNGLQ    | REAL*16    | REAL*4      |
 +------+---------+----------+------------+-------------+

 NOTE: FLOATK and SNGLQ are only available on Alpha systems.

 The setting of -r8 affects SNGL.
3 SQRT    
 SQRT (number)

 A function that returns the square root of the argument.
 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  1   |  SQRT   | SQRT     | REAL*4     | REAL*4      |
 |      |         | DSQRT    | REAL*8     | REAL*8      |
 |      |see note | QSQRT    | REAL*16    | REAL*16     |
 |      |         | CSQRT    | COMPLEX*8  | COMPLEX*8   |
 |      |         | CDSQRT   | COMPLEX*16 | COMPLEX*8   |
 |      |         | ZSQRT    | COMPLEX*16 | COMPLEX*8   |
 +------+---------+----------+------------+-------------+

 NOTE: QSQRT is only available on Alpha systems.

 The argument for SQRT, DSQRT, and QSQRT must be greater than or
 equal to zero.  The result of CSQRT, CDSQRT, and ZSQRT is the
 principal value, with the real part greater than or equal to zero.
 If the real part is zero, the result is the principal value, with
 the imaginary part greater than or equal to zero.
3 TAN     
 TAN (real-number)

 A function that returns the tangent of the argument.  The argument
 must be in radians; it is treated modulo 2*pi.
 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  1   |  TAN    | TAN      | REAL*4     | REAL*4      |
 |      |         | DTAN     | REAL*8     | REAL*8      |
 |      |see note | QTAN     | REAL*16    | REAL*16     |
 +------+---------+----------+------------+-------------+

 NOTE: QTAN is only available on Alpha systems.
3 TAND    
 TAND (real-number)

 A function that returns the tangent of the argument.  The argument
 must be in degrees; it is treated modulo 360.
 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  1   |  TAND   | TAND     | REAL*4     | REAL*4      |
 |      |         | DTAND    | REAL*8     | REAL*8      |
 |      |see note | QTAND    | REAL*16    | REAL*16     |
 +------+---------+----------+------------+-------------+

 NOTE: QTAND is only available on Alpha systems.
3 TANH    
 TANH (real-number)

 A function that returns the hyperbolic tangent of the argument.

 +------+---------+----------+------------+-------------+        
 | Args | Generic | Specific |  Argument  | Result Type |
 +------+---------+----------+------------+-------------+
 |  1   |  TANH   | TANH     | REAL*4     | REAL*4      |
 |      |         | DTANH    | REAL*8     | REAL*8      |
 |      |see note | QTANH    | REAL*16    | REAL*16     |
 +------+---------+----------+------------+-------------+

 NOTE: QTANH is only available on Alpha systems.
3 TIME    
 CALL TIME (buf)

 buf  Is an 8-byte variable, array, array element, 
      or character substring.

 A subroutine that places the current time in 24-hour ASCII format
 in the argument.  The time is returned as an 8-byte ASCII character
 string having the following form:

    hh:mm:ss

 A 24-hour clock is used.

 If "buf" is numeric type and smaller than 8 bytes, data corruption
 can occur.

 If "buf" is character type, its associated length is passed to the
 subroutine.  If "buf" is smaller than 8 bytes, the subroutine
 truncates the date to fit in the specified length.  Note that if a
 CHARACTER array is passed, the subroutine stores the time in the
 first array element, using the element length, not the length of
 the entire array.  For example, consider the following:

 CHARACTER*1 HOUR(8)
    .
    .
    .
 CALL TIME(HOUR)

 The length of the first array element in CHARACTER array HOUR is
 passed to the TIME subroutine.  The subroutine then truncates the
 time to fit into the one-character element, producing an incorrect
 result.
3 ZEXT    
 ZEXT (integer)

 A function that returns the value of the argument, zero extended.
 +------+----------+----------+------------+-------------+        
 | Args | Generic  | Specific |  Argument  | Result Type |
 +------+----------+----------+------------+-------------+
 |  1   |  ZEXT    | IZEXT    | LOGICAL*1  | INTEGER*2   |
 |      |          |  --      | LOGICAL*2  | INTEGER*2   |
 |      |          |  --      | INTEGER*1  | INTEGER*2   |
 |      |          |  --      | INTEGER*2  | INTEGER*2   |
 |      |          | JZEXT    | LOGICAL*1  | INTEGER*4   |
 |      |          |  --      | LOGICAL*2  | INTEGER*4   |
 |      |          |  --      | LOGICAL*4  | INTEGER*4   |
 |      |          |  --      | INTEGER*1  | INTEGER*4   |
 |      |          |  --      | INTEGER*2  | INTEGER*4   |
 |      |          |  --      | INTEGER*4  | INTEGER*4   |
 |      |see note1 | KZEXT    | LOGICAL*1  | INTEGER*8   |
 |      |see note2 |  --      | LOGICAL*2  | INTEGER*8   |
 |      |see note2 |  --      | LOGICAL*4  | INTEGER*8   |
 |      |see note2 |  --      | LOGICAL*8  | INTEGER*8   |
 |      |see note2 |  --      | INTEGER*1  | INTEGER*8   |
 |      |see note2 |  --      | INTEGER*2  | INTEGER*8   |
 |      |see note2 |  --      | INTEGER*4  | INTEGER*8   |
 |      |see note2 |  --      | INTEGER*8  | INTEGER*8   |
 +------+----------+----------+------------+-------------+

 NOTE1: KZEXT is only available on Alpha systems. 
 NOTE2: INTEGER*8 is only available on Alpha systems.

 The setting of -noi4 or -i8 (Alpha only) affects ZEXT.
2 Source_Format     
 Each Fortran line has the following four fields:

   Statement label field           Columns 1-5
   Continuation indicator field    Column 6
   Statement field                 Columns 7-72 (if you specify 
                                     the EXTEND_SOURCE compiler
                                     option or OPTIONS/EXTEND_SOURCE, 
                                     statements extend to column 132)
   Sequence number field           Columns 73-80

 There are two ways to code a Fortran line:  standard formatting and
 tab formatting.  You may prefer to use the standard formatting when
 program portability to other systems is necessary.  The tab
 formatting method is convenient when you are entering lines at a
 terminal with a text editor.
3 Standard
 A Fortran line is divided into fields for the required information.
 Each column represents a single character.

  COLUMN    FIELD
  ------    -----
      1     Indicator: Comment(C,c,*,!,blank) or Debug(D,d)
    1-5     Label (any decimal integer except zero)
      6     Indicator: Continuation of statement (any character
                  except zero or space)
   7-72     Statement Field (up to column 72)
  73-80     Sequence Number (optionally to column 132 -- ignored)
3 Tab     
 A Fortran line is divided into fields for the required information.
 Each column represents a single character.  You cannot specify a
 sequence number field using this method of coding.

  COLUMN   FIELD
  ------   -----
  (before tab)
    1      Indicator: Comment(C,c,*,!,blank) or Debug(D,d)
  1-5      Label (any decimal integer except zero)
  (after first tab)
    6      Indicator: Continuation of statement (any digit 1-9)
  (after second tab)
           Statement Field (up to column 72)

 Tabs are treated as single characters.
2 Statements        
 Statements in a Fortran program unit follow a required order.  In
 the following figure, vertical lines separate statement types that
 can be interspersed.  For example, DATA statements can be
 interspersed with executable statements.  Horizontal lines indicate
 statement types that cannot be interspersed.  For example, type
 declaration statements cannot be interspersed with executable
 statements.










 +-------+--------------------------------------------------------+
 |       |              OPTIONS Statement                         |
 |       |--------------------------------------------------------|
 |       |PROGRAM, FUNCTION, SUBROUTINE, or BLOCK DATA Statements |
 |       |--------+-----------------------------------------------|
 |COMMENT|         |  IMPLICIT NONE Statement                     |
 | Lines,|         |-------------------------------+--------------|
 |INCLUDE|NAMELIST,|  IMPLICIT Statements          |              |
 | State-| FORMAT, |------+------------------------|  PARAMETER   |
 | ments,|   &     |      |  Other Specification   |  Statements  |
 |& Gen- | ENTRY   | DATA |      Statements,       |              |
 |  eral | State-  |State-|  DICTIONARY Statements |              |
 |Direc- |  ments  | ments|------------------------+--------------|
 | tives |         |      |   Statement Function Definitions      |
 |       |         |      |---------------------------------------|
 |       |         |      |       Executable Statements           |
 |-------+---------+------+---------------------------------------|
 |                     END Statement                              |
 +----------------------------------------------------------------+
3 Directive_Statements    
 cDEC$ ALIAS name, external name
 cDEC$ IDENT string
 cDEC$ OPTIONS /[NO]ALIGN[=p]
 cDEC$ PSECT /common-name/ attr [,attr,...]
 cDEC$ SUBTITLE string
 cDEC$ TITLE string

 c  Is either: 

    The letter C (or c), an asterisk (*), or an 
    exclamation point (!) in column 1.

    An exclamation point preceded by whitespace only.

 You can use directives in a Fortran source program to influence
 certain aspects of the compilation process.

 Directives are prefixed, starting in column 1, with a 5-character
 identifier and a space (or tab).  Directives prefixed with cDEC$
 are enabled in all Fortran compilation units, regardless of the
 options used on the command line.

 A directive statement cannot be continued across multiple lines in
 a source program, and any blanks appearing after column 6 are
 insignificant.

 Continuation lines cannot appear in directive statements.

 If a blank common block is used in a compiler directive, it must be
 specified as two slashes (/ /).
4 ALIAS             
 cDEC$ ALIAS name, external name

 Specifies an alternate external name to be used when referring to
 external objects such as subroutines and functions.

 This can be useful when compiling applications written for other
 platforms that have different naming conventions.

 The "name" is the name of the external object.

 The "external name" is an identifier or a character constant
 delimited by quotation marks.  If a character constant is
 specified, it is used as is; the string is not changed to uppercase
 nor are blanks removed.

 The ALIAS directive affects only the external name used for
 references to the specified internal name.

 Names that are not acceptable to the linker will cause link-time
 errors.
4 IDENT             
 cDEC$ IDENT string

 The IDENT directive lets you specify a string that can be used to
 identify an object module.  The compiler places the string in the
 identification field of an object module when it generates the
 module for each source program unit.  The string that you specify
 can consist of a group of up to 31 printable characters delimited
 by apostrophes.

 Only the first IDENT directive is effective -- the compiler ignores
 any additional IDENT directives in a program unit.
4 OPTIONS           
 cDEC$ OPTIONS

 The OPTIONS directive controls whether the Digital Fortran 77
 compiler naturally aligns fields in records and data items in
 common blocks for performance reasons, or whether the compiler
 packs those fields and data items together on arbitrary byte
 boundaries.  The OPTIONS directive takes the following form:

 cDEC$ OPTIONS /[NO]ALIGN[=p]
        .
        .
        .
 cDEC$ END OPTIONS

 p  Is a specifier with one of the following forms:

    [class =] rule    
    (class = rule,...) 
    ALL
    NONE

    class  Is one of the following keywords:

           COMMONS    (for common blocks)
           RECORDS    (for records)
           STRUCTURES (a synonym for RECORDS)

    rule   Is one of the following keywords:

           PACKED -   Packs fields in records or data 
                      items in common blocks on arbitrary 
                      byte boundaries.

           NATURAL -  Naturally aligns fields in records 
                      and data items in common blocks on 
                      up to 64-bit boundaries (inconsistent 
                      with the FORTRAN-77 standard).

                      If you specify NATURAL, the compiler will 
                      naturally align all data in a common 
                      block, including INTEGER*8, REAL*8, and 
                      all COMPLEX data.

           STANDARD - Naturally aligns data items in common 
                      blocks on up to 32-bit boundaries (con-
                      sistent with the FORTRAN-77 standard).

                      Note that this keyword only applies to 
                      common blocks; therefore, you can specify 
                      /ALIGN=COMMONS=STANDARD, but you cannot 
                      specify /ALIGN=STANDARD.

    ALL    Is the same as /ALIGN, /ALIGN=NATURAL, and 
           /ALIGN=(RECORDS=NATURAL,COMMONS=NATURAL).

    NONE   Is the same as /NOALIGN, /ALIGN=PACKED, and
           /ALIGN=(RECORDS=PACKED,COMMONS=PACKED)

 cDEC$ OPTIONS (and accompanying cDEC$ END OPTIONS) directives must
 come after OPTIONS, SUBROUTINE, FUNCTION, and BLOCK DATA statements
 (if any) in the program unit, and before statement functions or the
 executable part of the program unit.

 For performance reasons, Digital Fortran 77 always aligns local
 data items on natural boundaries.  However, EQUIVALENCE, COMMON,
 RECORD, and STRUCTURE data declaration statements can force
 misaligned data.  You can use the OPTIONS directive to control the
 alignment of fields associated with COMMON and RECORD statements.
 By default, you receive compiler messages when misaligned data is
 encountered.

 To request packed, unaligned data in a record structure, specify
 /ALIGN=RECORDS=PACKED, or consider placing source data declarations
 for the record so that the data is naturally aligned.

                                NOTE

         Misaligned data significantly increases the time it
         takes  to  execute  a  program.   As  the number of
         misaligned fields encountered  increases,  so  does
         the  time  needed  to  complete  program execution.
         Specifying  cDEC$  OPTIONS/ALIGN  (or  the   /ALIGN
         compiler option) minimizes misaligned data.


 To request aligned, data in common blocks, specify
 /ALIGN=COMMONS=STANDARD (for data items up to 32 bits in length) or
 /ALIGN=COMMONS=NATURAL (for data items up to 64 bits in length), or
 place source data declarations within the common block in
 descending size order, so that each data field is naturally
 aligned.

 The OPTIONS directive supersedes the -align "keyword" compiler
 option.

 OPTIONS directives must be balanced and can be nested up to 100
 levels, for example:

    CDEC$ OPTIONS /ALIGN=PACKED         ! Group A
       declarations
    CDEC$ OPTIONS /ALIGN=RECO=NATU         ! Group B
       more declarations
    CDEC$ END OPTIONS                      ! End of Group B
       still more declarations
    CDEC$ END OPTIONS                   ! End of Group A

 Note that common blocks within Group B will be PACKED.  The CDEC$
 OPTION specification for Group B only applies to RECORDS, so
 COMMONS retains the previous setting (in this case, from the Group
 A specification).

 For more information on alignment and data sizes, see your user
 manual.
4 PSECT             
 cDEC$ PSECT /common-name/ attr [,attr,...]

 The PSECT directive lets you modify several attributes of a common
 block.

 Specify the name of a common block, preceded and followed by a
 slash, and one of the following attributes:

  o  ALIGN=val or ALIGN=keyword

     Specifies alignment for the common block.

     "val" must be a constant ranging from 0 through 16.

     The specified number is interpreted as a power of 2.  The value
     of the expression is the alignment in bytes.  On Digital UNIX
     systems, "val" is limited to a maximum of 4; values above 4
     produce an error message.

     "keyword" is one of the following:

           Keyword        Equivalent to "val"
           BYTE               0
           WORD               1
           LONG               2
           QUAD               3
           OCTA               4
           PAGE              16

     The default is octaword alignment (4).  On Digital UNIX
     systems, PAGE produces an error message.

  o  GBL (VMS only)

     Specifies global scope.  This is the default scope.

  o  LCL (VMS only)

     Specifies local scope.  This keyword is opposite to GBL and
     cannot appear with it.

  o  [NO]MULTILANGUAGE (VMS only)

     Controls whether the compiler pads the size of overlaid psects
     (program sections) to ensure compatibility when the psect is
     shared by code created by other Digital compilers.

     When a psect generated by a Fortran common block is overlaid
     with a psect consisting of a C structure, linker error messages
     can occur.  This is because the sizes of the psects are
     inconsistent; the C structure is padded, but the Fortran common
     block is not.

     Specifying MULTILANGUAGE ensures that Digital Fortran 77
     follows a consistent psect size allocation scheme that works
     with DEC C psects shared across multiple images.  Psects shared
     in a single image do not have a problem.

     The default is NOMULTILANGUAGE, which is sufficient for most
     applications.

     To specify MULTILANGUAGE for all COMMON blocks in a module, use
     compiler option /ALIGN=COMMON=MULTILANGUAGE.  (For more
     information, see your user manual.)

  o  [NO]SHR (VMS only)

     Determines whether the contents of a common block can be shared
     by more than one process.  The default is NOSHR.

  o  [NO]WRT (VMS only)

     Determines whether the contents of a common block can be
     modified during program execution.  The default is WRT.


 Global or local scope is significant for an image that has more
 than one cluster.  Program sections with the same name that are
 from different modules in different clusters are placed in separate
 clusters if local scope is in effect.  They are placed in the same
 cluster if global scope is in effect.

 If one program unit changes one or more characteristics of a common
 block, all other units that reference that common block must also
 change those characteristics in the same way.

 Default characteristics apply if you do not modify them with a
 PSECT directive.

 See ld(1) for detailed information about default attributes of
 common blocks.
4 TITLE_and_SUBTITLE
 cDEC$ TITLE string
 cDEC$ SUBTITLE string

 The TITLE directive lets you specify a string and place it in the
 title field of a listing header.  Similarly, SUBTITLE lets you
 place a specified string in the subtitle field of a listing header.

 The string that you specify can consist of up to 31 printable
 characters and must be delimited by apostrophes.

 In addition to the compiler-directive syntax rules, the TITLE and
 SUBTITLE directives have the following specific rules:

  -  To enable TITLE and SUBTITLE directives, you must specify the
     -V compiler option.

  -  When TITLE or SUBTITLE appears on a page of a listing file, the
     specified string appears in the listing header of the following
     page.

  -  If two or more of either directive appear on a page, the last
     directive is the one in effect for the following page.

  -  If either directive does not specify a string, no change occurs
     in the listing file header.

3 Executable_Statements   
 The executable statements are:

 ACCEPT, ASSIGN, assignment statements, BACKSPACE, CALL, CLOSE,
 CONTINUE, CYCLE, DELETE, DO, END DO, ELSE, EXIT, END, ENDFILE, END
 SELECT, FIND, GO TO, IF, END IF, INQUIRE, OPEN, PAUSE, PRINT, READ,
 RETURN, REWIND, REWRITE, SELECT CASE, STOP, TYPE, UNLOCK, and
 WRITE.

 CASE and DO constructs can be named.  The name must appear in the
 initial line and terminal line of the construct.  In the initial
 line, the name is separated from the statement keyword by a colon
 (:).  For example:

   [name:] SELECT CASE
   ...
   END SELECT [name]

 The construct name must be a unique identifier in the program unit.
3 Specification_Statements
 The specification statements are:

 AUTOMATIC, BLOCK DATA, COMMON, DATA, DIMENSION, EQUIVALENCE,
 EXTERNAL, IMPLICIT, INTRINSIC, NAMELIST, PARAMETER, POINTER,
 PROGRAM, RECORD, SAVE, STATIC, structure declarations, type
 declarations, and VOLATILE.
3 ACCEPT                  
 Transfers input data to internal storage from external records
 accessed under the sequential mode of access.  It takes one of the
 following forms:

     Formatted           ACCEPT f[,iolist]
     List-directed       ACCEPT *[,iolist]
     Namelist            ACCEPT n

     f       Is a format specifier not prefaced by FMT=.

     iolist  Is a simple I/O list element or an implied-DO list.

     *       Specifies list-directed formatting (can be specified
             as FMT=*).

     n       The nonkeyword form of a namelist specifier.

 The control-list parameters are "f," "*" (or FMT=*), and "n".  The
 I/O list parameter is "iolist".

 The formatted ACCEPT statement transfers data from your terminal to
 internal storage.  The access mode is sequential.

 The list-directed ACCEPT statement translates the data from
 character to binary format according to the data types of the
 variables in the I/O list.

 The namelist ACCEPT statement translates the data from character to
 binary format according to the data types of the list entities in
 the corresponding NAMELIST statement.

 Also see the READ Statement.
3 ASSERT                  
 This statement is not available in Digital Fortran 77.
3 ASSIGN                  
 Assigns the value of a statement label to an integer variable.
 Statement format:

    ASSIGN s TO v

    s  Is the label of an executable statement or a 
       FORMAT statement.  You must specify the label 
       as an unsigned integer (from 1-5 characters
       long, using digits 0-9).

    v  Is an integer variable.

 When the value of a statement label is assigned to an integer
 variable:  the variable can then be used as a transfer destination
 in a subsequent assigned GOTO statement or as a format specifier in
 a formatted I/O statement.  The ASSIGN statement must be in the
 same program unit as and must be executed before the statement(s)
 in which the assigned variable is used.
3 Assignment              
 Assigns the value of the expression to the variable.
 Arithmetic/Logical/Character assignment takes the form:

    v = e

    v  Is a scalar memory reference.
  
    e  Is an arithmetic expression (arithmetic assignment), 
       a character scalar memory reference (character assignment), 
       or a logical scalar memory reference (logical assignment).

 The right side of the equation must evaluate to a data type
 compatible with the variable on the left side.  If aggregates are
 involved, the aggregate reference and the aggregate must have
 matching structures.
4 Conversion_Rules     
 The following tables summarize the conversion rules for assignment
 statements.  MS signifies the most significant (high-order) bit; LS
 signifies the least significant (low-order) bit.

 +---------+----------------------------------------------------+
 |Variable |          Expression (E)                            |
 |or Array |-----------------------------------------------------
 |Element  |integer or logical |      REAL     |    REAL*8      |
 +---------+----------------------------------------------------+
 | integer |  Assign E to V    | Truncate E to | Truncate E to  |
 |  or     |                   | integer and   | integer and    |
 | logical |                   | assign to V   | assign to V    |
 +--------------------------------------------------------------+
 |  REAL   | Append fraction   | Assign E to V | Assign MS por- |
 |         | (.0) to E and     |               | tion of E to V;|
 |         | assign to V       |               | LS portion of E|
 |         |                   |               | is rounded     |
 +--------------------------------------------------------------+
 |  REAL*8 | Append fraction   | Assign E to MS| Assign E to V  |
 |         | (.0) to E and     | portion of V; |                |
 |         | assign to V       | LS portion of |                |
 |         |                   | V is 0        |                |
 +--------------------------------------------------------------+
 | REAL*16 | same as above     | same as above | Assign E to MS |
 |         |                   |               | portion of V;  |
 |         |                   |               | LS portion of V|
 |         |                   |               | is 0           |
 +--------------------------------------------------------------+
 | COMPLEX | Append fraction   | Assign E to   | Assign MS por- |
 |         | (.0) to E and     | real part of  | tion of E to   |
 |         | assign to real    | V; imaginary  | real part of V;|
 |         | part of V; imagin-| part of V is  | LS portion of  |
 |         | ary part of V is  | 0.0           | E is rounded;  |
 |         | 0.0               |               | imaginary part |
 |         |                   |               | of V is 0.0    |
 +--------------------------------------------------------------+
 |COMPLEX*16| Append fraction  | Assign E to MS | Assign E to   |
 |          | (.0) to E and    | portion of     | real part of  |
 |          | assign to V;     | real part of V;| V; imaginary  |
 |          | imaginary part of| imaginary part | part is 0.0   |
 |          | V is 0.0         | of V is 0.0    |               |
 +--------------------------------------------------------------+

 continued chart
 +---------+----------------------------------------------------+
 |Variable |          Expression (E)                            |
 |or Array |-----------------------------------------------------
 |Element  |   REAL*16   |    COMPLEX    |    COMPLEX*16        |
 |         |             |               |                      |
 +---------+----------------------------------------------------+
 |integer  | Truncate E  | Truncate real | Truncate real part of|
 | or      | to integer  | part of E to  | E to integer and     |
 |logical  | and assign  | integer and   | assign to V; imagin- |
 |         | to V        | assign to V;  | ary part of E is not |
 |         |             | imaginary part| used                 |
 |         |             | is not used   |                      |
 +--------------------------------------------------------------+
 |  REAL   | Assign MS   | Assign real   | Assign MS portion of |
 |         | portion of E| part of E to  | the real part of E to|
 |         | to V; LS    | V; imaginary  | V; LS portion of the |
 |         | portion of E| part of E is  | real part of E is    |
 |         | is rounded  | not used      | rounded; imaginary   |
 |         |             |               | part of E is not used|
 +--------------------------------------------------------------+
 | REAL*8  | same as     | Assign real   | Assign real part of E|
 |         | above       | part of E to  | to V; imaginary part |
 |         |             | MS of V; LS   | of E is not used     |
 |         |             | portion of V  |                      |
 |         |             | is 0; imagin- |                      |
 |         |             | ary part of E |                      |
 |         |             | is not used   |                      |
 +--------------------------------------------------------------+
 | REAL*16 | Assign E to | same as above | Assign real part of E|
 |         | V           |               | to MS portion of V;  |
 |         |             |               | LS portion of real   |
 |         |             |               | part of V is 0; imag-|
 |         |             |               | inary part of E is   |
 |         |             |               | not used             |
 +--------------------------------------------------------------+
 | COMPLEX | Assign MS   | Assign E to V | Assign MS portion of |
 |         | portion of E|               | real part of E to    |
 |         | to real part|               | real part of V; LS   |
 |         | of V; LS    |               | portion of real part |
 |         | portion of E|               | of E is rounded.     |
 |         | is rounded; |               | Assign MS portion of |
 |         | imaginary   |               | imaginary part of E  |
 |         | part of V is|               | to imaginary part of |
 |         | 0.0         |               | V; LS portion of     |
 |         |             |               | imaginary part of E  |
 |         |             |               | is rounded           |
 +--------------------------------------------------------------+
 |COMPLEX*16| same as    | Assign real    | Assign E to V       |
 |          | above      | part of E to   |                     |
 |          |            | MS portion of  |                     |
 |          |            | real part of V;|                     |
 |          |            | LS portion of  |                     |
 |          |            | real part is 0.|                     |
 |          |            | Assign imagin- |                     |
 |          |            | ary part of E  |                     |
 |          |            | to MS portion  |                     |
 |          |            | of imaginary   |                     |
 |          |            | part of V;     |                     |
 |          |            | LS portion of  |                     |
 |          |            | imaginary part |                     |
 |          |            | is 0           |                     |
 +--------------------------------------------------------------+
3 AUTOMATIC_and_STATIC  
 The AUTOMATIC and STATIC statements are used within a called
 subprogram to control the allocation of storage to variables and
 the initial value of variables.  Statement format:

    AUTOMATIC  v [,v]...
    STATIC  v [,v]...

    v  Is the name of a variable, array, or array declarator.

 AUTOMATIC and STATIC declarations only affect how data is allocated
 in storage, as follows:

  o  A variable declared as AUTOMATIC and allocated in memory
     resides the stack storage area.

  o  A variable declared as STATIC and allocated in memory resides
     in the static storage area.


 By default, the compiler allocates local variables of non-recursive
 subprograms in the static storage area.  The compiler may choose to
 allocate a variable in temporary (stack or register) storage if it
 notices that the variable is always defined before use.
 Appropriate use of the SAVE statement can prevent compiler warnings
 if a variable is used before it is defined.

 To change the default from STATIC to AUTOMATIC, specify the -assume
 recursive compiler option.

 To override the compiler option in effect for specific variables,
 specify the variables in AUTOMATIC or STATIC type statements.

                                NOTE

         Variables in COMMON, DATA,  EQUIVALENCE,  and  SAVE
         statements, or in BLOCK DATA subprograms are always
         STATIC,  regardless  of   the   -assume   recursive
         compiler   option   or   any   previous   AUTOMATIC
         specification.


 AUTOMATIC variables can reduce memory use because only the
 variables currently being used are allocated to memory.

 AUTOMATIC variables permit recursion.  With recursion, a subprogram
 can call itself (directly or indirectly), and resulting values are
 available upon a subsequent call or return to the subprogram.
3 BACKSPACE               
 Repositions a sequential file that is currently open for sequential
 access to the beginning of the preceding record.  The file must be
 on disk or tape.  Statement format:

     BACKSPACE ([UNIT=]u[,ERR=s][,IOSTAT=ios])
     BACKSPACE u

     u     Is an integer variable or constant specifying the 
           logical unit number of the file, optionally prefaced 
           by UNIT=.  UNIT= is required if unit is not the 
           first I/O specifier.
     s     Is the label of a statement that receives control 
           if an error occurs, prefaced by ERR=.
     ios   Is an integer variable to which the completion status 
           of the I/O operation is returned, prefaced by IOSTAT=
           (positive if an error occurs, zero if no error occurs).

 A BACKSPACE statement should not be specified for a file that is
 open for direct or append access.  Backspacing from record "n" can
 be done by rewinding to the start of the file and then performing
 n-1 successive reads to reach the previous record.  For direct and
 append access, the current record count ("n") is not available to
 the Fortran I/O system.
3 BLOCK_DATA               
 Begins a block data program unit.  Statement format:

    BLOCK DATA [nam]

    nam   Is the symbolic name used to identify the block.  

 A BLOCK DATA statement and its associated specification statements
 are a special kind of program unit, called a block data subprogram.
 The block data subprogram has the following syntax rules:

    - Any of the following specification statements can appear 
      in a block data subprogram:
      
      COMMON             RECORD
      DATA               SAVE
      DIMENSION          STATIC
      EQUIVALENCE        Structure declaration
      IMPLICIT           Type declaration statements
      PARAMETER

    - A block data subprogram must not contain any 
      executable statements.

    - As with other types of program units, the last 
      statement in a block data subprogram must be an 
      END statement.

    - Within a block data subprogram, if a DATA statement 
      initializes any entity in a named common block, 
      the subprogram must have a complete set of speci-
      fication statements that establishes the common block.  
      However, all of the entities in the block do not have 
      to be assigned initial values in a DATA statement.

    - One block data subprogram can establish and define 
      initial values for more than one common block.

    - The name of a block data subprogram can appear in the 
      EXTERNAL statement of a different program unit to force 
      a search of object libraries for the BLOCK DATA program 
      unit at link time.
3 CALL                    
 Transfers control and passes arguments to a subprogram.  Statement
 format:

    CALL sub[([a][,[a]]...)]

    sub  Is the name of a subroutine, or other external 
         procedure, or a dummy argument associated with 
         a subroutine subprogram or other external procedure.

    a    Is a value to be passed to the subroutine.  

 If you specify an argument list, the CALL statement associates the
 values in the list with the dummy arguments in the subroutine.  It
 then transfers control to the first executable statement following
 the SUBROUTINE or ENTRY statement referenced by the CALL statement.

 The arguments in the CALL statement must agree in number, order,
 and data type with the dummy arguments in the subroutine.  They can
 be variables, arrays, array elements, records, record elements,
 record arrays, record array elements, substring references,
 constants, expressions, Hollerith constants, alternate return
 specifiers, or subprogram names.  An unsubscripted array name or
 record array name in the argument list refers to the entire array.

 An alternate return specifier is an asterisk (or ampersand)
 followed by the label of a statement in the program unit containing
 the CALL statement.

 Digital Fortran 77 allows direct or indirect recursive calls to
 subroutines, if you specify the -assume recursive compiler option.
3 CASE                    
 The CASE construct conditionally executes one block of constructs
 or statements depending on the value of a scalar expression in a
 SELECT CASE statement.  Statement format:

   [name :] SELECT CASE (expr)
   [CASE (case-value [,case-value]...) [name]
     block]...
   [CASE DEFAULT [name]
     block]
   END SELECT [name]

   name   Is the name of the CASE construct.

   expr   Is an expression of type integer, logical, or 
          character (enclosed in parentheses). Evaluation
          of this expression results in a value called 
          the case index.

   case-value  Is one or more compile-time constant expressions 
               of type integer, logical, or character (enclosed 
               in parentheses).  Each "case-value" must be of the 
               same data type as "expr". If the type is character, 
               "case-value" and "expr" can be of different lengths.

               Integer and character expressions can be expressed 
               as a range of case values, taking one of the following 
               forms:

               low:high
               low:
               :high

               Case values must not overlap.

   block  Is a sequence of zero or more statements or 
          constructs.

 If a construct name is specified in a SELECT CASE statement, the
 same name must appear in the corresponding END SELECT statement.
 The same construct name can optionally appear in any CASE statement
 in the construct.  The same construct name must not be used for
 different named constructs in the same program unit; it must be
 unique.

 The case expression ("expr") is evaluated first.  The resulting
 case index is compared to the case values to find a matching value
 (there can only be one).  When a match occurs, the block following
 the matching case value is executed and the construct terminates.

 The following rules determine whether a match occurs:

  o  When the case value is a single value (no colon appears), a
     match occurs as follows:

       Data Type              A Match Occurs If:
       ---------              ---------------------------
       Logical                case-index .EQV. case-value
       Integer or character   case-index ==  case-value

  o  When the case value is a range of values (a colon appears), a
     match depends on the range specified, as follows:

       Range       A Match Occurs If:
       -----       -------------------------
       low:        case-index >= low
       :high       case-index <= high
       low:high    low <= case-index <= high


 The following are all valid case values:

    CASE (1, 4, 7, 11:14, 22)      ! Individual values as specified:
                                   !     1, 4, 7, 11, 12, 13, 14, 22
    CASE (:-1)                     ! All values less than zero
    CASE (0)                       ! Only zero
    CASE (1:)                      ! All values above zero

 If no match occurs but a CASE DEFAULT statement is present, the
 block following that statement is executed and the construct
 terminates.

 If no match occurs and no CASE DEFAULT statement is present, no
 block is executed, the construct terminates, and control passes to
 the next executable statement or construct following the END SELECT
 statement.

 The following are examples of CASE constructs:

   INTEGER FUNCTION STATUS_CODE (I)
     INTEGER I
     CHECK_STATUS: SELECT CASE (I)
     CASE (:-1)
       STATUS_CODE = -1
     CASE (0)
       STATUS_CODE =  0
     CASE (1:)
       STATUS_CODE =  1
     END SELECT CHECK_STATUS
   END 

   SELECT CASE (J)
   CASE (1, 3:7, 9)    ! Values: 1, 3, 4, 5, 6, 7, 9
     CALL SUB_A
   CASE DEFAULT
     CALL SUB_B
   END SELECT

 The following three examples are equivalent:

   1. SELECT CASE (ITEST .EQ. 1)
      CASE (.TRUE.)
        CALL SUB1 ()
      CASE (.FALSE.)
        CALL SUB2 ()
      END SELECT

   2. SELECT CASE (ITEST)
      CASE DEFAULT
        CALL SUB2 ()
      CASE (1)
        CALL SUB1 ()
      END SELECT

   3. IF (ITEST .EQ. 1) THEN
        CALL SUB1 ()
      ELSE
        CALL SUB2 ()
      END IF
3 CLOSE                   
 Closes a file.  Statement format:

    CLOSE ([UNIT=]u[,p][,ERR=s][,IOSTAT=ios])

    u    Is an integer variable or constant specifying the 
         logical unit number of the file, optionally prefaced 
         by UNIT=.  UNIT= is required if unit is not the 
         first I/O specifier.

    p    Is the disposition of the file after closing, prefaced 
         by STATUS=, DISPOSE= or DISP=.  Dispositions are as follows:

         'KEEP'             Retains the file.
                              *DEFAULT FOR ALL BUT SCRATCH FILES*
         'SAVE'             Retains the file.
         'DELETE'           Deletes the file.
                              *DEFAULT FOR SCRATCH FILES*
         'PRINT'            Submits the file as a print job.
         'PRINT/DELETE'     Submits then deletes the file as a 
                            print job.
         'SUBMIT'           Submits the file as a batch job.
         'SUBMIT/DELETE'    Submits then deletes the file as a 
                            batch job.

     s    Is the label of an executable statement.

     ios  Is an integer scalar memory reference.  (Returns a 
          zero if no error condition exists or a positive
          integer if an error condition exists.)

 The disposition specified in a CLOSE statement supersedes the
 disposition specified in the OPEN statement, except that a file
 opened as a scratch file cannot be saved, printed, or submitted,
 nor can a file opened for read-only access be deleted.

 If a CLOSE statement is specified for a unit that is not open, it
 has no effect.
3 COMMON                  
 Defines one or more contiguous blocks of storage shared among
 separate subprograms.  You can define the same common block in
 different program units of your program.  The first COMMON
 statement in a program unit to name a common block defines it;
 subsequent COMMON statements that name the block reference it.  You
 can leave one common block (the "blank" common block) unnamed.
 Statement format:

    COMMON [/[cb]/] nlist[[,] /[cb] /nlist]...

    cb     Is a symbolic name to identify the common block.

    nlist  Is one or more names of variables, arrays, array 
           declarators, or records to identify elements of 
           the common block.

 Any common block name, blank or otherwise, can appear more than
 once in one or more COMMON statements in a program unit.  The list
 following each successive appearance of the same common block name
 is treated as a continuation of the list for the block associated
 with that name.

 You can use array declarators in the COMMON statement to define
 arrays.

 A common block can have the same name as a variable, array, record,
 structure, or field.  However, in a program with one or more
 program units, a common block cannot have the same name as a
 function, subroutine, or entry name in the executable program.

 When common blocks from different program units have the same name,
 they share the same storage area when the units are combined into
 an executable program.

 Entities are assigned storage in common blocks on a one-for-one
 basis.  Thus, the entities assigned by a COMMON statement in one
 program unit should agree with the data type of entities placed in
 a common block by another program unit; for example, consider a
 program unit containing the following statement:

    COMMON CENTS

 Consider another program unit containing the following statements:

    INTEGER*2 MONEY
    COMMON MONEY

 When these program units are combined into an executable program,
 incorrect results can occur if the 2-byte integer variable MONEY is
 made to correspond to the lower-addressed two bytes of the real
 variable CENTS.

                                NOTE

         Note that on Digital UNIX  systems,  when  multiple
         object modules declare the same named COMMON block,
         all modules must declare the COMMON block to be the
         same  size,  or  the  module that gets loaded first
         must declare the COMMON block  to  be  its  maximum
         defined length.  If the common block is initialized
         by a DATA statement, then the module containing the
         initialization  must declare the common block to be
         its maximum defined length.

         This limitation does not apply if you  compile  all
         source  modules  together  using full optimization,
         which allows  interprocedural  analysis  to  handle
         COMMON  block size differences.  Loading of modules
         occurs in the order in which they are specified  on
         the compiler command line.

3 CONTINUE                
 Transfers control to the next executable statement.  The CONTINUE
 statement is used primarily as the terminal statement of a labeled
 DO loop when that loop would otherwise end improperly with a GOTO,
 arithmetic IF, or other prohibited control statement.  Statement
 format:

    CONTINUE
3 CYCLE                   
 The CYCLE statement terminates the current execution cycle of the
 innermost (or named) DO construct.  Statement format:

    CYCLE [name]

    name   Is the name of the DO construct. 

 When a CYCLE statement is executed, the following occurs:

 1.  The current execution cycle of the named (or innermost) DO
     construct is terminated.

     If a DO construct name is specified, the CYCLE statement must
     be within the range of that construct.

 2.  The iteration count (if any) is decremented by 1.

 3.  The DO variable (if any) is incremented by the value of the
     increment parameter (if any).

 4.  A new iteration cycle of the DO construct begins.


 Any executable statements following the CYCLE statement (including
 a labeled terminal statement) are not executed.

 A CYCLE statement can be labeled, but it cannot be used to
 terminate a DO construct.

 The following example shows the CYCLE statement:

 DO I =1, 10
   A(I) = C + D(I)
   IF (D(I) < 0) CYCLE    ! If true, the next statement is omitted
   A(I) = 0               ! from the loop and the loop is tested again.
 END DO
3 DATA                    
 Assigns values to variables at compile time.  The values within the
 backslashes are assigned to the preceding variables left to right;
 the number of values must equal the number of variable elements.
 Statement format:

    DATA nlist/clist/[[,] nlist/clist]...

    nlist  Is a list combining any combination of variable names,
           array names, array element names, character substring 
           names, and implied-DO lists.  (RECORDs are not allowed 
           in this list.)  Elements in the list must be separated 
           by commas.

           Subscript expressions and expressions in substring 
           references must be integer expressions containing 
           integer constants and implied-DO variables.
  
           An implied-DO list in a DATA statement takes the 
           following form:

           (dlist, i = n1,n2[,n3])

           dlist     Is a list of one or more array element 
                     names, character substring names, or 
                     implied-DO lists, separated by commas.

           i         Is the name of an integer variable.

           n1,n2,n3  Are integer constant expressions.  The 
                     expression can contain implied-DO variables 
                     of other implied-DO lists that have this 
                     implied-DO list within their ranges.

    clist  Is a list of constants separated by commas; "clist"
           constants take one of the following forms:

           c OR n *c
  
           c  Is a constant or the symbolic name of a constant.

           n  Defines the number of times the same value is to 
              be assigned to successive entities in the associated 
              "nlist"; "n" is a nonzero, unsigned integer constant 
              or the symbolic name of an unsigned integer constant.

 The DATA statement assigns the constant values in each "clist" to
 the entities in the preceding "nlist", from left to right, as they
 appear in the "nlist".  The number of constants must equal the
 number of entities in the "nlist".

 When an unsubscripted array name appears in a DATA statement,
 values are assigned to every element of that array in the order of
 subscript progression.  The associated constant list must contain
 enough values to fill the array.

 For more information on the relationship between "nlist" and
 "clist", see your DEC Fortran user manual.
3 DELETE                  
 Deletes a record from a relative file.  Statement format:


 Format -- Relative:

    DELETE ([UNIT=]u ,REC=r [,ERR=s] [,IOSTAT=ios])
    DELETE (u'r [,ERR=s] [,IOSTAT=ios])

    Deletes the specified record from a relative file.

    u    Is the logical unit specifier, optionally prefaced 
         by UNIT=.  UNIT= is required if unit is not the first 
         I/O specifier.

    r    Is a record position specifier, prefaced by REC=.

    u'r  Is a unit and a record position specifier, not 
         prefaced by REC=.

    s    Is the label of a statement to which control is 
         transferred if an error occurs, prefaced by ERR=.

    ios  Is an I/O status specifier, prefaced by IOSTAT=.

 The forms of the DELETE statement with relative files are direct
 access deletes.  These forms delete the record specified by the
 number "r".

 The DELETE statement logically removes the appropriate record from
 the specified file by locating the record and marking it as a
 deleted record.  A new record can be written into that position.

 Following a direct access delete, any associated variable is set to
 the next record number.

 NOTE:  You must specify the -vms compiler option for future READs
 to detect that a record has been deleted.
3 DICTIONARY              
 This statement is only available on VMS systems.
3 DIMENSION               
 Defines the number of dimensions in an array and the number of
 elements in each dimension.  Statement format:

    DIMENSION a([d1:]d2)[,a([d1:]d2)]...

    a        Is the symbolic name of the array.  If the array 
             is not defined in a data type statement, the array 
             takes an implicit data type.

    [d1:]d2  Is the optional lower (d1) and required upper (d2) 
             bounds of the array.
3 DO                      
 Executes a block of statements repeatedly until the value of a
 control variable equals, exceeds, or is less than the terminal
 value, according to the control variable specified in the DO loop
 (indexed DO).  The block of statements starts immediately following
 the DO statement.

 You can transfer control out of a DO loop, but not out of a
 parallel DO loop.

 Statement format:

     [name:] DO [s[,]] v = e1,e2[,e3]
        block
     [s] term-stmt

     name Is the name of the DO construct.

     s    Is the optional label of an executable statement 
          which follows the DO statement in the same program unit. 
          The label designates the last statement of the DO
          loop. If omitted, an END DO statement is required.

     v    Is the control variable; an integer or real variable
          (it cannot be a record field).  You cannot modify 
          the control variable inside the DO loop.

     e1   Is the initial value of the control variable; an 
          integer or real value.

     e2   Is the terminal value of the control variable; an 
          integer or real value.

     e3   Is the value by which to increment the control 
          variable after each execution of the DO loop; 
          integer or real value.  It cannot be 0. 
          The default of e3 is 1.

     block Is a sequence of zero or more statements or
           constructs.

     term-stmt Is the terminal statement for the construct.

 If the iteration count (the number of executions of the DO range)
 is zero or negative, the body of the loop is not executed.  If the
 -nof77 compiler option is specified and the iteration count is zero
 or negative, the body of the loop is executed once.

 If a DO statement does not contain a terminal statement label, the
 construct must be terminated by an END DO statement.  If it does
 contain a terminal statement label, the END DO is optional.

 If a construct name is specified in a block DO statement, the same
 name must appear in the terminal END DO statement.  If no construct
 name is specified in the block DO statement, no name can appear in
 the terminal END DO statement.  The construct name must be a unique
 identifier in the program unit.

 The following cannot be terminal statements for DO constructs:
 CYCLE, DO, END (for a program unit), EXIT, GO TO, IF, RETURN, or
 STOP.
3 DO_WHILE                
 Executes a block of statements repeatedly until the value of a
 logical expression is false.  Statement format:

    DO [s[,]] WHILE (e)

    s  Is the label of an executable statement which follows 
       the DO statement in the same program unit. The label 
       designates the last statement of the DO loop. If 
       omitted, an END DO statement is required.

    e  Is a logical expression.  You can reference and modify 
       the variable elements of the expression within the 
       DO loop.

 You can transfer control out of a DO WHILE loop but not into a loop
 from elsewhere in the program.

 The DO WHILE statement tests the logical expression at the
 beginning of each execution of the loop, including the first.  If
 the value of the expression is true, the statements in the body of
 the loop are executed; if the expression is false, control
 transfers to the statement following the loop.

 If no label appears in the DO WHILE statement, the DO WHILE loop
 must be terminated with an END DO statement.
3 ELSE                    
 Executes a block of statements if no preceding statement block in a
 block IF construct was executed.  The block of statements starts
 immediately following the ELSE statement.  The block is terminated
 by an END IF statement.  Statement format:

    ELSE
3 ELSE_IF                 
 Executes a block of statements if no preceding statement block in a
 block IF construct was executed and if the value of a logical
 expression is true.  The block of statements starts immediately
 following the ELSE IF statement.  The block is terminated by
 another ELSE IF statement, an ELSE statement, or an END IF
 statement.  Statement format:

    ELSE IF (e) THEN

    Where e represents a logical expression.
3 END                     
 Marks the end of a program unit.  The END statement must be present
 as the last statement of every program unit.  In a main program,
 execution terminates if control reaches the END statement.  In a
 subprogram, a RETURN statement is implicitly executed.  Statement
 format:

    END
3 END_DO                  
 Terminates the block of statements following a DO or DO WHILE
 statement when a label is not used.  Statement format:

    END DO
3 END_IF                  
 Terminates a block IF construct.  Statement format:

    END IF
3 END_MAP                 
 Marks the end of a map declaration within a union declaration in a
 structure declaration block.  Terminates a field declaration or a
 series of field declarations that started with the MAP statement.
 The END MAP statement must be present in a map declaration.
 Statement format:

    END MAP
3 END_SELECT              
 Marks the end of a CASE construct.  Statement format:

    END SELECT [name]
3 END_STRUCTURE           
 Marks the end of a structure declaration.  The END STRUCTURE
 statement must be present as the last statement of every structure
 declaration.  Statement format:

    END STRUCTURE
3 END_UNION               
 Marks the end of a union declaration within a structure declaration
 block.  The END statement must be present as the last statement of
 every union declaration.  Statement format:

    END UNION
3 ENDFILE                 
 Writes an end-of-file record to the specified unit.  Statement
 format:

    ENDFILE ([UNIT=]u[,ERR=s][,IOSTAT=ios])
    ENDFILE u

    u    Is an integer variable or constant specifying 
         the logical unit number of the file, optionally  
         prefaced by UNIT=.  UNIT= is required if unit is 
         not the first I/O specifier.

    s    Is the label of a statement to which control is 
         transferred if an error occurs, prefaced by ERR=.

    ios  Is an integer variable to which the completion 
         status of the I/O operation is returned, prefaced 
         by IOSTAT= (a zero if no error occurs; a positive
         value if an error occurs).

 If the unit specified in the ENDFILE statement is not open, the
 default file is opened for unformatted output.

 An end-of-file record consists of one byte with the ASCII value 26
 (Ctrl/Z).  An end-of-file record can be written only to sequential
 organization files that are accessed as formatted sequential files
 or unformatted segmented sequential files.

 An ENDFILE statement must not be specified for a file that is open
 for direct access.  End-of-file records should not be written in
 files that are read by programs written in a language other than
 Fortran.
3 ENTRY                   
 Designates an alternate entry point at which execution of a
 subprogram can commence.  You cannot use an ENTRY statement in a DO
 loop or a block IF construct.  Statement format:

    ENTRY nam [([p[,p]...])]

    nam  Is a symbolic name for the entry point.  The name 
         must be unique among all global names in the program.  
         In a function subprogram, the data type defined for 
         or implied by the name and the data type of the
         function must be consistent within the following groups:  

         Group 1: BYTE, INTEGER*1, INTEGER*2, INTEGER*4, 
                  INTEGER*8 (Alpha only), LOGICAL*1, LOGICAL*2, 
                  LOGICAL*4, LOGICAL*8 (Alpha only), REAL*4, 
                  REAL*8, and COMPLEX*8 
         Group 2: REAL*16 (Alpha only) and COMPLEX*16 
         Group 3: CHARACTER

         If the data type is character, the length of the entry 
         point name must be the same as the function name or must 
         be of passed length.

    p    Is a dummy argument or an alternate return argument 
         (designated by an asterisk).  The arguments must agree in 
         order, number, and type with the actual arguments of the 
         statement invoking the entry point.  The arguments need 
         not agree in name, order, number, or type with the
         dummy arguments in the SUBROUTINE or FUNCTION statement 
         for the subprogram.  You must use only the dummy arguments 
         defined in the ENTRY statement.

 The ENTRY statement is not executable and can appear within a
 function or subroutine program after the FUNCTION or SUBROUTINE
 statement.  Execution of a subprogram referred to by an entry name
 begins with the first executable statement after the ENTRY
 statement.
3 EQUIVALENCE             
 Starts two or more data elements in one program unit at the same
 storage location, thereby overlaying them in memory.  Statement
 format:

    EQUIVALENCE (nlist)[,(nlist)]...

    nlist  Is a list of variables, array elements, arrays, 
           or character substring references, separated by 
           commas.  You must specify at least two of these 
           entities in each list.

 The elements named within each set of parentheses are given the
 same storage location.  The data elements do not have to be of the
 same type or length.  An equivalency begins with the first byte of
 each element.  When an array or substring element is equivalenced,
 the entire array or string is equivalenced in its normal linear
 storage.

 You cannot equivalence array or string elements in a manner that is
 inconsistent with their normal linear order.  You cannot
 equivalence elements of the same array or string.  You cannot
 equivalence two elements that are both in common areas.

 Records, record fields, and dummy arguments cannot be specified in
 EQUIVALENCE statements.

 You can identify a multidimensional array element by a single
 subscript.  The single subscript designates the absolute position
 of the element within the array.
3 EXIT                    
 The EXIT statement terminates a DO construct.  Statement format:

    EXIT [name]

    name  Is the name of the DO construct. 

 When an EXIT statement is executed, the named (or innermost) DO
 construct is terminated.

 If a DO construct name is specified, the EXIT statement must be
 within the range of that construct.

 Any DO variable present retains its last defined value.

 An EXIT statement can be labeled, but it cannot be used to
 terminate a DO construct.

 The following example shows an EXIT statement:

 LOOP_A : DO I = 1, 15
   N = N + 1
   IF (N > I) EXIT LOOP_A
 END DO LOOP_A
3 EXTERNAL                
 Specifies that a name is a global symbol defined outside the
 program unit.  Statement format:

    EXTERNAL v[,v]...
    EXTERNAL *v[,*v]...

    v  Is the symbolic name of a user-supplied subprogram, or
       the name of a dummy argument associated with the name
       of a subprogram.  If you name an intrinsic subprogram, 
       that name becomes disassociated from the intrinsic
       subprogram and is assumed to be the name of an external 
       element.  (The INTRINSIC statement allows intrinsic
       function names to be used as arguments.)

    *  Is permitted only with the -nof77 (/NOF77 on VMS 
       systems) option.

 You must use EXTERNAL statements in the following cases:

  -  To identify subprogram or entry point names passed as actual
     arguments

  -  To identify a block data program unit that will reside in a
     library module not explicitly referenced at link time.


 You do not need to use an EXTERNAL statement to identify a
 subprogram or entry point name used as the object of a CALL
 statement or function reference; these names are recognized as
 external implicitly.
3 FORMAT                  
 Defines the conversion of data in formatted data transfer
 operations.  Statement format:

    FORMAT (q1 f1s1 f2s2 ... fnsn qn)

    qn   Is zero or more slash (/) record terminators.

    fn   Is a field descriptor, an edit descriptor, or
         a group of field and edit descriptors enclosed
         in parentheses.

    sn   Is a field separator (a comma or slash).  A
         comma can be omitted in the following cases:

         o Between a P edit descriptor and an immediately
           following F, E, D, or G edit descriptor.

         o Before or after a slash (/) record terminator.

         o Before or after a colon (:) edit descriptor.

 The "field descriptor" has one of the following forms:

    [r]c  [r]cw  [r]cw.m  [r]cw.d[Ee]

    r    Is the optional repeat count.  (If you omit r, 
         the repeat count is assumed to be 1.)

    c    Is a format code (I,O,Z,F,E,D,G,L, or A).

    w    Is the external field width in characters.  Each
         data item in the external medium is called an 
         external field.

    m    Is the minimum number of characters that must appear 
         in the field (including leading zeros).

    d    Is the number of characters to the right of the decimal point.

    E    Is an exponent field.

    e    Is the number of characters in the exponent.

 The ranges for "r", "w", "m", "d", and "e" are as follows:

 Term      Range                 
 ----      __________                 
  r        1 to 2147483647 (2**31-1)  
  w        1 to 2147483647            
  m        0 to 32767 (2**15-1)       
  d        0 to 32767                 
  e        1 to 32767                 

 The terms must all be unsigned integer constants or variable format
 expressions.  A variable format expression is an integer variable
 or expression enclosed in angle brackets that takes the place of an
 integer constant.  The value of the variable or variables can
 change during program execution.

 You cannot use PARAMETER constants for "r", "w", "m", "d", or "e".

 The "edit descriptor" has one of the following forms:

    c  [n]c  c[n]
   
    c     Is a format code (X,T,TL,TR,SP,SS,S,BN,BZ,P,H,
          '...', "...", Q, $, or :).

    n     Is the optional number of characters or character
          positions.

 The term "n" must be an unsigned integer constant (for format code
 P, it can be signed or unsigned) or a variable format expression.
 A variable format expression is an integer variable or expression
 enclosed in angle brackets that takes the place of an integer
 constant.  The value of the variable or variables can change during
 program execution.

 The value of "n" for P must be within the range -128 to 127.  For
 all other format codes, the value of "n" must be within the range 1
 through 2147483647 (2**31-1); actual useful ranges may be
 constrained by record sizes (RECL) and the file system.

 For more information, see FORMAT_SPECIFIERS in this online Help
 file.
3 FUNCTION                
 Begins a function subprogram.  Identifies the data type of the
 function and names the dummy arguments.  Format:

    [typ] FUNCTION nam [*m][([p[,p]...])]

    typ  Is a data type.  If you do not specify a data type, 
         the data type of the function is implied from its 
         name.  If the data type is CHARACTER, you can specify 
         CHARACTER*(*) to indicate a passed length function
         type -- the function type assumes the length of its 
         definition in the program unit invoking it.

    nam  Is a symbolic name for the function.  The name must be 
         unique among all global names in the program.  The name 
         is used as a variable within the function.  The value of 
         the variable is returned to the caller of the function 
         as the value of the function.

    m    Is an unsigned, nonzero integer specifying the length of
         the data type. It must be one of the valid length specifiers
         for "typ".  This length overrides the length specified or 
         implied by the type.

    p    Is an unsubscripted variable name specifying a dummy 
         argument.  The arguments must agree in order, number, and 
         type with the actual arguments of the statement invoking 
         the function.  A dummy argument must not be defined as an 
         array with more elements than the actual argument holds.

 The array declarator for a dummy argument can itself contain
 integer values that are dummy arguments or are references to a
 common block, providing for adjustable size arrays in functions.
 The upper bound of the array declarator for a dummy argument can be
 specified as an asterisk, in which case the upper bound of the
 dummy argument assumes the size of the upper bound of the actual
 argument.  The size in a character string declarator for a dummy
 argument can be specified as an asterisk in parentheses (*) -- in
 which case the size of the actual argument is passed to the dummy
 argument.

 The values of the actual arguments in the invoking program unit
 become the values of the dummy arguments in the function.  If you
 modify a dummy argument, the corresponding actual argument in the
 invoking program unit is also modified; the actual argument must be
 a variable if it is to be modified.

 If the actual argument is a character constant, the dummy argument
 can be either character or numeric in type, unless the name of the
 subprogram being invoked is a dummy argument in the invoking
 program unit.  If the actual argument is a Hollerith constant, the
 dummy argument must be numeric.

 The FUNCTION statement must be the first statement of a function
 subprogram, unless an OPTIONS statement is specified.  A function
 subprogram cannot contain a SUBROUTINE statement, a BLOCK DATA
 statement, a PROGRAM statement, or another FUNCTION statement.
 ENTRY statements can be included to provide multiple entry points
 to the subprogram.

                                NOTE

         In a function, the function name identifier  refers
         to  the  return  value,  not  the  function itself,
         unless an argument list is present.  Therefore,  it
         is  not  possible to pass a function as an argument
         to another routine from inside the  function.   For
         example, consider the following:

            INTEGER FUNCTION RECURSIVE_FUNCTION
               . 
               .
               .
            CALL OTHERSUB (RECURSIVE_FUNCTION)

         The reference to  RECURSIVE_FUNCTION  in  the  CALL
         statement passes the function return value, not the
         function itself.

3 Function_Reference      
 Transfers control and passes arguments to a function.  Format:

    nam (p[,p]...)

    nam  Is the name of the function or the name of an entry 
         point to the function.

    p    Is a value to be passed to the function.  The value 
         can be a constant, the name of a variable, the name 
         of an array element, the name of an array, an expression, 
         a substring, field reference, or the name of a subprogram 
         or entry point to a subprogram (must be defined as 
         external).  You must not specify more than 255 arguments.
3 GOTO                    
 Transfers control within a program unit.  Depending upon the value
 of an expression, control is transferred either to the same
 statement every time GO TO is executed or to one of a set of
 statements.
4 Unconditional  
 Transfers control unconditionally to the same statement every time
 the GO TO is executed.  Statement format:

    GO TO s

    s  Is the label of an executable statement that is 
       in the same program unit as the GO TO statement.
4 Computed       
 Transfers control to a statement based upon the value of an
 expression within the statement.  Statement format:

    GO TO (slist)[,]e

    slist  Is a list of one or more labels of executable 
           statements separated by commas. The list of labels 
           is called the transfer list.

    e      Is an integer arithmetic expression in the range 
           1 to n (where "n" is the number of statement labels 
           in the transfer list).

 If the value of "e" is less than one or greater than the number of
 labels in the transfer list, control is transferred to the first
 executable statement after the computed GO TO.
4 Assigned       
 Transfers control to a statement label that is represented by a
 variable.  An ASSIGN statement must establish a relationship
 between the variable and the specified statement label.  Statement
 format:

    GO TO v[[,](slist)]

    v      Is an integer variable whose value was set by a 
           preceding ASSIGN statement in the same program unit.

    slist  Is a list of one or more labels of executable 
           statements separated by commas.
3 IF                      
 Conditionally transfers control or executes a statement or block of
 statements.

 For each type of IF statement, the decision to transfer control or
 to execute the statement or block of statements is based on the
 evaluation of an expression within the IF statement.
4 Arithmetic 
 Conditionally transfers control to one of three statements, based
 on the current value of an arithmetic expression.  Statement
 format:

    IF (e) s1,s2,s3

    e         Is an arithmetic expression.

    s1,s2,s3  Are labels of executable statements in the same 
              program unit.  All three labels are required, 
              but they need not refer to different statements.

 Executes the statement at the first label ("s1") if the arithmetic
 expression evaluates to a value less than 0; the statement at the
 second label ("s2") if the arithmetic expression evaluates to 0; or
 the statement at the third label ("s3") if the arithmetic
 expression evaluates to a value greater than 0.
4 Logical    
 Executes the statement if the logical expression is true.
 Statement format:

    IF (e) st

    e   Is a logical expression.

    st  Is a complete Fortran statement. The statement can 
        be any statement except DO, END DO, END, block IF, 
        or another logical IF statement.
4 Block      
 Executes a block of statements if the logical expression is true.
 The block of statements starts immediately following the IF
 statement.  The block of statements can be followed by optional
 ELSE IF statements (any number) and one optional ELSE statement.
 The entire block IF construct must be terminated by an END IF
 statement.  Format:

    IF (e) THEN
      block
    ELSE IF (e1) THEN
      block
    ELSE
      block
    END IF 

    e,e1   Are logical expressions.

    block  Is a series of zero or more Fortran statements
           (called a statement block).
 it must be unique.

 NOTE:  No additional statement can be placed after the IF THEN
 statement in a block IF construct.  For example, the following
 statement is invalid in the block IF construct:

    IF (e) THEN I = J

 This statement is translated as the following logical IF statement:

    IF (e) THENI = J
3 IMPLICIT                
 Overrides implied (default) data typing of symbolic names.
 Statement format:

    IMPLICIT typ (a[,a]...)[,typ (a[,a]...)]...

    typ  Is any data type except CHARACTER*(*).  When "typ" 
         is equal to CHARACTER*len, "len" specifies the length 
         for character data type.  The "len" is an unsigned 
         integer constant or an integer constant expression 
         enclosed in parentheses, and must be in the range of 
         1 to 2**31-1.

    a    Is an alphabetical character.  If you specify a 
         range of alphabetic characters (two characters 
         joined by a hyphen), the first character must be 
         less than the second.

 The IMPLICIT statement assigns the specified data type to all
 symbolic names that have no explicit data type and begins with the
 specified letter or range of letters.  It has no effect on the
 default types of intrinsic procedures.
3 IMPLICIT_NONE           
 Disables the implicit declaration of data types in the program
 unit.  When it is used, you must declare the data types of all
 symbols explicitly.  You must not include any other IMPLICIT
 statements in the program unit containing an IMPLICIT NONE
 statement.  Statement format:

    IMPLICIT NONE

 NOTE:  To receive diagnostic messages when variables are used but
 not declared, you can specify the -warn declarations compiler
 option instead of IMPLICIT NONE.
3 INCLUDE                 
 Directs the compiler to stop reading statements from the current
 file and read the statements in the included file.  When it reaches
 the end of the included file, the compiler resumes compilation with
 the next statement after the INCLUDE statement.  Statement format:

    INCLUDE 'full-file-name[/[NO]LIST]'

    INCLUDE '[text-lib] (module-name)[/[NO]LIST]' (VMS only)

    full-file-name  Is a character string that specifies 
                    the file to be included.  The form of
                    the "full-file-name" must be acceptable
                    to the operating system, as described
                    in your user manual.

    /[NO]LIST       Specifies whether the incorporated code 
                    is to appear in the compilation source 
                    listing.  (On U*X systems, you must specify 
                    the -vms compiler option to use this 
                    qualifier.)  In the listing, a number 
                    precedes each incorporated statement.  The 
                    number indicates the "include" nesting 
                    depth of the code. The default is /NOLIST.  
                    /LIST and /NOLIST must be spelled completely.

    text-lib (VMS only)    Is a character string that specifies 
                           the "full-file-name" of the text 
                           library to be searched.  Its form must 
                           be acceptable to the operating system, 
                           as described in your user manual.

    module-name (VMS only) Is the name of the text module, located 
                           in a text library, that is to be included. 
                           The name of the module must be enclosed 
                           in parentheses.  It can be up to 31 char-
                           acters long and can contain any alpha-
                           numeric character and the special char-
                           acters dollar sign ($) and underscore (_).

 The file must contain valid Fortran statements.  The file cannot
 start with a continuation line, but it can contain an INCLUDE
 statement.

 The limit on nesting depth is when system resources are exhausted.

 In the following example, the file COMMON.FOR defines a parameter
 constant M, and defines arrays X and Y as part of the blank common
 block.

    Main Program File              COMMON.FOR File
    -----------------              ---------------
    INCLUDE 'COMMON.FOR'           PARAMETER (M=100)
    DIMENSION Z(M)                 COMMON X(M),Y(M)
    CALL CUBE
    DO 5, I=1,M

 5  Z(I) = X(I)+SQRT(Y(I))
        .
        .
        .
    END

    SUBROUTINE CUBE
    INCLUDE 'COMMON.FOR'
    DO 10, I=1,M
 10 X(I) = Y(I)**3
    RETURN
    END
3 Input_Output            
 Transfer I/O statements include READ, WRITE, REWRITE, ACCEPT, TYPE,
 and PRINT.  Auxiliary I/O statements include OPEN, CLOSE, INQUIRE,
 REWIND, BACKSPACE, ENDFILE, and DELETE.

 Transfer I/O statements may be formatted (F), unformatted (U),
 list-directed (L-D), or namelist (N) as follows:

    ACCEPT     Sequential -- F, L-D, N
    DELETE     Relative -- U
               Indexed -- U (VMS only)
    PRINT      Sequential -- F, L-D, N
    READ       Sequential -- F, U, L-D, N
               Direct Access -- F, U
               Internal -- F, L-D
               Indexed -- F, U (VMS only)
    REWRITE    Relative -- F, U
               Sequential -- F
               Indexed -- F, U (VMS only)
    TYPE       Sequential -- F, L-D, N
    WRITE      Sequential -- F, U, L-D, N
               Direct Access -- F, U
               Internal -- F, L-D
               Indexed -- F, U (VMS only)
4 Formatted        
 Formatted I/O statements contain explicit format specifiers that
 are used to control the translation of data from internal (binary)
 form within a program to external (readable character) form in the
 records, or vice versa.

 Formatted I/O statements must have a format (FMT=) specified in the
 control list (clist).  Additional "clist" elements are required
 depending on the type of access.

 Formatted sequential READ:

   READ (UNIT=u,FMT=f[,IOSTAT=ios][,ERR=err]
         [,END=end]) [iolist]
   READ f [,iolist]

 Formatted direct access READ:

   READ (UNIT=u,REC=rec,FMT=f[,IOSTAT=ios][,ERR=err]) [iolist]
    
 Formatted indexed READ (VMS only):

   READ (UNIT=u,FMT=f,KEY=k[,KEYID=n][,IOSTAT=ios]
         [,ERR=err]) [iolist]

 Formatted internal READ:

   READ (UNIT=u,FMT=f[,IOSTAT=ios][,ERR=err]
         [,END=end]) [iolist]

 Formatted sequential WRITE:

   WRITE (UNIT=u,FMT=f[,IOSTAT=ios][,ERR=err]) [iolist]

 Formatted direct access WRITE:

   WRITE (UNIT=u,REC=rec,FMT=f[,IOSTAT=ios]
          [,ERR=err]) [iolist]

 Formatted indexed WRITE (VMS only):

   WRITE (UNIT=u,FMT=f[,IOSTAT=ios][,ERR=err]) [iolist]

 Formatted internal WRITE:

   WRITE (UNIT=u,FMT=f[,IOSTAT=ios][,ERR=err]) [iolist]
4 Unformatted      
 Unformatted I/O statements do not contain format specifiers and
 therefore do not translate the data being transferred.

 Unformatted I/O is especially appropriate where the output data
 will subsequently be used as input.  Unformatted I/O saves
 execution time by eliminating the data translation process,
 preserves greater precision in the external data, and usually
 conserves file storage space.

 Unformatted I/O statements do not specify a format (FMT=) in the
 control list (clist).  Other "clist" elements are required
 depending on the type of access.

 Unformatted sequential READ:

   READ (UNIT=u[,IOSTAT=ios][,ERR=err][,END=end]) [iolist]

 Unformatted direct access READ:

   READ (UNIT=u,REC=rec[,IOSTAT=ios][,ERR=err]) [iolist]

 Unformatted indexed READ (VMS only):

   READ (UNIT=u,KEY=k[,KEYID=n][,IOSTAT=ios][,ERR=err]) [iolist]

 Unformatted sequential WRITE:

   WRITE (UNIT=u,[,IOSTAT=ios][,ERR=err]) [iolist]

 Unformatted direct access WRITE:

   WRITE (UNIT=u,REC=rec[,IOSTAT=ios][,ERR=err]) [iolist]

 Unformatted indexed WRITE (VMS only):

   WRITE (UNIT=u[,IOSTAT=ios][,ERR=err]) [iolist]
4 List_Directed    
 List-directed I/O statements are similar to formatted statements in
 function, but control the translation of data through data types
 instead of explicit format specifiers.

 List-directed I/O statements specify a format (FMT=) in the control
 list (clist).  Other "clist" elements are required depending on the
 type of access.

 List-directed sequential READ:

   READ (UNIT=u,FMT=*[,IOSTAT=ios][,ERR=err][,END=end]) [iolist]
   READ * [,iolist]

 List-directed internal READ

   READ (UNIT=u,FMT=*[,IOSTAT=ios][,ERR=err][,END=end]) [iolist]

 List-directed sequential WRITE

   WRITE (UNIT=u,FMT=*[,IOSTAT=ios][,ERR=err]) [iolist]

 List-directed internal WRITE

   WRITE (UNIT=u,FMT=*[,IOSTAT=ios][,ERR=err]) [iolist]
4 Namelist           
 Namelist I/O statements are similar to formatted statements in
 function, but control the translation of data through data types
 instead of explicit format specifiers.

 Namelist I/O statements do not specify a format (FMT=) in the
 control list (clist).

 Namelist sequential READ:

    READ (UNIT=u,NML=nml[,IOSTAT=ios][,ERR=err][,END=end]) 
    READ n

 Namelist sequential WRITE:

   WRITE (UNIT=u,NML=nml[,IOSTAT=ios][,ERR=err]) 

 Comments (beginning with !  only) can appear anywhere in namelist
 input.  The comment extends to the end of the source line.
3 INQUIRE                 
 Returns information about specified properties of a file or of a
 logical unit on which a file might be opened.  The unit need not
 exist, nor need it be connected to a file.  If the unit is
 connected to a file, the inquiry encompasses both the connection
 and the file.  Statement format:

    INQUIRE (FILE=fi [,DEFAULTFILE=dfi...], flist)
    INQUIRE ([UNIT=]u,flist)

    fi     Is a character expression, numeric scalar memory 
           reference, or numeric array name reference whose 
           value specifies the name of the file to be 
           inquired about.  (This file name can start with a 
           tilde (~) on U*X systems.)

    dfi    Is a character expression specifying a default file 
           pathname (or file specification) string.  (This file 
           name can start with a tilde (~) on U*X systems.)

    flist  Is a list of property specifiers in which any one 
           specifier appears only once.  Information about the 
           individual specifiers is available under the 
           subtopic headings listed at the end of this Help 
           topic.

    u      Is an integer variable or constant specifying the 
           logical unit number of the file, optionally prefaced 
           by UNIT=.  UNIT= is required if unit is not the 
           first I/O specifier.  The unit does not have to 
           exist, nor does it need to be connected to a file.
           If the unit is connected to a file, the inquiry 
           encompasses both the connection and the file.

 FILE=fi and UNIT=u can appear anywhere in the property-specifier
 list; however, if the UNIT keyword is omitted, the unit specifier
 ("u") must be the first parameter in the list.

 When inquiring by file, you can specify DEFAULTFILE=dfi in addition
 to, or in place of, FILE=fi.  If a file is open with both FILE and
 DEFAULTFILE keywords specified in the OPEN statement, then you can
 inquire about this file by specifying both the FILE and DEFAULTFILE
 keywords in the INQUIRE statement.

 An INQUIRE statement may be executed before, during, or after the
 connection of a file to a unit.  The values assigned by the
 statement are those that are current when the INQUIRE statement
 executes.

 You can use INQUIRE to get file characteristics after opening a
 file.
4 ACCESS          
 ACCESS = acc

 acc  Is a character scalar memory reference that is 
      assigned one of the following values:

 'SEQUENTIAL'  If the file is open for sequential access 
 'DIRECT'      If the file is open for direct access 
 'UNKNOWN'     If the file is not open
4 BLANK           
 BLANK = blnk

 blnk  Is a character scalar memory reference that is 
       assigned one of the following values:

 'NULL'      If null blank control is in effect for the
             file open for formatted I/O.  (Blanks are 
             ignored unless the field is all blanks, in
             which case it is treated as zero.)

 'ZERO'      If zero blank control is in effect.  (All 
             blanks other than leading blanks are treated 
             as zeros.)

 'UNKNOWN'   If the file is not open or if the existing
             file is not open for formatted I/O.
4 CARRIAGECONTROL
 CARRIAGECONTROL = cc

 cc  Is a character scalar memory reference that is
     assigned one of the following values:

 'FORTRAN'  If the file is open with the FORTRAN carriage 
            control 
 'LIST'     If the file is open with implied carriage control
            (single spacing between records)
 'NONE'     If the file is open with no carriage control 
            attribute
 'UNKNOWN'  If the file is not open
4 CONVERT         
 CONVERT = fm

 fm  Is a character scalar memory reference that is assigned 
     one of the following values:

 'LITTLE_ENDIAN':  If the file is open with little endian 
                   integer and IEEE floating-point data 
                   conversion in effect.

 'BIG_ENDIAN':     If the file is open with big endian 
                   integer and IEEE floating-point data 
                   conversion in effect.

 'CRAY':           If the file is open with big endian 
                   integer and CRAY floating-point data 
                   conversion in effect.

 'FDX':            If the file is open with little endian 
                   integer and Digital VAX F_floating, 
                   D_floating, and IEEE X_floating data 
                   conversion in effect.

 'FGX':            If the file is open with little endian 
                   integer and Digital VAX F_floating, 
                   G_floating, and IEEE X_floating data 
                   conversion in effect.

 'IBM':            If the file is open with big endian 
                   integer and IBM System\370 floating-
                   point data conversion in effect.

 'VAXD':           If the file is open with little endian 
                   integer and Digital VAX F_floating, 
                   D_floating, and H_floating data 
                   conversion in effect.

 'VAXG':           If the file is open with little endian 
                   integer and Digital VAX F_floating, 
                   G_floating, and H_floating data 
                   conversion in effect.

 'NATIVE':         If the file is open with no data 
                   conversion in effect.

 'UNKNOWN':        If the file or unit is not connected 
                   for unformatted I/O.
4 DIRECT          
 DIRECT = dir

 dir  Is a character scalar memory reference that is
      assigned one of the following values:

 'YES'       If the file is open for direct access
 'NO'        If the file is not open for direct access
 'UNKNOWN'   If the file is not open 
4 ERR             
 ERR = s

 s  Is the label of an executable statement.

 ERR is a control specifier rather than a property specifier.  If an
 error occurs during the execution of the INQUIRE statement, control
 is transferred to the statement whose label is "s".
4 EXIST           
 EXIST = lv

 lv  Is a logical scalar memory reference that is
     assigned one of the following values:

 .TRUE.    If the specified file exists and can be opened 
           or if the unit exists
 .FALSE.   If the specified file or unit does not exist or 
           if the file exists but cannot be opened 

 The unit exists if it is a number in the range allowed by the
 processor.
4 FORM            
 FORM = fm

 fm  Is a character scalar memory reference that is
     assigned one of the following values:

 'FORMATTED'     If the file is open for formatted I/O
 'UNFORMATTED'   If the file is open for unformatted I/O
 'UNKNOWN'       If the file is not open
4 FORMATTED       
 FORMATTED = fmd

 fmd  Is a character character scalar memory reference that is
      assigned one of the following values:

 'YES'       If formatted I/O is allowed
 'NO'        If formatted I/O is not allowed
 'UNKNOWN'   If the processor cannot determine whether formatted
             I/O is allowed
4 IOSTAT          
 IOSTAT = ios

 ios  Is an integer scalar memory reference.

 IOSTAT is a control specifier rather than a property specifier.
 The "ios" is assigned a processor-dependent positive integer value
 if an error occurs during execution of the INQUIRE statement; it is
 assigned the value zero if there is no error condition.
4 KEYED           
 This specifier is only available on VMS systems.
4 NAME            
 NAME = nme

 nme  Is a character scalar memory reference that is 
      assigned the name of the file being inquired about.  
      If the file does not have a name, "nme" is undefined.

 NOTE:  The FILE and NAME keywords are synonyms when used with the
 OPEN statement, but not when used with the INQUIRE statement.
4 NAMED           
 NAMED = nmd

 nmd  Is a logical scalar memory reference that is
      assigned one of the following values:

 .TRUE.    If the specified file has a name
 .FALSE.   If the file does not have a name
4 NEXTREC         
 NEXTREC = nr

 nr  Is an integer scalar memory reference whose value depends
     on the following conditions:

     - If a record was previously read or written on the 
       specified unit, the value of "nr" is one more than the 
       number of that record.

     - If no records have been read or written, the value 
       of "nr" is 1.

     - If the file is not opened for direct access or if the 
       position is indeterminate because of an error condition, 
       "nr" is 0.
4 NUMBER          
 NUMBER = num

 num  Is an integer scalar memory reference to which the 
      logical unit number of the file is returned.  No value 
      is returned if the file is not connected to a unit.
4 OPENED          
 OPENED = od

 od  Is a logical scalar memory reference that is
     assigned one of the following values:

 .TRUE.    If the specified file or unit is open
 .FALSE.   If the specified file or unit is not open
4 ORGANIZATION    
 ORGANIZATION = org

 org  Is a character scalar memory reference that is
      assigned one of the following values:

 'SEQUENTIAL'          If the file is a sequential file
 'RELATIVE'            If the file is a relative file
 'INDEXED' (VMS only)  If the file is an indexed file
 'UNKNOWN'             If the file organization cannot 
                          be determined
4 RECL            
 RECL = rcl

 rcl  Is an integer scalar memory reference to which the 
      maximum allowed record length is returned if the file 
      or unit is open.  If the file or unit is not open or 
      does not exist, rcl is zero.

 The length is expressed in bytes for formatted files and longwords
 for unformatted files.
4 RECORDTYPE      
 RECORDTYPE = rtype

 rtype  Is a character scalar memory reference that is
        assigned one of the following values:

 'FIXED'       If the file is open for fixed-length records
 'VARIABLE'    If the file is open for variable-length records
 'SEGMENTED'   If the file is open for unformatted sequential
               I/O using segmented records
 'STREAM'      If the file's records are not terminated
 'STREAM_CR'   If the file's records are terminated with a 
               carriage-return
 'STREAM_LF'   If the file's records are terminated with a 
               line-feed
 'UNKNOWN'     If the file is not open
4 SEQUENTIAL      
 SEQUENTIAL = seq

 seq  Is a character scalar memory reference that is
      assigned one of the following values:

 'YES'       If sequential access is allowed for the 
             specified file
 'NO'        If sequential access is not allowed
 'UNKNOWN'   If the access mode cannot be determined
4 UNFORMATTED     
 UNFORMATTED = unf

 unf  Is a character scalar memory reference that is
      assigned one of the following values:

 'YES'       If unformatted I/O is allowed for the 
             specified file
 'NO'        If unformatted I/O is not allowed
 'UNKNOWN'   If the form cannot be determined
3 INTRINSIC               
 Specifies that a symbolic name is the name of an intrinsic
 subprogram.  Statement format:

    INTRINSIC v[,v]...

    v  Is the symbolic name of an intrinsic subprogram.

 Subprogram names passed as actual arguments must be identified in
 INTRINSIC statements.  Names of subprograms used as the objects of
 CALL statements or function references do not need to be identified
 by means of INTRINSIC statements; these names are recognized as
 intrinsic implicitly.
3 MAP                     
 See Help topic:  STRUCTURE (subheads Unions and Type_declarations).
3 NAMELIST                
 Defines a list of variables or array names and associates that list
 with a unique group-name, which is used in the namelist I/O
 statement.

    NAMELIST /group-name/nlist[[,]/group-name/nlist]...

    group-name  Is a symbolic name.

    nlist       Is the list of (no more than 250) variable 
                or array names, separated by commas, to be 
                associated with the preceding group-name.

 You cannot include array elements, character substrings, pointers,
 records, and record fields in a namelist, but you can use namelist
 I/O to assign values to elements of arrays or substrings of
 character variables that appear in namelists.  Dummy arguments can
 appear in a namelist.

 The namelist entities can have any data type and can be explicitly
 or implicitly typed.

 Only the entities specified in the namelist can be read or written
 in namelist I/O.  It is not necessary for the input records in a
 namelist input statement to define every entity in the associated
 namelist.

 The order of entities in the namelist controls the order in which
 the values are written in the namelist output.  Input of namelist
 values can be in any order.

 A variable or an array name can appear in several namelists.
3 OPEN                    
 Opens an existing file or creates a new file.  If you do not
 explicitly open a file before accessing it, the file is created
 (for write operations) or opened with default attributes.

    OPEN (par[,par]...)

    par  Is a keyword specification in one of the 
         following forms:

         keywd
         keywd=value

         keywd  Is a keyword.  (See the subtopic headings
                listed at the end of this Help topic.)
         value  Is a keyword value. (Some keywords do not
                have keyword values.)

 If an OPEN statement is executed for a unit that is already open,
 and the file pathname (or specification) is different from that of
 the current open file, the previously opened file is closed and the
 new file is opened.  If the file pathname (or specification) is the
 same for both files, the new value of the BLANK= specifier is in
 effect, but the position of the file is unaffected.

 Keyword specifications can appear in any order.  In most cases,
 they are optional.  Default values apply in their absence.  If the
 logical unit specifier is the first parameter in the list, the UNIT
 keyword is optional.

 You can specify character values at run time by substituting a
 general character expression for a keyword value in the OPEN
 statement.  The character value can contain trailing spaces but not
 leading or embedded spaces; for example:

    CHARACTER*6 FINAL /' '/
        .
        .
        .
    IF (exp) FINAL = 'DELETE'
    OPEN (UNIT=1, STATUS='NEW', DISP=FINAL)

 NOTE:  Keyword values that are numeric expressions can be any
 integer or real expression.  The value of the expression is
 converted to integer data type before it is used in the OPEN
 statement.
4 ACCESS           
 ACCESS = acc

 acc  Is a character expression with one of the following 
      values:

 'DIRECT'           Access by record number
 'SEQUENTIAL'       Access sequentially (the default)
 'KEYED' (VMS only) Access by a specified key
 'APPEND'           Access sequentially, after the last record 
                    of the file

 On Digital UNIX systems, there may be limitations on record access
 by file organization and record type (see your DEC Fortran user
 manual).
4 ASSOCIATEVARIABLE
 ASSOCIATEVARIABLE = asv

 asv  Is an integer variable.  It cannot be a dummy argument
      to the routine in which the OPEN statement appears.
      Use only in direct access mode.  

 NOTE:  Direct access READ, direct access WRITE, FIND, DELETE, and
 REWRITE statements can affect the value of the variable.
4 BLANK            
 BLANK = blnk

 blnk  Is a character expression with one of the following 
       values:

 'NULL'  Ignore all blanks in a numeric field (unless the field 
         is all blanks, in which case treat blanks as zero).
 'ZERO'  Treat all blanks other than leading blanks as zeros.

 The default is 'NULL'.  However, if you specify the -nof77 compiler
 option (or OPTIONS /NOF77) or the -vms compiler option, the default
 is 'ZERO'.
4 BLOCKSIZE        
 BLOCKSIZE = bks

   bks  Is a numeric expression.

 If you specify a BLOCKSIZE number, it is rounded up to a multiple
 of 512 byte blocks.

 If you do not specify BLOCKSIZE or you specify zero, the filesystem
 default is assumed.
4 BUFFERCOUNT      
 BUFFERCOUNT = bc

 bc  Is a numeric expression.

 The range of values for bc is from 1 to 127.

 The BLOCKSIZE keyword determines the size of each buffer.  Thus, if
 BUFFERCOUNT=3 and BLOCKSIZE=2048, the total number of bytes
 allocated for buffers is 3*2048, or 6144.

 If you do not specify BUFFERCOUNT or you specify zero, the default
 is 1.
4 CARRIAGECONTROL  
 CARRIAGECONTROL = cc

 cc  Is a character expression with one of the following 
     values:

 'FORTRAN'   Process with normal FORTRAN interpretation of
             the first character
 'LIST'      Process with single spacing between records
 'NONE'      Do not use implied carriage control

 The default for unformatted files is 'NONE'.  The default for
 formatted files is 'LIST'.  However, if you specify the -vms
 compiler option, and the unit is connected to a terminal, the
 default is 'FORTRAN'.
4 CONVERT          
 CONVERT = fm

 fm  Is a character expression with one of the following 
     options:

    'LITTLE_ENDIAN'- Little endian integer data of the 
                     appropriate size (INTEGER*1, INTEGER*2, 
                     INTEGER*4, or INTEGER*8) and IEEE 
                     floating-point data of the appropriate size 
                     and type (REAL*4, REAL*8, REAL*16, COMPLEX*8, 
                     or COMPLEX*16).  INTEGER*1 data is the same 
                     for little endian and big endian.

    'BIG_ENDIAN' -   Big endian integer data of the appropriate
                     size (INTEGER*1, INTEGER*2, INTEGER*4, or
                     INTEGER*8) and IEEE floating-point data of 
                     the appropriate size and type (REAL*4, REAL*8, 
                     REAL*16, COMPLEX*8, or COMPLEX*16).  INTEGER*1 
                     data is the same for little endian and big 
                     endian.

    'CRAY' -         Big endian integer data of the appropriate
                     size (INTEGER*1, INTEGER*2, INTEGER*4, or
                     INTEGER*8) and CRAY floating-point data of 
                     size REAL*8 or COMPLEX*16.

    'FDX' -          Little endian integer data of the appropriate
                     size (INTEGER*1, INTEGER*2, INTEGER*4, or
                     INTEGER*8) and Digital VAX floating-point data
                     of format F_floating for REAL*4 or COMPLEX*8,
                     D_floating for size REAL*8 or COMPLEX*16, and
                     IEEE X_floating for REAL*16.

    'FGX' -          Little endian integer data of the appropriate
                     size (INTEGER*1, INTEGER*2, INTEGER*4, or
                     INTEGER*8) and Digital VAX floating-point data
                     of format F_floating for REAL*4 or COMPLEX*8,
                     G_floating for size REAL*8 or COMPLEX*16, and
                     IEEE X_floating for REAL*16.

    'IBM' -          Big endian integer data of the appropriate
                     size (INTEGER*1, INTEGER*2, INTEGER*4, or
                     INTEGER*8) and IBM System\370 floating-point
                     data of size REAL*4 or COMPLEX*8 (IBM
                     short 4) and size REAL*8 or COMPLEX*16 (IBM
                     long 8).

    'VAXD' -         Little endian integer data of the appropriate
                     size (INTEGER*1, INTEGER*2, INTEGER*4, or
                     INTEGER*8) and Digital VAX floating-point 
                     data of format F_floating for size
                     REAL*4 or COMPLEX*8, D_floating for size
                     REAL*8 or COMPLEX*16, and H_floating for
                     REAL*16.

    'VAXG' -         Little endian integer data of the appropriate
                     size (INTEGER*1, INTEGER*2, INTEGER*4, or
                     INTEGER*8) and Digital VAX floating-point 
                     data of format F_floating for size
                     REAL*4 or COMPLEX*8, G_floating for size 
                     REAL*8 or COMPLEX*16, and H_floating for
                     REAL*16.
     
    'NATIVE' -       No data conversion.  This is the default.

 You can use CONVERT to specify multiple formats in a single
 program, usually one format for each specified unit number.

 When reading a non-native format, the non-native format on disk is
 converted to native format in memory.  If a converted non-native
 value is outside the range of the native data type, a run-time
 message appears.

 There are other ways to specify numeric format for unformatted
 files:  you can specify a U*X environment variable or the compiler
 option CONVERT (or OPTIONS/CONVERT).  The order of precedence is
 U*X environment variable, OPEN (CONVERT=), OPTIONS/CONVERT, and
 then compiler option CONVERT.  The CONVERT compiler option and
 OPTIONS/CONVERT affect all unit numbers used by the program, while
 environmental variables and OPEN (CONVERT=) affect specific unit
 numbers.

 The following source code shows how to code the OPEN statement to
 read unformatted CRAY numeric data from unit 15, which might be
 processed and possibly written in little endian format to unit 20:

    OPEN (CONVERT='CRAY', FILE='graph3.dat', FORM='UNFORMATTED', 
   1     UNIT=15)
      .
      .
      .
    OPEN (FILE='graph3_native.dat', FORM='UNFORMATTED', UNIT=20)
4 DEFAULTFILE      
 DEFAULTFILE = ce

 ce  Is a character expression that specifies a default file
     pathname (or file specification) string.

 This keyword supplies a value to the Fortran I/O system that is
 prefixed to the FILE keyword parameter.

 The default file pathname string is used primarily when accepting
 file pathnames interactively.  File pathnames known to a user
 program are normally completely specified in the FILE keyword.

 If the DEFAULTFILE keyword value does not end in a slash (/), then
 one is added.

 If the DEFAULTFILE keyword is not supplied in the OPEN statement,
 the Fortran I/O system uses the current working directory.

 The following example opens the existing file
 /usr/users/someone/test.dat:

    OPEN (unit=10, DEFAULTFILE='/usr/users/someone/', 
   1     FILE='test.dat', FORM='FORMATTED', HISTORY='OLD')
4 DISPOSE          
 DISPOSE = dis
 or DISP = dis

 dis  Is a character expression with one of the following 
      values:

 'KEEP' or 'SAVE'  Retain the file after the unit is closed.
                   (*DEFAULT FOR ALL BUT SCRATCH FILES*)

 'DELETE'          Delete the file after the unit is closed.
                   (*DEFAULT FOR SCRATCH FILES*)

 'PRINT'           Submit the file as a print job and retain it.
                   Use this value only with sequential files.

 'PRINT/DELETE'    Submit the file as a print job and then 
                   delete it.  Use this value only with sequential 
                   files.

 'SUBMIT'          Fork a process to execute the file.

 'SUBMIT/DELETE'   Fork a process to execute the file, and 
                   delete the file after the fork is completed.

 The disposition specified in a CLOSE statement supersedes the
 disposition specified in the OPEN statement, except that a file
 opened as a scratch file cannot be saved, printed, or submitted,
 nor can a file opened for read-only access be deleted.
4 ERR              
 ERR = s

 s  Is the label of an executable statement that is to receive
    control when an error occurs.

 ERR applies only to the OPEN statement in which it is specified,
 and not in subsequent I/O operations on the unit.  If an error
 occurs, no file is opened or created.  However, you can use IOSTAT
 in subsequent I/O statements to perform a similar function.
4 EXTENDSIZE       
 This keyword is only available on VMS systems.
4 FILE             
 FILE = fln

 fln  Is a character scalar reference, numeric scalar memory 
      reference, or numeric array name reference.

 The FILE parameter specifies the name of the file to be connected
 to the unit.  The name can be any file pathname (or file
 specification) accepted by the operating system.  (See the
 appropriate manual in your operating system documentation set.)

 If the file name is stored in a numeric scalar or array, the name
 must consist of ASCII characters terminated by an ASCII null
 character (zero byte).  However, if it is stored in a character
 scalar or array, it must not contain a zero byte.
4 FORM             
 FORM = ft

 ft  Is a character expression with one of the following 
     values:

 'FORMATTED'     Formatted (*DEFAULT FOR SEQUENTIAL ACCESS*)
 'UNFORMATTED'   Unformatted (*DEFAULT FOR DIRECT ACCESS*)
4 INITIALSIZE      
 This keyword is only available on VMS systems.
4 IOSTAT           
 IOSTAT = ios

 ios   Is an integer scalar memory reference.

 If no error exists, ios is defined as zero; if an error exists, ios
 is defined as a positive integer.  IOSTAT applies only to the OPEN
 statement in which it appears and not to subsequent I/O operations
 on the logical unit that is opened.  However, you can use the
 IOSTAT parameter in subsequent I/O statements to perform a similar
 function.
4 KEY              
 This keyword is only available on VMS systems.
4 MAXREC           
 MAXREC = mr

 mr  Is an numeric expression whose value specifies the 
     maximum number of records permitted in a direct access 
     file.  The default is an unlimited number of records.
4 NAME             
 NAME is a nonstandard synonym for FILE.  (See FILE.)
4 NOSPANBLOCKS     
 This keyword is only available on VMS systems.
4 ORGANIZATION     
 ORGANIZATION = org

 org  Is a character expression with one of the following 
      values:

 'SEQUENTIAL'          Records are stored in the order that 
                       they are written. Access mode must be 
                       sequential, append, or direct (fixed-length 
                       records only). (*DEFAULT FOR NEW FILES*)

 'RELATIVE'            Records are stored in numbered positions. 
                       Access mode must be direct or sequential.

 'INDEXED' (VMS only)  Records are stored according to the values 
                       of their keys. Access mode must be indexed 
                       or sequential.

 The default for an existing file is its current organization.
4 READONLY         
 READONLY

 Prohibits write access to the file.  Enables users with read access
 but not write access to access the file.

 The Fortran I/O system's default file access privileges are
 read-write, which can cause run-time I/O errors if the file
 protection does not permit write access.

 If you wish to read a file for which you do not have write access,
 you must specify READONLY.
4 RECL             
 RECL = rl

 rl  Is an numeric expression whose value indicates the length 
     of logical records in a file.

 The value of "rl" does not include space for control information,
 such as for two segment control bytes (if present).  The
 specification is for record data only.

 The value of rl is expressed in units of bytes or longwords,
 depending on the record's format.  Formatted records use byte units
 and unformatted records use "longword" units (which are equal to 4
 bytes).

 The following table lists the maximum Digital UNIX processor values
 that can be specified for rl, based on record format and
 CARRIAGECONTROL value.

 +--------------+-----------------+----------------------+
 | Record Type  | CARRIAGECONTROL | Formatted (bytes)    |
 +--------------+-----------------+----------------------+
 | FIXED        | NONE            | 2147483647 (2**31-1) |
 |              |                 | (Subtract 1 if -vms  |
 |              |                 | is used.)            |
 +--------------+-----------------+----------------------+
 | VARIABLE     | NONE            | 2147483640 (2**31-8) |
 +--------------+-----------------+----------------------+
 | SEGMENTED    | NONE            | 32764 (2**15-4)      |
 +--------------+-----------------+----------------------+
 | STREAM       | NONE            | 2147483647 (2**31-1) |
 +--------------+-----------------+----------------------+
 | STREAM_CR    | LIST            | 2147483647 (2**31-1) |
 |              | FORTRAN         | 2147483647 (2**31-2) |
 +--------------+-----------------+----------------------+
 | STREAM_LF    | LIST            | 2147483647 (2**31-1) |
 |              | FORTRAN         | 2147483646 (2**31-2) |
 +--------------+-----------------+----------------------+

 The following are the RECL default values:

 RECORDTYPE value    RECL value
 ----------------    -----------------------------------------

 'FIXED'             None; value must be explicitly specified.
 All other types     132 bytes (for formatted records)
                     510 longwords (for unformatted records)

 The interpretation and effect of the logical record length varies
 as follows:

  -  If the file contains segmented records, RECL specifies the
     maximum length for any segment (including the two
     segment-control bytes).

  -  If the file contains fixed-length records, RECL specifies the
     size of each record.

  -  If the file contains variable-length records, RECL specifies
     the maximum length for any record.  A fixed-length file with
     unformatted records must have a record size that is an even
     multiple of four.

  -  If your program attempts to write to an existing file a record
     that is longer than the logical record length, an error occurs.

  -  Reading a fixed-length file with a record length different from
     the one used to create the file will produce indeterminate
     results.


 You must specify RECL when you open files with fixed-length
 records.
4 RECORDSIZE       
 RECORDSIZE is the nonstandard synonym for RECL (see RECL).
4 RECORDTYPE       
 RECORDTYPE = typ

 typ  Is a character expression with one of the following 
      values:

 'FIXED'      All records are one size. Short records are padded
              with blanks (formatted files) or zeros (unformatted
              files). 
 'VARIABLE'   Records can vary in length. 
 'SEGMENTED'  A record consists of one or more variable length
              records which may exist in different physical blocks. 
              Valid only for unformatted, sequential files with 
              sequential access. 
 'STREAM'     Data is not grouped into records and contains no
              control information.
 'STREAM_CR'  Variable-length records whose length is indicated by
              carriage-returns embedded in the data.
 'STREAM_LF'  Variable-length records whose length is indicated by
              line-feeds (new lines) embedded in the data.

 When you open a file, default record types are as follows:

 +-------------------------------------+---------------------+
 | File Type                           | Default Record Type |
 +-------------------------------------+---------------------+
 | Direct access sequential files      | 'FIXED'             |
 | Formatted sequential access files   | 'STREAM_LF'         |
 | Unformatted sequential access files | 'VARIABLE'          | 
 | Relative files                      | 'FIXED'             |
 +-------------------------------------+---------------------+

 Within segmented records, a FORTRAN logical record can be greater
 than 65,535 bytes in length.  Only use segmented records for
 unformatted sequential access to disk or raw magnetic tape files.

 In fixed-length record files, if an output statement does not
 specify a full record, the record is filled with spaces in a
 formatted file and zeros in an unformatted file.

 You cannot use an unformatted READ statement to access an
 unformatted sequential organization file containing variable-length
 records, unless you specify the corresponding RECORDTYPE value in
 your OPEN statement.

 Files containing segmented records can be accessed only by
 unformatted sequential Fortran I/O statements.
4 SHARED           
 This keyword is only available on VMS systems.
4 STATUS           
 STATUS = sta

 sta  Is a character expression with one of the following 
      values:

 'OLD'       Open an existing file
 'NEW'       Create a new file; if the file already exists an
             error occurs
 'SCRATCH'   Create a new file and delete it when the file is 
             closed
 'UNKNOWN'   Open the file as OLD; if it does not exist, then 
             open the file as NEW 

 The default is 'UNKNOWN'.  This is also the default value if you
 implicitly open a file using WRITE.  However, if you implicitly
 open a file using READ, the default value is 'OLD'.  If you specify
 the -nof77 compiler option, or OPTIONS /NOF77 the default value is
 'NEW'.

 Scratch files (STATUS='SCRATCH') are created in the user's working
 directory and are visible while they are open.  When they are
 closed, they are deleted.

 NOTE:  The STATUS parameter is also used in CLOSE statements to
 specify the status of a file after the file is closed.  However, in
 CLOSE statements the STATUS values are the same as those listed for
 the DISPOSE keyword (see DISPOSE).
4 TYPE             
 TYPE is a nonstandard synonym for STATUS (see STATUS).
4 UNIT             
 [UNIT=] u

 u  Is a numeric expression that specifies the logical unit to
    which a file is to be connected. 

 The unit specification must appear in the parameter list, unless
 the unit specifier is the first element in the list.

 The logical unit may already be connected to a file when an OPEN
 statement is executed.  If this file is not the same as the one to
 be opened, the OPEN statement executes as if a CLOSE statement had
 executed just before it.

 If the file to be opened is already connected to the unit or if the
 file specifier (FILE keyword) is not included in the OPEN
 statement, only the blank specifier (BLANK keyword) can have a
 value different from the one currently in effect.  The position of
 the file is unaffected.
4 USEROPEN         
 This keyword is only available on VMS systems.
3 OPTIONS                 
 Overrides or confirms the compiler options in effect for a program
 unit.  Statement format:

    OPTIONS option [option...]

    option  Is one of the following:

    /ASSUME=([NO]BACKSLASH, [NO]UNDERSCORE) 
    /NOASSUME

    /CHECK=(ALL, [NO]BOUNDS, [NO]OVERFLOW, [NO]UNDERFLOW, NONE)
    /NOCHECK

    /CONVERT=(BIG_ENDIAN, CRAY, FDX, FGX, IBM, LITTLE_ENDIAN, 
              NATIVE, VAXD, VAXG)

    /[NO]EXTEND_SOURCE
    /[NO]F77
    /[NO]I4
    /[NO]RECURSIVE 

 You must place the slash (/) before the option.

 The OPTIONS statement must be the first statement in a program
 unit, preceding the PROGRAM, SUBROUTINE, FUNCTION, and BLOCK DATA
 statements.

 OPTIONS statement options have the same syntax and abbreviations as
 their similarly-named VMS compiler options.

 OPTIONS statement options override compiler options, but only until
 the end of the program unit for which they are defined.  Thus, an
 OPTIONS statement must appear before each program unit in which you
 wish to override the compiler options.
3 PARAMETER               
 Associates a symbolic name with a constant value.  Statement
 format:

    PARAMETER (p=c [,p=c]...)

    p  Is a symbolic name.  

    c  Is a constant, a compile-time expression, or the 
       symbolic name of a constant.

 The following additional rules apply to symbolic names:

  -  If the symbolic name is used as the length specifier in a
     CHARACTER declaration, it must be enclosed in parentheses.

  -  If the symbolic name is used as a numeric item in a FORMAT edit
     description, it must be enclosed in angle brackets.

  -  The symbolic name of a constant cannot appear as part of
     another constant, although it can appear as either the real or
     imaginary part of a complex constant.

  -  A symbolic name can be defined only once within the same
     program unit.

  -  You can only use a symbolic name defined to be a constant
     within the program unit containing the defining PARAMETER
     statement.


 The data type of a symbolic name associated with a constant is
 determined as follows:

  -  By an explicit type declaration statement preceding the
     defining PARAMETER statement

  -  By the same rules for implicit declarations that determine the
     data type of any other symbolic name

     For example, the following PARAMETER statement is interpreted
     as MU=1 (MU has an integer data type by implication):

        PARAMETER (MU=1.23)

     If the PARAMETER statement is preceded by an appropriate type
     declaration or IMPLICIT statement, it could be interpreted as
     MU=1.23; for example:

        REAL*8 MU
        PARAMETER (MU=1.23)


 Once a symbolic name is associated with a constant, it can appear
 anywhere in a program that any other constant can appear --- except
 in FORMAT statements (where constants can only be used in variable
 format expressions) and as the character count for Hollerith
 constants.  For compilation purposes, writing the name is the same
 as writing the value.

 A compile-time expression can contain the following intrinsic
 subprograms as long as the operands are constants:  ABS, CHAR,
 CMPLX, CONJG, DIM, DPROD, IAND, ICHAR, IEOR, IMAG, IOR, ISHFT, LGE,
 LGT, LLE, LLT, MIN, MAX, MOD, NINT, and NOT.

 For information on an alternate syntax for PARAMETER, see Help
 topic:  Compatibility_Features PARAMETER.
3 PAUSE                   
 The PAUSE statement displays a message on the terminal and
 temporarily suspends program execution, so that you can take some
 action.  Statement format:

    PAUSE [disp]
  
    disp  Is an optional character constant or a string of 
          up to six digits.  (FORTRAN-77 limits digits to five.)

 If you do not specify a value for "disp", the system displays the
 following default message:

    FORTRAN PAUSE

 The system then displays the following prompt:

    PAUSE prompt>

 If you specify a value for "disp", this value is displayed instead
 of the default message.

 EFFECT OF PAUSE IN INTERACTIVE OR FOREGROUND MODE:

 In interactive or foreground mode, the program is suspended until
 you enter a command.

 To resume processing, enter CONTINUE, and execution will resume at
 the next executable statement.  Any other command terminates
 execution.

 EFFECT OF PAUSE IN BACKGROUND PROCESS MODE:

 In background mode, the effect differs depending on stdin (standard
 input), as follows:

  o  If stdin is redirected to a file, the system displays the
     following (after the message and prompt):

        To continue from background, execute 'kill -15 n'

     In this message, "n" is the process id of the program.

  o  If stdin is not redirected to a file, the program becomes a
     suspended background job, and you must specify fg to bring the
     job into the foreground.  You can then enter a command to
     resume or terminate processing.

3 POINTER                 
 The POINTER statement establishes pairs of variables and pointers,
 in which each pointer contains the address of its paired variable.
 Statement format:

    POINTER ((pointer,pointee) [,(pointer,pointee)]...

    pointer  Is a variable whose value is used as the 
             address of the pointee.

    pointee  Is a variable, array, array declarator, record, 
             record array, or record array declarator.

 The following are rules and behavior for the "pointer" argument:

  o  Two pointers can have the same value, so pointer aliasing is
     allowed.

  o  When used directly, a pointer is treated like an integer
     variable.  On Digital UNIX systems, a pointer occupies two
     numeric storage units, so it is a 64-bit quantity (INTEGER*8).

  o  A pointer cannot be a pointee.

  o  A pointer cannot appear in the following statements:

        ASSIGN       INTRINSIC
        EXTERNAL     PARAMETER

     A pointer can appear in a DATA statement with integer literals
     only.

  o  Integers can be converted to pointers, so you can point to
     absolute memory locations.

  o  A pointer variable cannot be declared to have any other data
     type.

  o  A pointer cannot be a function return value.

  o  You can give values to pointers by using the %LOC built-in
     function to retrieve addresses, or by using malloc(3f) (on
     Digital UNIX systems) or LIB$GET_VM (on OpenVMS systems) to
     allocate storage for an object.  For example:

        Using %LOC:                   Using malloc:

        integer i(10)                 integer i(10)
        integer i1 (10) /10*10/       pointer (p,i)
        pointer (p,i)                 p = malloc (40)
        p = %loc (i1)                 i(2) = i(2) + 1
        i(2) = i(2) + 1

  o  The value in a pointer is used as the pointee's base address.


 The following are rules and behavior for the "pointee" argument:

  o  A pointee is not allocated any storage.  References to a
     pointee look to the current contents of its associated pointer
     to find the pointee's base address.

  o  A pointee can appear in only one POINTER statement.

  o  A pointee array can have fixed, adjustable, or assumed
     dimensions.

  o  A pointee cannot appear in the following statements:

        AUTOMATIC       PARAMETER
        COMMON          SAVE
        DATA            STATIC
        EQUIVALENCE     VOLATILE
        NAMELIST

  o  A pointee cannot be a dummy argument.

  o  A pointee cannot be a function return value.

  o  A pointee cannot be a record field or an array element.

3 PRINT                   
 Transfers output data from internal storage to external records
 that are sequentially accessed.
4 Formatted        
 Translates data from binary to character format as specified by f.
 Statement format:

    PRINT f[,iolist]

    f       Is a format specifier not prefaced by FMT=.

    iolist  Are the names of the variables from which the 
            data is transferred, listed in the order of transfer.
4 List-directed    
 Translates data from binary to character format according to the
 data types of the variables in the I/O list.  Statement format:

    PRINT *[,iolist]

    *       Specifies list-directed formatting.

    iolist  Are the names of the variables from which the data 
            is transferred, listed in the order of transfer.
4 Namelist
 Translates data from binary to character format according to the
 data types of the list entities in the corresponding NAMELIST
 statement.  Statement format:

    PRINT n

    n  Is a namelist group name not prefaced by NML=.
3 PROGRAM                 
 Begins a main program.  The PROGRAM statement is optional; when
 used, it can only be preceded by comment lines or an OPTIONS
 statement.  Statement format:

    PROGRAM nam

    nam   Is a symbolic name for the program.  The name must 
          be unique among all global names in the program.  

 If no PROGRAM statement begins the program, the program name
 defaults to filename$MAIN, where filename is the name of the file
 containing the program.
3 READ                    
 Transfers data from external or internal units to internal storage.

 The meanings of the symbolic abbreviations used to represent the
 parameters in the READ statement syntax are as follows:

    extu     Is the logical unit or internal file optionally 
    or       prefaced by UNIT=.  UNIT= is required if unit is 
    intu     not the first element in the clist.

    fmt      Specifies whether formatting is to be used for 
             data editing, and if it is, the format specification 
             or an asterisk (*) to indicate list-directed formatting. 
             The "fmt" is optionally prefaced by FMT=, if "fmt" is 
             the second parameter in the clist and the first parameter
             is a logical or internal unit specifier without the 
             optional keyword UNIT=.

    nml      Is the namelist group specification for namelist I/O. 
             Optionally prefaced by NML=.  NML= is required
             if namelist is not the second I/O specifier.
    
    rec      Is the cell number of a record to be accessed directly.
             Optionally prefaced by REC= or by an apostrophe (').
    
    iostat   Is the name of a variable to contain the completion 
             status of the I/O operation. Optionally prefaced 
             by IOSTAT=.

    err      Is the label of a statement to which control is 
             transferred in the event of an error. Optionally 
             prefaced by ERR=.

    end      Is the label of a statement to which control is 
             transferred in the event of an end-of-file. 
             Optionally prefaced by END=.

    iolist   Are the names of the variables, arrays, array 
             elements, or character substrings from which or 
             to which data will be transferred.  Optionally 
             an implied-DO list.

 The control-list parameters are "extu" (or "intu"), "fmt", "nml",
 "rec", "iostat", "err", and "end".  The I/O list parameter is
 "iolist".
4 Sequential  
5 Formatted         
 Translates the data from character to binary format as specified by
 format specifications.  Statement formats:

 1. READ(extu,fmt[,iostat][,err][,end])[iolist]
    Reads from a specified external unit.

 2. READ f[,iolist]
    Reads from FOR$READ (normally, the terminal).
5 List-directed     
 List-directed sequential READ statement formats:

 1. READ(extu,*[,iostat][,err][,end])[iolist]
    
    Reads from a specified external unit.  
    Translates the data from character to binary 
    format according to the data types of the
    variables in the I/O list.

 2. READ *[,iolist]

    Reads from FOR$READ (normally, the terminal). 
    Translates the data from character to binary 
    format according to the data types of the 
    variables in the I/O list.

 List-directed character input can be delimited by apostrophes or
 quotation marks.
5 Namelist           
 Namelist sequential READ statement formats:

 1. READ(extu,nml[,iostat][,err][,end])
  
    Reads from a specified external unit.  Translates 
    the data from character to binary format according 
    to the data types of the list entities in the 
    corresponding NAMELIST statement.

 2. READ nml

    Reads from FOR$READ (normally, the terminal). 
    Translates the data from character to binary format 
    according to the data types of the entities in the 
    corresponding NAMELIST statement.

 Namelist character input can be delimited by apostrophes or
 quotation marks.
5 Unformatted       
 Unformatted sequential READ statement format:

    READ(extu,[,iostat][,err][,end])[iolist]

 Reads from a specified external unit.  Does not translate the data.
4 Direct      
5 Formatted         
 Formatted direct READ statement format:

    READ(extu,fmt,rec[,iostat][,err])[iolist]

 Reads from a specified external unit.  Translates the data from
 character to binary format as specified by "fmt".
5 Unformatted       
 Unformatted direct READ statement format:

    READ(extu,rec[,iostat][,err])[iolist]

 Reads from a specified external unit.  Does not translate the data.
4 Indexed     
 This statement is only available on VMS systems.
4 Internal          
 Internal READ statement format:

    READ(intu,fmt[,err][,iostat][,end])[iolist]
 Reads from a specified character variable.  Translates the data
 from character to binary format as specified by "fmt".
3 RECORD                  
 Creates a record consisting of the variables and arrays specified
 in a previous structure declaration.  Statement format:

    RECORD /str/rnlist[,/str/rnlist...]

    str     Is the name of a previously declared structure.

    rnlist  Is a list of one or more variable names, array 
            names, or array declarators, separated by commas.
            All of the records named in this list have the 
            same structure and are allocated separately in 
            memory.

 Record variables can be used in COMMON and DIMENSION statements,
 but not in DATA, EQUIVALENCE, or NAMELIST statements.

 Records initially have undefined values unless you have defined
 their values in structure declarations.
3 RETURN                  
 Transfers control from a subprogram to the calling program.  You
 can only use RETURN in a subprogram unit.  Statement format:

    RETURN [i]

    i  Is an optional integer constant or expression (such
       as 2 or I+J) indicating the position of an alternate 
       return from the subprogram in the actual argument list.
       The "i" is converted to an integer value if necessary.      

 The argument "i" is valid only for subroutine subprograms.  If no
 alternate return is specified or the specified alternate return
 does not exist in the actual argument list, control returns to the
 statement following the CALL statement.

 If the subprogram is a function, control returns to the statement
 containing the function reference.  If the subprogram is a
 subroutine, control returns either to the statement following the
 CALL statement, or to the label specified by the alternate return
 argument.
3 REWIND                  
 Repositions a sequential file currently open for sequential or
 append access to the beginning of the file.  Do not use a REWIND
 statement for a file that is open for direct access.  Use this
 statement only for files on disk or magnetic tape.  Statement
 format:

     REWIND ([UNIT=]u[,ERR=s][,IOSTAT=ios])
     REWIND u

     u    Is an integer variable or constant specifying the 
          logical unit number of the file, optionally prefaced 
          by UNIT=.  UNIT= is required if unit is not the first 
          I/O specifier.

     s    Is the label of a statement to which control is 
          transferred if an error occurs, prefaced by ERR=.

     ios  Is an integer variable to which the completion status 
          of the I/O operation is returned, prefaced by IOSTAT=.

 If a REWIND statement is specified for a unit that is not open, it
 has no effect.

 See also BACKSPACE.
3 REWRITE                 
 Transfers data from internal storage and writes the data
 (translated if formatted; untranslated if unformatted) to the
 current record in a file with direct access.

 The current record is the last record accessed by a preceding,
 successful direct access or sequential READ statement.

    Formatted REWRITE statement format:

     REWRITE ([UNIT=]u,[FMT=]f[,ERR=s][,IOSTAT=ios])[iolist]
    
    Translates the data from binary to character format as
    specified by FMT.

    Unformatted REWRITE statement format:

     REWRITE ([UNIT=]u[,ERR=s][,IOSTAT=ios])[iolist]

    Does not translate the binary data.

    Arguments:

    u       Is an integer variable or constant specifying the 
            logical unit number of the file, optionally 
            prefaced by UNIT=.  UNIT= is required if unit is 
            not the first I/O specifier.

    f       Is a format specifier.

    s       Is the label of a statement to which control is 
            transferred if an error condition occurs, prefaced 
            by ERR=.

    ios     Is an integer variable to which the completion 
            status of the I/O operation is returned, prefaced 
            by IOSTAT=.

    iolist  Are the names of the variables from which the data 
            is transferred, listed in the order of transfer.

 Formatted REWRITE Statement Behavior and Errors:

 The formatted REWRITE statement performs the following operations:

  o  It retrieves binary values from internal storage.

  o  It translates those values to character form as specified by
     FORMAT.

  o  It writes the translated data to a current (existing) record in
     a file OPENed with ACCESS='DIRECT'.

     The current record is the last record accessed by a preceding,
     successful direct access, or sequential READ statement.


 Errors occur under the following conditions:

  o  If you attempt to rewrite more than one record in a single
     REWRITE statement operation

  o  If a record is too long (Note that unused space in a rewritten,
     fixed-length record is filled with spaces.)


 In the following example, the REWRITE statement updates the current
 record contained in the relative organization file connected to
 logical unit 3 with the values represented by NAME, AGE, and BIRTH.

          REWRITE (3,10,ERR=99) NAME, AGE, BIRTH
    10    FORMAT (A16,I2,A8)

 Unformatted REWRITE Statement Behavior and Errors:

 The formatted REWRITE statement performs the following operations:

  o  It retrieves binary values from internal storage.

  o  It writes the untranslated data to a current (existing)
     existing record in a file OPENed with ACCESS='DIRECT'.

     The current record is the last record accessed by a preceding,
     successful direct access, or sequential READ statement.


 Errors occur under the following conditions:

  o  If you attempt to rewrite more than one record in a single
     REWRITE statement operation

  o  If a record is too long (Note that unused space in a rewritten,
     fixed-length record is filled with zeros.)

3 SAVE                    
 Declares that the values of data elements are to be saved across
 invocations of a subprogram.  Statement format:

    SAVE [a[,a]...]

    a  Is the symbolic name of a common block (enclosed in 
       slashes), a variable, or an array.  

 A SAVE statement cannot include a blank common block, names of
 entities in a common block, procedure names, and names of dummy
 arguments.

 Within a program unit, an entity listed in a SAVE statement does
 not become undefined upon execution of a RETURN or END statement
 within that program unit.

 Even though a common block can be included in a SAVE statement,
 individual entities within the common block could become undefined
 (or redefined) in another program unit.

 When a SAVE statement does not explicitly contain a list, it is
 treated as though all allowable items in the program unit are
 specified on the list.

 NOTE:  In Digital Fortran 77, the definitions of COMMON variables,
 and local variables of non-recursive subprograms (other than
 variables declared AUTOMATIC), are saved by default.  To enhance
 portability and avoid possible compiler warning messages, Digital
 recommends that you use the SAVE statement to name variables whose
 values you want to preserve between subprogram invocations.
3 Statement_Function      
 Defines a function consisting of a single expression.  The function
 must be invoked from the program unit in which it is defined.
 Format:

    fun([p [,p]...])=e

    fun  Is the symbolic name for the function. You can 
         establish its type explicitly or implicitly. The 
         value of the expression is returned to the function 
         name when the function is invoked.

    p    Is an unsubscripted variable name specifying a 
         dummy argument.  The arguments must agree in order, 
         number, and type with the actual arguments of the 
         statement invoking the function.  

    e    Is an arithmetic, logical, or character expression.  
         If the expression contains a reference to another 
         statement function, the referenced statement 
         function must precede the statement function 
         containing the reference.

 Declarator information does not apply to a dummy argument except
 for type.  For example, you cannot define a dummy argument as an
 array or as part of a common block.

 If you use the name of a dummy argument outside the function
 statement, the name defines another separate data entity.
3 STOP                    
 Terminates program execution.  Statement format:

    STOP [disp]

    disp  Is a character constant or a string of up to
          six digits.  (FORTRAN-77 limits digits to five.)

 If you specify the optional argument "disp", the STOP statement
 displays the contents of "disp" at your terminal, terminates
 program execution, and returns control to the operating system.

 If you do not specify a value for "disp", no message is displayed.
3 STRUCTURE               
 Indicates the beginning of the record structure declaration and
 defines the name of the structure.  Declaration format:

    STRUCTURE [/str/][fnlist]
               fdcl
              [fdcl]
              ...
              [fdcl]
    END STRUCTURE

    str     Identifies a structure name, which is used in 
            subsequent RECORD statements to refer to the 
            structure. A structure name is enclosed in slashes.

    fnlist  Identifies field names when used in a substructure 
            declaration.(Only allowed in nested structure
            declarations.)

    fdcl    (Also called the declaration body.)  Is any 
            declaration or combination of declarations of 
            substructures, unions, or typed data, or
            PARAMETER statements.

 Subsequent RECORD statements use the structure name to refer to the
 structure.  A structure name must be unique among structure names,
 but structures can share names with variables (scalar or array),
 record fields, PARAMETER constants, and common blocks.

 Structure declarations can be nested (contain one or more other
 structure declarations).  A structure name is required for the
 structured declaration at the outermost level of nesting, and
 optional for the other declarations nested in it.  However, if you
 wish to reference a nested structure in a RECORD statement in your
 program, it must have a name.

 Structure, field, and record names are all local to the defining
 program unit.  When records are passed as arguments, the fields
 must match in type, order, and dimension.

 Unlike type declaration statements, structure declarations do not
 create variables.  Structured variables (records) are created when
 you use a RECORD statement containing the name of a previously
 declared structure.  The RECORD statement can be considered as a
 kind of type declaration statement.  The difference is that
 aggregate items, not single items, are being defined.

 Within a structure declaration, the ordering of both the statements
 and the field names within the statements is important because this
 ordering determines the order of the fields in records.

 In a structure declaration, each field offset is the sum of the
 lengths of the previous fields.  The length of the structure,
 therefore, is the sum of the lengths of its fields.  The structure
 is packed; you must explicitly provide any alignment that is needed
 by including, for example, unnamed fields of the appropriate
 length.

 By default, fields are aligned on natural boundaries; misaligned
 fields are padded as necessary.  To avoid padding of records, you
 should lay out structures so that all fields are naturally aligned.

 To pack fields on arbitrary byte boundaries, you must specify a
 compiler option.  You can also specify alignment for fields by
 using the cDEC$ OPTIONS general directive.

 In the following example, the declaration defines a structure named
 DATE.  This structure contains three scalar fields:  DAY
 (LOGICAL*1), MONTH (LOGICAL*1), and YEAR (INTEGER*2).

    STRUCTURE /DATE/
        LOGICAL*1  DAY, MONTH
        INTEGER*2  YEAR
    END STRUCTURE
4 Type_declarations
 The syntax of a type declaration within a record structure is
 identical to that of a normal Fortran type declaration statement:
 it includes a data type (for example, INTEGER), one or more names
 of variables or arrays; and optionally, one or more data
 initialization values.

 The following rules and behavior apply to type declarations in
 record structures:

  o  %FILL can be specified in place of a field name to leave space
     in a record for purposes such as alignment.  This creates an
     unnamed field.

     %FILL can have an array declarator; for example:

        INTEGER %FILL (2,2)

     Unnamed fields cannot be initialized.  For example, the
     following statement is invalid and generates an error message:

        INTEGER*4 %FILL /1980/

  o  Initial values can be supplied in field declaration statements.
     These initial values are supplied for all records that are
     declared using this structure.  Fields not initialized will
     have undefined values when variables are declared by means of
     RECORD statements.  Unnamed fields cannot be initialized; they
     are always undefined.

  o  Field names must always be given explicit data types.  The
     IMPLICIT statement has no effect on statements within a
     structure declaration.

  o  All Fortran data types are allowed in field declarations.

  o  Any required array dimensions must be specified in the field
     declaration statements.  DIMENSION statements cannot be used to
     define field names.

  o  Adjustable or assumed sized arrays and passed-length CHARACTER
     declarations are not allowed in field declarations.

  o  Field names within the same declaration level must be unique,
     but an inner structure declaration (substructure declaration)
     can include field names used in an outer structure declaration
     without conflict.

4 Substructure_declarations
 A field within a structure can itself be a structured item composed
 of other fields, other structures, or both.  You can declare a
 substructure in two ways:

  o  By nesting structure declarations within other structure or
     union declarations (with the limitation that you cannot refer
     to a structure inside itself at any level of nesting).

     One or more field names must be defined in the STRUCTURE
     statement for the substructure because all fields in a
     structure must be named.  In this case, the substructure is
     being used as a field within a structure or union.

     Field names within the same declaration nesting level must be
     unique, but an inner structure declaration can include field
     names used in an outer structure declaration without conflict.

     %FILL can be specified in place of a field name to leave space
     in a record for purposes such as alignment.

  o  By using a RECORD statement that specifies another previously
     defined record structure, thereby including it in the structure
     being declared.

4 Union_declarations
 A union declaration is a multistatement declaration defining a data
 area that can be shared intermittently during program execution by
 one or more fields or groups of fields.  A union declaration must
 be within a structure declaration.  A union declaration is
 initiated by a UNION statement and terminated by an END UNION
 statement.  Enclosed within these statements are two or more map
 declarations, initiated and terminated by MAP and END MAP
 statements.  Each unique field or group of fields is defined by a
 separate map declaration.

 A union declaration takes the following form:

    UNION
         mdcl
        [mdcl]
        ...
        [mdcl]
    END UNION

    Where "mdcl" represents:

    MAP
       fdcl
      [fdcl]
      ...
      [fdcl]
    END MAP

    fdcl  Is any declaration or combination of declarations 
          of substructures, unions, or type declarations.

 As with normal Fortran type declarations, data can be initialized
 in field declaration statements in union declarations.  However, if
 fields within multiple map declarations in a single union are
 initialized, the data declarations are initialized in the order in
 which the statements appear.  As a result, only the final
 initialization takes effect and all of the preceding
 initializations are overwritten.

 The size of the shared area established for a union declaration is
 the size of the largest map defined for that union.  The size of a
 map is the sum of the sizes of the fields declared within it.

 As the variables or arrays declared in map fields in a union
 declaration are assigned values during program execution, the
 values are established in a record in the field shared with other
 map fields in the union.  The fields of only one of the map
 declarations are defined within a union at any given point in the
 execution of a program.  However, if you overlay one variable with
 another smaller variable, that portion of the initial variable is
 retained that is not overlaid.  Depending on the application, the
 retained portion of an overlaid variable may or may not contain
 meaningful data and can be utilized at a later point in the
 program.

 Manipulating data using union declarations is similar to the effect
 of using EQUIVALENCE statements.  The difference is that data
 entities specified within EQUIVALENCE statements are concurrently
 associated with a common storage location and the data residing
 there; with union declarations you can use one discrete storage
 location to alternately contain a variety of fields (arrays or
 variables).

 With union declarations, only one map declaration within a union
 declaration can be associated at any point in time with the storage
 location that they share.  Whenever a field within another map
 declaration in the same union declaration is referenced in your
 program, the fields in the prior map declaration become undefined
 and are succeeded by the fields in the map declaration containing
 the newly referenced field.

 In the following example, the structure WORDS_LONG is defined.
 This structure contains a union declaration defining two map
 fields.  The first map field consists of three INTEGER*2 variables
 (WORD_0, WORD_1, and WORD_2), and the second, an INTEGER*4
 variable, LONG:

    STRUCTURE /WORDS_LONG/
        UNION
            MAP
             INTEGER*2    WORD_0, WORD_1, WORD_2
            END MAP
            MAP
             INTEGER*4    LONG
            END MAP
        END UNION
    END STRUCTURE
4 PARAMETER_Statements
 PARAMETER statements:  PARAMETER statements can appear in a
 structure declaration, but cannot be given a data type within the
 declaration block.  Consider the following:

    STRUCTURE /ABC/
        INTEGER*4 P
        PARAMETER (P=4)
        REAL*4 F
    END STRUCTURE
        REAL*4 A(P)

 In this example, the INTEGER*4 statement does not provide the data
 type for PARAMETER constant P, but instead declares a record field
 P in structure ABC.  The subsequent PARAMETER statement declares a
 new, different symbol which is given the implicit data type for
 identifiers beginning with the letter P.

 Type declarations for PARAMETER symbolic names must precede the
 PARAMETER statement and be outside of a STRUCTURE declaration, as
 follows:

        INTEGER*4 P
    STRUCTURE /ABC/
        PARAMETER (P=4)
        REAL*4 F
    END STRUCTURE
        REAL*4 A(P)

 For more information on PARAMETER statements, see STATEMENTS
 PARAMETER in this Help file.
3 SUBROUTINE              
 Begins a subroutine subprogram and names the dummy arguments.  The
 CALL statement transfers control to a subroutine subprogram; a
 RETURN or END statement returns control to the calling program
 unit.  Statement format:

    SUBROUTINE nam [([p[,p]...])]

    nam  Is a symbolic name for the subroutine.  The name must 
         be unique among all global names in the program.

    p    Is an unsubscripted variable name specifying a dummy argument.  
         An asterisk (*) as a dummy argument specifies that the 
         actual argument is an alternate return argument.  

 The arguments must agree in order, number, and type with the actual
 arguments of the statement invoking the subroutine.  A dummy
 argument must not be defined as an array with more elements than
 the actual argument holds.  When control transfers to the
 subroutine, the values of any actual arguments in the CALL
 statement are associated with any corresponding dummy arguments in
 the SUBROUTINE statement.  The statements in the subprogram are
 then executed.

 The SUBROUTINE statement must be the first statement of a
 subroutine, unless an OPTIONS statement is specified.

 A subroutine subprogram cannot contain a FUNCTION statement, a
 BLOCK DATA statement, a PROGRAM statement, or another SUBROUTINE
 statement.

 ENTRY statements are allowed to specify multiple entry points in
 the subroutine.

 The array declarator for a dummy argument can itself contain
 integer values that are dummy arguments or are references to a
 common block, providing for adjustable size arrays in subroutines.
 The upper bound of the array declarator for a dummy argument can be
 specified as an asterisk, in which case the upper bound of the
 dummy argument assumes the size of the upper bound of the actual
 argument.  The size in a character string declarator for a dummy
 argument can be specified as an asterisk in parentheses, in which
 case the size of the actual argument is passed to the dummy
 argument.

 The values of the actual arguments in the invoking program unit
 become the values of the dummy arguments in the function.  If you
 modify a dummy argument, the corresponding actual argument in the
 invoking program unit is also modified; the actual argument must be
 a variable if it is to be modified.

 If the actual argument is a character constant, the dummy argument
 can be either character or numeric in type, unless the name of the
 subprogram being invoked is a dummy argument in the invoking
 program unit.  If the actual argument is a Hollerith constant, the
 dummy argument must be numeric.
3 TYPE                    
 Transfers output data from internal storage to external records
 that are sequentially accessed.
4 Formatted        
 Translates data from binary to character format as specified by the
 format specifications.  Statement format:

    TYPE f[,iolist]

    f       Is a format specifier not prefaced by FMT=.

    iolist  Are the names of the variables from which the 
            data is transferred, listed in the order of transfer.
4 List-directed    
 Translates data from binary to character format according to the
 data types of the variables in the I/O list.  Statement format:

    TYPE *[,iolist]

    *       Specifies list-directed formatting.

    iolist  Are the names of the variables from which the data 
            is transferred, listed in the order of transfer.
4 Namelist
 Translates data from binary to character format according to the
 data types of the list entities in the corresponding NAMELIST
 statement.  Statement format:

    TYPE n

    n  Is a namelist group name not prefaced by NML=.
3 Type_declaration        
 Explicitly specifies the data type of symbolic names.

 Type declarations must precede all executable statements, can be
 declared only once, and cannot be used to change the type of a
 symbolic name that has already been implicitly assumed to be
 another type.

 Type declaration statements can initialize data in the same way as
 the DATA statement:  by having values, bounded by slashes, listed
 immediately after the symbolic name of the entity.
4 Numeric     
 Statement format:

    type[*n] v [*n][/clist/][,v [*n][/clist/]]...

    type   Is any of the following data type specifiers:

           BYTE (equivalent to INTEGER*1)  DOUBLE PRECISION
           LOGICAL                         COMPLEX
           INTEGER                         DOUBLE COMPLEX
           REAL

    n      Is an integer that specifies (in bytes) the length 
           of "v".  It overrides the length that is implied by 
           the data type.

           The value of n must specify an acceptable length 
           for the type of "v" (see the DEC Fortran 
           Language Reference Manual). BYTE, DOUBLE 
           PRECISION, and DOUBLE COMPLEX data types have 
           one acceptable length; thus, for these data types, 
           the "n" specifier is invalid. 

           If an array declarator is used, the "n" specifier 
           must be positioned immediately after the array name.

    v      Is the symbolic name of a constant, variable, 
           array, statement function or function 
           subprogram, or array declarator.

    clist  Is a list of constants, as in a DATA statement.  If 
           "v" is the symbolic name of a constant, the "clist" 
           cannot be present.

 A numeric data type declaration statement can define arrays by
 including array declarators in the list.

 A numeric type declaration statement can assign initial values to
 variables or arrays if it specifies a list of constants (the
 "clist").  The specified constants initialize only the variable or
 array that immediately precedes them.  The "clist" cannot have more
 than one element unless it initializes an array.  When the "clist"
 initializes an array, it must contain a value for every element in
 the array.
4 Character   
 Format:

    CHARACTER[*len[,] v[*len] [/clist/] [,v[*len] [/clist/]]...

    len    Is an unsigned integer constant, an integer constant 
           expression enclosed in parentheses, or an asterisk (*)
           enclosed in parentheses.  The value of "len" specifies 
           the length of the character data elements.

    v      Is the symbolic name of a constant, variable, array, 
           statement function or function subprogram, or array 
           declarator.  The name can optionally be followed by 
           a data type length specifier (*len or *(*)).

    clist  Is a list of constants, as in a DATA statement.  If
           "v" is the symbolic name of a constant, "clist" must 
           not be present.

 If you use CHARACTER*len, "len" is the default length specification
 for that list.  If an item in that list does not have a length
 specification, the item's length is "len".  However, if an item
 does have a length specification, it overrides the default length
 specified in CHARACTER*len.

 When an asterisk length specification *(*) is used for a function
 name or dummy argument, it assumes the length of the corresponding
 function reference or actual argument.  Similarly, when an asterisk
 length specification is used for the symbolic name of a constant,
 the name assumes the length of the actual constant it represents.
 For example, STRING assumes a 9-byte length in the following
 statements:

    CHARACTER*(*) STRING
    PARAMETER (STRING = 'VALUE IS:')

 The length specification must range from 1 to 2**31-1.  If no
 length is specified, a length of 1 is assumed.

 Character type declaration statements can define arrays if they
 include array declarators in their list.  The array declarator goes
 first if both an array declarator and a length are specified.

 A character type declaration statement can assign initial values to
 variables or arrays if it specifies a list of constants (the
 clist).  The specified constants initialize only the variable or
 array that immediately precedes them.  The "clist" cannot have more
 than one element unless it initializes an array.  When the "clist"
 initializes an array, it must contain a value for every element in
 the array.
3 UNION                   
 See Help topic:  (statements) STRUCTURE (subheads Type_declarations
 and Union_declarations).
3 UNLOCK                  
 Frees the current record (that is, the last record read) in an
 indexed (VMS only), relative, or sequential file.  By default, a
 record is locked when it is read.  The lock is normally held until
 your program performs another I/O operation on the unit (for
 example, rewriting the record, reading another record, or closing
 the file).

 Statement format:

    UNLOCK ([UNIT=]u[,ERR=s][,IOSTAT=ios])
    UNLOCK u

    u    An integer variable or constant specifying the 
         logical unit number of the file, optionally 
         prefaced by UNIT=.  UNIT= is required if unit is
         not the first I/O specifier.

    s    The label of a statement to which control is 
         transferred if an error condition occurs.

    ios  An integer scalar memory reference that is 
         defined as a positive integer if an error occurs 
         and zero if no error occurs.
3 VOLATILE                
 Prevents specified variables, arrays, and common blocks from being
 optimized during compilation.  Statement format:

    VOLATILE nlist

    nlist  Is a list of one or more names of variables, arrays, 
           or common blocks (enclosed in slashes), separated 
           by commas.

 If array names or common block names are used, the entire array or
 common block becomes volatile.
3 WRITE                   
 Transfers data from internal storage to user-specified external
 logical units (such as disks, printers, terminals, and pipes) or
 internal files.

 The meanings of the symbolic abbreviations used to represent the
 parameters in the WRITE statement syntax are as follows:

    extu    Is the logical unit or internal file optionally 
    or      prefaced by UNIT=.  UNIT= is required if unit is
    intu    not the first element in the clist.

    fmt     Specifies whether formatting is to be used for data 
            editing, and if it is, the format specification or an 
            asterisk (*) to indicate list-directed formatting. 
            The "fmt" is optionally prefaced by FMT=, if "fmt"
            is the second parameter in the clist and the first 
            parameter is a logical or internal unit specifier 
            without the optional keyword UNIT=.

    nml     Is the namelist group specification for namelist I/O. 
            Optionally prefaced by NML=.  NML= is required if 
            namelist is not the second I/O specifier.

    rec     Is the cell number of a record to be accessed directly.
            Optionally prefaced by REC= or by an apostrophe (').

    iostat  Is the name of a variable to contain the completion 
            status of the I/O operation. Prefaced by IOSTAT=.

    err     Is the label of a statement to which control is 
            transferred in the event of an error. Prefaced by 
            ERR=.

    end     Is the label of a statement to which control is 
            transferred in the event of an end of file. Prefaced 
            by END=.

    iolist  Are the names of the variables, arrays, array elements, 
            or character substrings from which or to which data 
            will be transferred.  Optionally an implied-DO list.
 .b
 The control-list parameters are "extu" (or "intu"), "fmt", "nml",
 "rec", "iostat", "err", and "end".  The I/O list 
 parameter is "iolist".
4 Sequential  
5 Formatted         
 Formatted sequential WRITE statement format:

    WRITE (extu,fmt[,err][,iostat])[iolist]

 Writes to a specified external unit.  Translates the data from
 binary to character format as specified by "fmt".
5 List-directed     
 List-directed sequential WRITE statement format:

    WRITE (extu,*[,iostat][,err])[iolist]

 Writes to a specified external unit.  Translates the data from
 binary to character format according to the data types of the
 variables in the I/O list.
5 Namelist          
 Namelist sequential WRITE statement format:

    WRITE (extu,nml[,iostat][,err])

 Writes to a specified external unit.  Translates the data from
 binary to character format according to the data types of the list
 entities in the corresponding NAMELIST statement.
5 Unformatted       
 Unformatted sequential WRITE statement format:

    WRITE (extu[,iostat][,err])[iolist]

 Writes to a specified external unit.  Does not translate the data.
4 Direct      
5 Formatted         
 Formatted direct WRITE statement format:

    WRITE (extu,rec,fmt[,iostat][,err])[iolist]

 Writes to a specified external unit.  Translates the data from
 binary to character format as specified by "fmt".
5 Unformatted       
 Unformatted direct WRITE statement format:

   WRITE (extu,rec[,iostat][,err])[iolist]

 Writes to a specified external unit.  Does not translate the data.
4 Internal    
 Internal WRITE statement format:

    WRITE (intu[,fmt][,err][,iostat])[iolist]

 Writes to a specified character variable.  Translates the data from
 binary to character format as specified by "fmt".
4 Indexed     
 This statement is only available on VMS systems.
2 Glossary                
 This glossary contains terms that are commonly used in the DEC
 Fortran Language Reference Manual and user manual.  The terms and
 short descriptions are informative and are not part of the standard
 definition of the Fortran programming language.
3 3f_library_routines       
 3f library routines (U*X)

 Digital Fortran 77 library routines (in reference page section 3f)
 that handle the various differences between Digital Fortran 77 and
 C in argument passing and data types.  Some 3f routines are
 language interface routines that make appropriate system calls or
 call library routines.  You can call these routines from Digital
 Fortran 77 programs.  For a list of 3f routines, see the intro(3f)
 reference page.
3 absolute_pathname          
 absolute pathname (U*X)

 A directory path specified in fixed relationship to the root
 directory; the first character is a slash (/).
3 actual_argument            
 actual argument

 A value passed from a calling program unit to a subprogram.
3 aggregate_reference        
 aggregate reference

 A reference to a record field that resolves into a reference to a
 structured data item (a record structure or substructure).
3 alphabetic_character       
 alphabetic character

 A letter of the alphabet (uppercase A through Z and lowercase a
 through z).
3 alphanumeric                
 Pertaining to letters, digits and other special characters, such as
 punctuation marks and mathematical symbols (for example, plus and
 minus signs).
3 alternate_key              
 alternate key (VMS)

 An optional key within the data records in an indexed file, which
 can be used to build an alternate index.
3 ANSI                        
 The American National Standards Institute.  An organization through
 which accredited organizations create and maintain voluntary
 industry standards.
3 argument                    
 A variable (parameter) passed between a calling routine and a
 called routine.  See also actual_argument and dummy_argument.
3 arithmetic_expression      
 arithmetic expression

 A numeric constant, variable, or function value, or combination of
 these, joined by arithmetic operators and parentheses, so that the
 entire expression can be evaluated to produce a single numeric
 value.  For example, -L or X+(Y-4.5)*Z.
3 arithmetic_operator        
 arithmetic operator

 A symbol designating an arithmetic operation.  In Fortran, the
 symbols +, -, *, /, and ** are used to designate addition,
 subtraction, multiplication, division, and exponentiation,
 respectively.
3 array                       
 A group of components, called elements, that all have the same data
 type and share a common symbolic name.  Components of an array are
 specified individually with subscripts.  See also array element.
3 array_declaration          
 array declaration

 A program statement specifying an array name, the number of
 dimensions it contains, and its dimension bounds.  An array
 declaration can appear in a DIMENSION, COMMON, or explicit type
 statement.  See also array_name.
3 array_element              
 array element

 An item in an array, identified by the array name followed by one
 or more subscripts in parentheses, indicating the element's
 position in the array.  For example, B(3) or A(2,5).
3 array_name                 
 array name

 The symbolic name associated with an array.
3 array_name_reference      
 array name reference

 A reference to a record field that resolves into a reference to an
 array.  See also array.
3 ASCII                       
 The American Standard Code for Information Interchange.  A 7-bit
 character encoding scheme associating an integer from 0 through 127
 with 128 characters.  See also multinational_character_set.
3 assignment_statement       
 assignment statement

 A statement that assigns (stores) the value of an expression on the
 right of an equal sign to the storage location of the variable to
 the left of the equal sign.
3 assumed-size_array         
 assumed-size array

 A dummy array whose size is assumed from the associated actual
 argument.  The upper bound of its last dimension is specified by an
 asterisk (*).
3 background_process         
 background process (U*X)

 A process for which the command interpreter is not waiting.  Its
 process group differs from that of its controlling terminal, so it
 is blocked from most terminal access.  Contrast with
 foreground_process.
3 batch_process              
 batch process (VMS)

 A process that runs without user interaction.  Contrast with
 interactive_process.
3 big_endian                 
 big endian

 A method of data storage in which the least significant bit of a
 numeric value spanning multiple bytes is in the "highest" addressed
 byte.  Contrast with little_endian.
3 binary_constant            
 binary constant

 A constant that is a string of binary digits (0 or 1) enclosed by
 apostrophes and preceded or followed by the letter B.
3 binary_operator            
 binary operator

 An operator that acts on a pair of operands.  The exponentiation,
 multiplication, division, and concatenation operators are binary
 operators.
3 bit_constant               
 bit constant

 A constant that is an octal or hexadecimal number.  In Digital
 Fortran 77, it can also be a binary number.
3 bit_field                  
 bit field

 A contiguous group of bits within a binary pattern; they are
 specified by a starting bit position and length.  The functions
 IBSET, IBCLR, BTEST, and IBITS, and the subroutine MVBITS operate
 on bit fields.
3 blank_common_block        
 blank common block

 A common block (one or more contiguous areas of storage) without a
 name.  Common blocks are defined by a COMMON statement.
3 block                       
 In general, a group of related items treated as a physical unit.
 For example, a block can be a sequence of program statements that
 perform a specific function, or a set of records accessed as a
 single unit.
3 block_data_subprogram     
 block data subprogram

 A program unit, containing a BLOCK DATA statement and its
 associated specification statements, that establishes common blocks
 and assigns initial values to the variables in named common blocks.
3 bottleneck                  
 The slowest process in an executing program.  This process
 determines the maximum speed of execution.
3 bounds                      
 See dimension_bounds.
3 breakpoint                  
 A critical point in a program, during which execution is stopped so
 that you can see if the program variables contain the correct
 values.  Breakpoints are often used to debug programs.
3 built-in_function          
 built-in function

 See intrinsic_function.
3 carriage-control_character 
 carriage-control character

 A character in the first position of a printed record that
 determines the vertical spacing of the output line.
3 character_constant         
 character constant

 A constant that is a string of printable ASCII characters enclosed
 by apostrophes (').  In Digital Fortran 77, the string can
 alternatively be enclosed by quotation marks (").
3 character_expression       
 character expression

 A character constant, variable, function value, or another constant
 expression, separated by a concatenation operator (//); for
 example, DAY//' FIRST'.
3 character_string           
 character string

 A sequence of contiguous characters; a character data value.  See
 also character_constant.
3 character_substring        
 character substring

 One or more contiguous characters in a character string.
3 character_storage_unit    
 character storage unit

 The amount of storage needed to represent one scalar character
 value.  In Digital Fortran 77, one character storage unit is
 equivalent to one byte of memory.
3 character_type             
 character type

 A data type consisting of alphanumeric characters.  See also
 data_type.
3 comment                     
 Text that documents or explains a program, and begins with a letter
 C (or c) or an asterisk (*) in column 1 of a source line.  Note
 that the letter C can also denote a compiler directive.  A comment
 can also begin with an exclamation point (!), which can appear
 anywhere in a source line -- except in a Hollerith or character
 constant, in column 6 of a fixed-format line, or inside a
 placeholder (using the DESIGN compiler option on VMS on VAX).  The
 comment extends from the exclamation point to the end of the line.
 The Fortran compiler does not process comments, but shows them in
 program listings.  See also compiler_directive.
3 common_block               
 common block

 A storage area (area in memory) shared by one or more program
 units.  This storage area is defined by a COMMON statement.  If the
 common block is given a name, it is a named common block; if it is
 not given a name, it is a blank common block.  See also
 blank_common_block.
3 compiler_directive         
 compiler directive

 A statement that tells the compiler to perform certain tasks when
 it compiles a source program unit.  The tag CDEC$ (and CPAR$ in VMS
 on VAX) must appear in columns 1 through 5.
3 complex_constant           
 complex constant

 A constant that is a pair of real or integer constants representing
 a complex number; the pair is separated by a comma and enclosed in
 parentheses.  The first constant represents the real part of the
 number; the second constant represents the imaginary part.  In
 Digital Fortran 77, there are two types of complex constants:
 COMPLEX (COMPLEX*8) and DOUBLE COMPLEX (COMPLEX*16).
3 complex_type               
 complex type

 A data type that represents the values of complex numbers.  The
 value is expressed as a complex constant.  See also data_type.
3 concatenate                 
 The combination of two items into one by placing one of the items
 after the other.  In Fortran, the concatenation operator (//) is
 used to combine character items.  See also character_expression.
3 conservative_automatic_inlining
 conservative automatic inlining

 The inline expansion of small procedures, with conservative
 heuristics to limit extra code.
3 constant                    
 A data item with a fixed value that does not change during the
 execution of a program.  The value of a constant can be numeric or
 logical, or it can be a character string.  Contrast with variable.
3 contiguous                  
 Pertaining to entities that are adjacent (next to one another)
 without intervening spaces:  for example, contiguous characters or
 contiguous areas of storage.
3 control_statement          
 control statement

 A statement that alters the normal order of execution by
 transferring control to another section of a program unit or a
 subprogram.  A control statement can be conditional (such as the IF
 or computed GO TO statement) or unconditional (such as the STOP or
 GO TO statement).
3 critical_region            
 critical region

 A section of code (such as parallel DO-loops) that must execute
 serially (sequentially) to achieve correct results.
3 data_item                  
 data item

 A unit of data (or value) to be processed.  Includes constants,
 variables, arrays, character substrings, or records.
3 data_type                  
 data type

 The properties and internal representation that characterize data
 and functions.  The basic data types are integer, real, complex,
 logical, and character.
3 data_type_declaration     
 data type declaration

 See type_declaration_statement.
3 data_type_length_specifier
 data type length specifier

 The form *n appended to a data type name.  For example, the *4 in
 REAL*4.
3 denormalized_number        
 denormalized number

 A computational floating-point result smaller than the lowest value
 in the normal range of a data type (the smallest representable
 normalized number) that gradually underflows and loses precision
 until it reaches the smallest representable subnormal value (.GT.
 or .EQ.  0) for that data type.  You cannot write a constant for a
 denormalized number.
3 dimension                   
 A range of values for one subscript or index of an array.  An array
 can have from 1 to 7 dimensions.
3 dimension_bounds           
 dimension bounds

 For a named array, the limits within which the values of the
 subscripts of its array elements must lie.  These bounds are
 specified in an array declaration.  See also array_declaration.
3 direct_access              
 direct access

 A method for retrieving or storing data in which the data (record)
 is identified by the record number, or the position of the record
 in the file.  The record is accessed directly (nonsequentially);
 therefore, all information is equally accessible.  Also called
 random access.  Contrast with sequential_access.
3 double-precision_constant  
 double-precision constant

 A processor approximation to the value of a real number that
 occupies 8 bytes of memory and can assume a positive, negative, or
 zero value.  The precision is greater than a constant of real
 (single-precision) type.  For information on ranges for these
 numbers, see your language reference manual.  See also
 denormalized_number.
3 driver_program             
 driver program (U*X)

 A U*X program that is the user interface to the language compiler.
 It accepts command options and file names and causes one or more
 language utilities or system programs to process each file.
3 dummy_aliasing             
 dummy aliasing

 The sharing of memory locations between dummy (formal) arguments
 and other dummy arguments or COMMON variables that are assigned.
3 dummy_argument             
 dummy argument

 A variable name used in a function or subroutine which accepts the
 calling program unit's actual argument value.  Dummy arguments are
 defined in FUNCTION statements, SUBROUTINE statements, and
 statement function definitions.
3 edit_descriptor            
 edit descriptor

 A nonrepeatable format descriptor that directly displays text or
 affects the conversions performed by subsequent field descriptors.
3 element                     
 See array_element.
3 end-of-file                 
 The condition that exists when all records in a file open for
 sequential access have been read.
3 error_number               
 error number

 A small integer value denoting an I/O error condition, obtained by
 using the IOSTAT= keyword in an I/O statement.
3 executable_statement       
 executable statement

 A Fortran statement that specifies an action to be performed.
3 expression                  
 A scalar field reference, a function reference, or a combination of
 these, joined by operators so that the expression can be reduced to
 a single value.  An expression can have any of the Fortran data
 types.
3 extension                   
 See language_extension.
3 external_file              
 external file

 A sequence of records that exists in a medium external to the
 executing program.
3 external_routine           
 external routine

 A procedure or function called from outside the program in which
 the program is defined.  Also called an external subprogram.
3 field                       
 (1) A set of contiguous characters, considered as a single item, in
 a record or line.  (2) A substructure of a STRUCTURE declaration.
3 field_descriptor           
 field descriptor

 A repeatable format descriptor that causes the transfer or
 conversion of data to or from its internal representation.
3 field_separator            
 field separator

 The comma (,) or slash (/) that separates edit descriptors or field
 descriptors in a format specification.
3 field_width                
 field width

 The size in characters of the field.  See also field, definition 1.
3 file                        
 A collection of logically related records.  If the file is in
 internal storage, it is an internal file; if the file is on an
 input/output device, it is an external file.
3 file_access                
 file access

 The way records are accessed (and stored) in a file.  The Fortran
 file access modes are sequential and direct.  On VMS systems on VAX
 processors, you can also specify the keyed mode of access.
3 file_organization          
 file organization

 The way records in a file are physically arranged on a storage
 device.  Fortran files can have sequential or relative
 organization.  ON VMS systems on VAX processors, files can also
 have indexed organization.
3 fixed-length_record_type  
 fixed-length record type

 A file format in which all the records are the same length.
3 fixed-point                 
 Pertaining to a type of computation with real numbers in which the
 decimal point separating whole numbers and fractions is located in
 a single, unchanging (fixed) position.  For example, 99.9 is a
 fixed-point real number.  Contrast with floating-point.
3 floating-point              
 Pertaining to a type of computation (or data type) with real or
 complex numbers expressed in scientific notation.  In this
 notation, a number is expressed as a factor multiplied by an
 appropriate power of 10.  The decimal point "floats" to store the
 maximum number of significant digits.  For example, 864.5 can be
 expressed as 0.8645 * 10**3 (or 0.8645E3).  Contrast with
 fixed-point.  See also denormalized_number.
3 foreground_process         
 foreground process (U*X)

 A process for which the command interpreter is waiting.  Its
 process group is the same as that of its controlling terminal, so
 the process is allowed to read from or write to the terminal.
 Contrast with background_process.
3 foreign_file               
 foreign file

 An unformatted file which contains data from a foreign platform,
 such as data from a CRAY, IBM, or big endian IEEE machine.
3 format                      
 A specific arrangement of data.  A FORMAT statement specifies how
 data is to be read or written.
3 formatted_data             
 formatted data

 Data written to a file by using formatted I/O statements.  Such
 data contains ASCII representations of binary number values.
3 formatted_I/O_statement   
 formatted I/O statement

 A statement that contains explicit format specifiers to control the
 translation of data from internal (binary) form within a program to
 external (readable character) form in the records, or vice versa.
3 format_specification       
 format specification

 The part of a FORMAT statement that specifies data arrangement.  It
 is a list within parentheses that can include field descriptors,
 edit descriptors, and field separators.
3 full_pathname              
 full pathname (U*X)

 See absolute_pathname.
3 function                    
 See function_subprogram.
3 function_reference         
 function reference

 A reference, in an expression, consisting of a function name and
 its arguments.  A function reference returns a value that is used
 in evaluating the expression in which the function appears.
3 function_subprogram        
 function subprogram

 A series of statements that perform some operation and return a
 single value (through the function name) to the calling program
 unit.  A function subprogram begins with a FUNCTION (or optional
 OPTIONS) statement and is invoked by a function reference in a main
 program unit or a subprogram unit.  See also subroutine_subprogram
 and statement_function.
3 global_optimization        
 global optimization

 A level of optimization enabling code motion, strength reduction,
 split life analysis, instruction scheduling, and inlining of
 arithmetic functions.  Global optimization can be thought of as
 optimization within a program unit, that is, across statements.

 "Additional global optimization" is a level of optimization that
 improves speed at the cost of increasing the size of the VMS object
 module or U*X object file.  This optimization includes
 interprocedural analysis, inlining procedures, multiplication and
 division expansion, loop unrolling, and code replication.
 Additional global optimization can be thought of as optimization
 across program units.  See also optimization.
3 global_section             
 global section

 A data structure (for example, global COMMON) or shareable image
 section potentially available to all processes in the system.
3 global_symbol              
 global symbol

 A symbol name defined in a VMS module (such as a source, object, or
 image module) or U*X object file, that is available for reference
 by another module or object file.
3 hexadecimal_constant       
 hexadecimal constant

 A constant that is a string of hexadecimal digits (range 0 to 9, or
 an uppercase or lowercase letter in the range A to F) enclosed by
 apostrophes and followed by the letter X.  In Digital Fortran 77,
 the letter X can alternatively precede the string, and the letter Z
 can alternatively precede or follow the string.
3 Hollerith_constant         
 Hollerith constant

 A constant that is a string of printable ASCII characters preceded
 by nH, where n is the number of characters in the string (including
 spaces and tabs).
3 implicit_typing            
 implicit typing

 The specification of the type of data to be stored in a variable by
 the beginning letter of the symbolic (variable) name.
3 index                       
 (1) The variable used as a loop counter in a DO statement.  (2) An
 intrinsic function specifying the starting position of a substring
 inside a string.  (3) In VMS, an internal data structure that
 provides a guide, based on key values, to file components in an
 indexed file.
3 indexed_file_organization 
 indexed file organization (VMS)

 A file organization that allows random retrieval of records by key
 value and sequential retrieval of records within the key of
 reference.  Each file contains records and a primary key index
 (and, optionally, one or more alternate key indexes).
3 initialize                  
 The assignment of an initial value to a variable.
3 input/output                
 input/output (I/O)

 The data that a program reads or writes.  Also, devices to read and
 write data.
3 integer_constant           
 integer constant

 A constant that is a whole number with no decimal point.  It can
 have a leading sign and is interpreted as a decimal number.
3 interactive_process        
 interactive process

 A process that must periodically get user input to do its work.
 Contrast with batch process (VMS) or background process (U*X).
3 internal_file              
 internal file

 The designated internal storage space (or variable buffer) that is
 manipulated during input and output.  An internal file can be a
 character variable, character array, character array element, or
 character substring.  In general, an internal file contains one
 record.  However, an internal file that is a character array has
 one record for each array element.
3 intrinsic_function         
 intrinsic function

 A subprogram supplied as part of the Fortran library that performs
 mathematical, numeric, character, bit manipulation, and other
 miscellaneous functions.  Also called a built-in or library
 function.  See also 3f_library_routines (which are available on U*X
 systems).
3 invoke                      
 To call upon; used especially with reference to subprograms.  For
 example, to invoke a function is to execute the function.
3 I/O                         
 See input/output.
3 iteration_count            
 iteration count

 The number of executions of the DO range, which is determined as
 follows:

 [(terminal value - initial value + increment value) / increment value]
3 key                         
 key (VMS)

 A value in a file of indexed organization that VMS uses to build
 indexes into the file.  Each key is identified by its location
 within the component, its length, and its data type.  Also called
 the key field.  See also alternate_key, index, and primary_key.
3 key_of_reference          
 key of reference (VMS)

 A key used by VMS systems to determine the index to use when
 sequentially accessing components of an indexed file.  See also
 key, indexed_file_organization, and sequential_access.
3 keyed_access               
 keyed access (VMS)

 A method for retrieving or writing data in which the data (a
 record) is identified by specifying the information in a key field
 of the record.  See also key.
3 label                       
 See statement_label.
3 language_extension         
 language extension

 A Digital Fortran 77 language element that is not part of the
 FORTRAN-77 standard.
3 library_function           
 library function

 See intrinsic_function.
3 linker                      
 A system program that creates an executable program from one or
 more VMS object modules or U*X object files produced by a language
 compiler or assembler.  The linker resolves external references,
 acquires referenced library routines, and performs other processing
 required to create VMS executable images or U*X executable files.
3 list-directed_I/O_statement
 list-directed I/O statement

 An I/O statement that uses a data list (as do namelist I/O
 statements) instead of using explicit format specifiers.  Input is
 accomplished by READ *, list; output by WRITE *, list.  Contrast
 with formatted_I/O_statement.
3 listing                     
 A printed copy of a program.
3 little_endian              
 little endian

 A method of data storage in which the least significant bit of a
 numeric value spanning multiple bytes is in the "lowest" addressed
 byte.  This is the method used on Digital systems.  Contrast with
 big_endian.
3 local_optimization         
 local optimization

 A level of optimization enabling optimizations within the source
 program unit and recognition of common expressions.  See also
 optimization.
3 local_symbol               
 local symbol

 A name defined in a program unit that is not accessible outside of
 that program unit.
3 logical_constant           
 logical constant

 A constant that specifies the value .TRUE. or .FALSE..
3 logical_expression         
 logical expression

 An integer or logical constant, variable, function value, or
 another constant expression, joined by a relational or logical
 operator.  The logical expression is evaluated to a value of either
 true or false.  For example, .NOT.  6.5 + (B .GT.  D).
3 logical_operator           
 logical operator

 A symbol that represents an operation on logical expressions.  The
 logical operators are:  .AND., .OR., .NEQV., .XOR., .EQV., and
 .NOT..
3 logical_unit               
 logical unit

 A channel in memory through which data transfer occurs between the
 program and the device or file.  See also unit_identifier.
3 longword                    
 Four contiguous bytes (32 bits) starting on any addressable byte
 boundary.  Bits are numbered 0 to 31.  The address of the longword
 is the address of the byte containing bit 0.  When the longword is
 interpreted as a signed integer, bit 31 is the sign bit.  The value
 of signed integers is in the range -2**31 to 2**31-1.  The value of
 unsigned integers is in the range 0 to 2**32-1.
3 loop                        
 A group of statements that are executed repeatedly until an ending
 condition is reached.
3 main_program               
 main program

 A program unit containing a PROGRAM statement (or not containing a
 SUBROUTINE, FUNCTION, or BLOCK DATA statement).  The main program
 is the first program unit to receive control when a program is run,
 and exercises control over subprograms.  Contrast with subprogram.
3 makefile                    
 makefile (U*X)

 An argument to the make command containing a sequence of entries
 that specify dependences.  The contents of a makefile override the
 system built-in rules for maintaining, updating, and regenerating
 groups of programs.  For more information, see make(1).
3 message_file               
 message file

 A file (or catalog, in U*X) that contains the diagnostic message
 text of errors that may occur during program execution (run time).
3 misaligned_data            
 misaligned data

 Data not aligned on a natural boundary.  See also natural_boundary.
3 module                      
 A portion of a program or program library, as in a source module,
 object module, or image module; a program unit that contains or
 causes definitions that other program units can access.
3 multinational_character_set
 multinational character set

 An 8-bit character encoding scheme associating an integer from 128
 through 255 with 128 characters.  This character set contains
 international alphanumeric characters, including characters with
 diacritical marks.  See also ASCII.
3 named_common_block        
 named common block

 A common block (one or more contiguous areas of storage) with a
 name.  Common blocks are defined by a COMMON statement.
3 namelist_I/O_statement    
 namelist I/O statement

 An I/O statement that uses a data list (as do list- directed I/O
 statements) instead of using explicit format specifiers.  Input is
 accomplished by READ namelist; output by WRITE namelist.  Contrast
 with formatted I/O statement.
3 natural_boundary           
 natural boundary

 The virtual address of a data item that is the multiple of the size
 of its data type.  For example, a REAL*8 data item aligned on
 natural boundaries has an address that is a multiple of eight.
3 naturally_aligned_record  
 naturally aligned record

 A record that is aligned on a natural boundary up to 8 bytes; each
 field is naturally aligned.  Contrast with packed_record.
3 nesting                     
 The placing of one structure inside another structure of the same
 kind.  For example, nesting a loop within another loop (a nested
 loop), or nesting a subroutine within another subroutine (a nested
 subroutine).
3 nonexecutable_statement    
 nonexecutable statement

 A Fortran statement that describes program attributes, but does not
 cause any action to be taken when the program is executed.
3 numeric_storage_unit      
 numeric storage unit

 The amount of storage needed to represent one REAL, INTEGER, or
 LOGICAL value.  In Digital Fortran 77, one numeric storage unit is
 equivalent to 4 bytes of memory.
3 object_file                
 object file (U*X)

 The binary output of an U*X language processor (such as an
 assembler or compiler), which can either be executed or be used as
 input to the linker.  Contrast with object_module.
3 object_module              
 object module (VMS)

 The binary output of a language processor such as the assembler or
 a compiler, which is used as input to the linker.  Contrast with
 object_file.
3 octal_constant             
 octal constant

 A constant that is a string of octal digits (range of 0 to 7)
 enclosed by apostrophes and followed by the letter O.  In Digital
 Fortran 77, the string can alternatively be preceded by the letter
 O.
3 operand                     
 The passive element in an expression on which an operation is
 performed.  Every expression must have at least one operand.  For
 example, in I .NE.  J, I and J are operands.  Contrast with
 operator.
3 operator                    
 The active element in an expression that performs an operation.  An
 expression can have zero or more operators.  For example, in      
 I .NE.  J, .NE.  is the operator.  Contrast with operand.
3 optimization                
 The process of producing efficient object or executing code that
 takes advantage of the hardware architecture to produce more
 efficient execution.  See also global_optimization.
3 order_of_subscript_progression
 order of subscript progression

 A characteristic of a multidimensional array in which the leftmost
 subscripts vary most rapidly.
3 overflow                    
 An error condition occurring when the result of an arithmetic
 operation yields a result that is larger than the maximum value in
 the range of a data type.
3 packed_record              
 packed record

 A record that starts on an arbitrary byte boundary; each field
 starts in the next unused byte.  Contrast with
 naturally_aligned_record.
3 pad                         
 The filling of unused positions in a field or character string with
 dummy data (such as zeros or blanks).
3 parameter                   
 (1) In general, any quantity of interest in a given situation;
 often used in place of the term "argument." (2) A Fortran named
 constant.
3 passed-length_character_argument
 passed-length character argument

 A dummy argument that assumes the length attribute of the
 corresponding actual argument.  An asterisk (*) specifies the
 length of the dummy character argument.
3 pathname                   

 The path from the root directory to a subdirectory or file.  See
 also root.
3 pipe                       
 pipe (U*X)

 A connection that allows one program to get its input directly from
 the output of another program.
3 platform                   
 A combination of operating system and hardware that provides a
 distinct environment in which to use a software product.  The
 current Digital Fortran 77 platforms are Digital UNIX on Alpha,
 OpenVMS on VAX, OpenVMS on Alpha, and crosoft Windows NT on Alpha.
3 precision                  
 The number of significant digits in a real number.  See also
 double-precision_constant and single-precision_constant.
3 primary_key               
 primary key (VMS)

 The required key within the data records of an indexed file, which
 is used to determine the placement of records within the file and
 to build the primary index.
3 procedure                  
 A computation that can be invoked during program execution.  It can
 be a subroutine or function, an internal, external, or dummy
 procedure, or a statement function.  A subprogram can define more
 than one procedure if it contains an ENTRY statement.  See also
 subprogram.
3 program                    
 A set of instructions that can be compiled and executed by itself.
 Program blocks contain a declaration and an executable section.
3 program_section           
 program section

 A particular common block or local data area for a particular
 routine containing equivalence groups; used in data-flow analysis.
3 program_unit              
 program unit

 A main program or a subprogram; the fundamental component of an
 executable program.  A sequence of statements and optional comments
 that can be a main program, a procedure, an external program, or a
 block data program unit.
3 quadword                   
 Four contiguous words (64 bits) starting on any address- able byte
 boundary.  Bits are numbered 0 to 63.  (Bit 63 is used as the sign
 bit.) A quadword is identified by the address of the word
 containing the low-order bit (bit 0).  The value of the quadword is
 in the range -2**63 to 2**63-1.
3 random_access             
 random access

 See direct_access.
3 real_constant             
 real constant

 A constant that is a number written with a decimal point, exponent,
 or both.  It can have single precision (REAL*4) or double precision
 (REAL*8); on VAX processors, it can also have quad precision
 (REAL*16).
3 record                     
 (1) A set of logically related data items (in a file) that is
 treated as a unit; such a record contains one or more fields.  This
 definition applies to I/O records and items that are declared
 RECORD.  (2) One or more data items that are grouped in a structure
 declaration and specified in a RECORD statement.  See also field
 and structure_declaration.
3 record_access             
 record access

 The method used to store and retrieve records in a file.
3 record_type               
 record type

 The property that determines whether records in a file are all the
 same length, of varying length, or use other conventions to define
 where one record ends and another begins.
3 recursion                  
 recursion

 The act of a routine directly or indirectly calling itself.
3 relational_expression     
 relational expression

 An expression containing one relational operator and two operands
 of numeric or character type.  The result is a value that is true
 or false.  For example, A-C .GE.  B+2, or DAY .EQ.  'MONDAY'.
3 relational_operator        
 relational operator

 The symbols used to express a relational condition or expression:
 .EQ., .NE., .LT., .LE., .GT., and .GE..
3 relative_pathname         
 relative pathname (U*X)

 A directory path expressed in relation to any directory other than
 the root directory.  Contrast with absolute_pathname.
3 relative_file_organization
 relative file organization

 A file organization that consists of a series of component
 positions, called cells, numbered consecutively from 1 to n.
 Digital Fortran 77 uses these numbered, fixed-length cells to
 calculate the component's physical position in the file.
3 root                        
 root (U*X)

 The top-level directory in the U*X file system.  The root directory
 is represented by a slash (/).
3 routine                     
 A subprogram; a function or procedure.  See also
 function_subprogram, subroutine_subprogram, and procedure.
3 run_time                   
 run time

 The time during which a computer executes the statements of a
 program.
3 scalar                      
 Pertaining to single data items.  Contrast with vector.
3 scalar_memory_reference   
 scalar memory reference

 A reference to a scalar variable, scalar record field, or array
 element that resolves into a single, typed data item and can be
 assigned a value with an assignment statement.  It is similar to a
 scalar reference, but it excludes constants, character substrings,
 and expressions.
3 scalar_reference            
 scalar reference

 A reference to a scalar variable, scalar record field, array
 element, constant, character substring, or expression that resolves
 into a single, typed data item.  Contrast with
 scalar_memory_reference.
3 scalar_variable            
 scalar variable

 A variable name specifying one storage location.  Contrast with
 array_name.
3 scale_factor               
 scale factor

 A number indicating the location of the decimal point in a real
 number and, if there is no exponent, the size of the number on
 input.
3 scope                       
 The portion of a program in which a declaration or a particular
 name has meaning.
3 seed                        
 A value (which can be assigned to a variable) that is required in
 order to properly determine the result of the calculation; for
 example, the argument i in the random number generator (RAN)
 function syntax:  y = RAN (i).
3 sequential_access          
 sequential access

 A method for retrieving or storing data in which the data (record)
 is read from, written to, or removed from a file based on the
 logical order (sequence) of the record in the file.  (The record
 cannot be accessed directly.) Contrast with direct_access.
3 sequential_file_organization
 sequential file organization

 A file organization in which records are stored one after the
 other, in the order in which they were written to the file.
3 short_field_termination    
 short field termination

 The use of a comma (,) to terminate the field of a numeric field
 descriptor.  This technique overrides the field width (w)
 specification in the field descriptor and therefore avoids padding
 of the input field.  The comma can only terminate fields less than
 w characters long.  See also field_descriptor.
3 signal                       
 The software mechanism used to indicate that an exception condition
 (abnormal event) has been detected.  For example, a signal can be
 generated by a program or hardware error, or by request of another
 program.
3 single-precision_constant   
 single-precision constant

 A processor approximation of the value of a real number that
 occupies 4 bytes of memory and can assume a positive, negative, or
 zero value.  The precision is less than a constant of
 double-precision type.  For information on ranges for these
 numbers, see your language reference manual.  See also
 denormalized_number.
3 source_program              
 source program

 A program (or code) in a high-level language form.  Also called
 source code.
3 specification_statement     
 specification statement

 A nonexecutable statement that provides information about the data
 used in the source program.  Such a statement can be used to
 allocate and initialize variables, arrays, records, and structures,
 and define other characteristics of symbolic names used in a
 program.
3 statement                    
 An instruction in a programming language that represents a step in
 a sequence of actions or a set of declarations.  There are two main
 classes of statements:  executable and nonexecutable.  See also
 executable_statement and nonexecutable_statement.
3 statement_block             
 statement block

 A sequence of zero or more statements following a block IF
 statement up to, but not including, the next block IF statement.
 Block IF statements can begin with IF THEN, ELSE IF THEN, or ELSE,
 and end with END IF.
3 statement_function          
 statement function

 A computing procedure defined in a single Fortran statement.  A
 statement function is invoked by a function reference in a main
 program unit or a subprogram unit; it must precede all executable
 statements and follow all specification statements.
3 statement_function_definition
 statement function definition

 A statement that defines a statement function.  Its form is the
 statement function name (followed by its optional dummy arguments
 in parentheses), followed by an equal sign (=), followed by a
 numeric, logical, or character expression.  See also
 statement_function.
3 statement_label            
 statement label

 An integer, from 1 to 5 digits long, that is used to identify a
 statement.  For example, statement labels can be used to refer to a
 FORMAT statement, or transfer control.
3 static_variable            
 static variable

 A variable whose storage is allocated for the entire execution of a
 program.
3 storage_location           
 storage location

 An addressable unit of main memory.
3 storage_unit               
 storage unit

 The amount of storage used to represent one REAL, INTEGER, LOGICAL,
 or character value.  See also numeric_storage_unit and
 character_storage_unit.
3 structure_declaration      
 structure declaration

 A block of statements that define the fields in a record.  The
 block begins with a STRUCTURE statement and ends with END
 STRUCTURE.  The name of the structure must be specified in a RECORD
 statement.
3 subprogram                  
 An external function or subroutine that can be invoked from another
 program unit to perform a specific task.  Contrast with
 main_program.
3 subroutine                  
 See subroutine_subprogram.
3 subroutine_subprogram      
 subroutine subprogram

 A procedure that can return many values, a single value, or no
 value to the calling program unit (through arguments).  A
 subroutine subprogram begins with a SUBROUTINE (or optional
 OPTIONS) statement and is invoked by a CALL statement in another
 program unit.  See also function_subprogram and statement_function.
3 subscript                   
 An integer value, enclosed in parentheses and used with an array
 name, that specifies the position of an array element.  See also
 array, array_name, array_element.
3 subscript_expressions      
 subscript expressions

 A list of expressions, enclosed in parentheses, that determine
 which element in the array is being referenced.  The subscript is
 appended to the array name to which it refers.
3 symbolic_name              
 symbolic name

 A unique name used to identify an entity within a Fortran program
 unit.  A symbolic name identifies one entity in a program unit
 (such as a function or subroutine), or it can identify a common
 block, record, structure, structure field, array, or variable.
3 syntax                      
 The formal structure of a statement or command string.
3 transfer_list              
 transfer list

 The list of statement labels in a computed GO TO statement; the
 labels are separated by commas.
3 truncation                  
 (1) A technique that approximates a numeric value by dropping its
 fractional value and using only the integer portion.  (2) The
 process of removing one or more characters from the left or right
 of a number or string.
3 type_declaration_statement
 type declaration statement

 A nonexecutable statement specifying the data type of one or more
 variables:  an INTEGER, REAL, DOUBLE PRECISION, COMPLEX, DOUBLE
 COMPLEX, CHARACTER, LOGICAL, or TYPE statement.  Also called a type
 declaration or type specification.
3 unary_operator             
 unary operator

 An operator that operates on one operand.  For example, the minus
 sign in -A and the .NOT.  operator in .NOT.  (J .GT.  K).
3 underflow                   
 An error condition occurring when the result of an arithmetic
 operation yields a result that is smaller than the minimum value in
 the range of a data type.  For example, in unsigned arithmetic,
 underflow occurs when a result is negative.  See also
 denormalized_number.
3 unformatted_data           
 unformatted data

 Data written to a file by using unformatted I/O statements; for
 example, binary numbers.
3 unformatted_I/O_statements
 unformatted I/O statements

 A statement that does not contain format specifiers and therefore
 does not translate the data being transferred.
3 unformatted_record         
 unformatted record

 A record that is transmitted in internal format between internal
 and external storage.
3 unit_identifier            
 unit identifier

 The number that specifies an external unit or internal file.  The
 number can be any one of the following:  an integer expression
 whose value must be zero or positive; an asterisk (*) that
 corresponds to the default input or output unit; the name of a
 character scalar memory reference or character array name reference
 for an internal file.  Also called a device code, or logical unit
 number.
3 variable                    
 A value stored in a memory location that may change during the
 execution of a program.  A variable is a value that is referenced
 by a symbolic name (identifier).  See also symbolic_name.
3 variable-length_record_type
 variable-length record type

 A file format in which records may be of different lengths.
3 vector                      
 A data structure comprising scalar elements with the same data type
 and organized as a simple linear sequence.  Contrast with scalar.
