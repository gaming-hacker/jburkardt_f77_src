1 MATMAN  version 1.58  11 November 1996   MATMAN is a teaching program, which makes it easy to carry out  operations on a matrix.   MATMAN can help a user:    Transform a matrix to reduced row echelon form;    Diagonalize a symmetric matrix;    Carry out the simplex method.   The MATMAN user can choose:    Fractional arithmetic, like 4/3;    Real arithmetic, like 1.33333...;    Decimal arithmetic to a fixed number of places, like 1.33.2 Table of Contents   MATMAN    Background     Purpose    Typical session    Matrix algebra commands      A    Add S times row I to row J.      B    Set up sample problem.      C    Change entry I,J to S.      D    Divide row I by S.      DEC  Use decimal arithmetic.      DET  Determinant of the matrix      E    Enter a matrix with I rows and J columns.      EDET Print the ERO determinant.      F    Change to fraction, real, or decimal arithmetic.      G    Add/delete a row or column of the matrix.      H    Display brief help.      HELP Display full help      I    Interchange rows I and J.      J    Jacobi rotation in (I,J) plane.      K    Open/close transcript file.      L    Enter linear programming mode.      M    Multiply row I by S.      N    Set number of decimal digits.      O    Check matrix for reduced row echelon form.      Q    Quit.      R    Restore the matrix or tableau.      RAT  Use rational arithmetic.      REAL Use real arithmetic.      S    Store the matrix or tableau.      T    Type out the matrix or tableau.      TR   Transpose the matrix.      U    Undo last operation.      W    Write the matrix to a file.      X    Read the matrix from a file.      Y    Turn autoprint OFF or ON.      Z    Automatic reduction to reduced row echelon form      $    Turn paging OFF.      %    Turn paging ON.      #    Begin a comment line.      ?    Extensive help from the help file.      <    Get input from a file.    Linear programming commands      A     Add S times row I to row J.      B     Set up sample problem.      BASIC Assign row I to basic variable J.      C     Change entry I,J to S.      D     Divide row I by S.      DEC   Use decimal arithmetic.      E     Enter a problem with I constraints and J variables.      F     Change to fraction, real, or decimal arithmetic.      H     Display brief help.      HELP  Display full help      I     Interchange rows I and J.      K     Open/close transcript file.      L     Leave linear programming mode.      M     Multiply row I by S.      N     Set number of decimal digits.      O     Check tableau for optimality.      P     Carry out one pivoting step.      Q     Quit.      R     Restore the matrix or tableau.      RAT   Use rational arithmetic.      REAL  Use real arithmetic.      S     Store the matrix or tableau.      T     Type out the matrix or tableau.      U     Undo last operation.      V     Eliminate artificial variables.      W     Write the tableau to a file.      X     Read the tableau from a file.      Y     Turn autoprint OFF or ON.      Z     Automatic simplex method solution.      $     Turn paging OFF.      %     Turn paging ON.      #     Begin a comment line.      ?     Extensive help from the help file.      <     Get input from a file.    Arithmetic forms     Elementary row operations      Solving a linear system      Inverting a matrix      Computing the determinant     Row echelon form     Jacobi iteration     Simplex method      Pivoting step      Two phase method     Sample problems      Determinant example      Solve example      Inverse example      Eigenvalue example      Standard linear programming example      Advanced linear programming example     DOS PC version      Compilation details on the PC      Redirecting Input and Output on the PC     Windows PC version     Macintosh version      Compilation details on the Macintosh      Bugs and Problems on the Macintosh     UNIX version      Compilation details on UNIX      Redirecting Input and Output on UNIX     VMS version      Compilation details on VMS      Redirecting Input and Output on VMS     DOUBLE PRECISION version     64 bit integer version2 Background   MATMAN was developed by     John Burkardt,    Mathematics Department,    Iowa State University,    Ames, Iowa, 50011      and      Charles G. Cullen,    Department of Mathematics and Statistics,    University of Pittsburgh,    Pittsburgh, Pennsylvania, 15260   The developer's EMAIL addresses are:     burkardt@math.iastate.edu    cullen@vms.cis.pitt.edu   This program accompanies the textbook     Charles G. Cullen,    An Introduction to Linear Algebra, Second Edition    Harper Collins College Publishers,    Glenview, Illinois, 1996   All rights to this program are reserved by the authors, the  University of Pittsburgh, and the publishers.   MATMAN may not be reproduced in any manner without permission.   Schools using this textbook are automatically granted permission  to distribute copies of MATMAN to their faculty and students.   The creation of MATMAN was partially supported by a courseware   development grant from the College of General Studies of the   University of Pittsburgh.  2 Purpose   MATMAN is a learning aid, NOT a computational device!  Therefore, MATMAN only accompanies the user through the solution  of simple problems in linear algebra or linear programming.  MATMAN does the arithmetic involved in matrix elimination, but the   user must decide which row to use as a pivot, how to normalize   the row, and how to eliminate nonzero entries in other rows.   MATMAN can be used in two ways:   * In "linear algebra mode" MATMAN carries out elementary    row operations on a matrix, with the goal of bringing that     matrix to row echelon form.   * In "linear programming mode", MATMAN operates on a a linear    programming tableau to find a legal set of values that     maximize a linear function.    MATMAN offers three forms of arithmetic to work in.  The  desired choice can be selected using the "RATIONAL", "REAL"  or "DECIMAL" commands:   * Rational arithmetic will most nearly duplicate normal     hand calculations, and round-off inaccuracies will be     avoided.  However, MATMAN can fail if the numerator or    denominator of a fraction becomes too large.   * Real arithmetic has a greater range than fractional, but    has trouble representing simple values like 1/3 exactly.    Calculations with real numbers are always subject to     inaccuracies.     * Decimal arithmetic can exactly represent any decimal     quantity of a limited number of digits.  Calculations     with decimals will be inexact.  This option can    simulate the arithmetic of an N digit decimal computer    with rounding.    MATMAN has a fixed amount of workspace, which restricts the size   of the problems that can be solved.   In linear algebra mode, matrices can have 16 rows and 30 columns.   In linear programming, the tableau can have 15 rows (plus one  "hidden" row for two phase problems) and 30 columns.  To increase these limits, recompile the program after changing the   following lines of the source code file MATMAN.F:       integer maxcol      parameter (maxcol=30)      integer maxrow      parameter (maxrow=16) 2 Typical Session  Here is a simple MATMAN session.  The user enters a matrix and reduces it to reduced row echelon form,  using elementary row operations.  COMMAND          MEANING  -------          -------  e                Enter a matrix.  3, 3             The matrix has 3 rows and 3 columns.          -1,  2, -1       Here are the entries of the matrix.   2,  1,  0   0, -1,  2  c 2,2 -1         Changing the value of matrix entry (2,2)                    to -1.  The matrix is now:                    -1,  2, -1                      2, -1,  0                     0, -1,  2  r1 <=> r2        Interchange matrix rows 1 and 2.                      The matrix is now:                     2, -1,  0                    -1,  2, -1                      0, -1,  2  r1 <= r1 / 2     Divide row 1 by 2.                   The matrix is now:                     1  -1   0                         2                      -1   2  -1                       0  -1   2  r2 <= r2 + r1    Add 1 times row 1 to row 2, resulting in                     1  -1   0                         2                       0   3  -1                         2                       0  -1   2  r2 <= 2/3 r2     Multiply row 2 by 2/3, resulting in                     1  -1   0                         2                       0   1  -2                             3                       0  -1   2  o                 Ask MATMAN if the matrix is in row echelon form.                    MATMAN's response is:  "The matrix is NOT in row echelon form.   The first nonzero entry in row 3   is -1 rather than 1."  Continuing in this way, this matrix can be transformed into  the identity matrix.2 Matrix Algebra Commands   The list of the commands available in linear algebra mode  follows.  Only the commands specific to this mode will be  explained here.   This list can be displayed at any time by issuing the "H" command.  Many commands are only legal if a matrix has been set up, and  the "H" command will only display them when they are available.   In this list, "S", "I" and "J" stand for numbers that should  be included in the command.   "S" is typically a multiplier, in real or fractional format,  "I" and "J" are usually row or column identifiers.      A    Add S times row I to row J.    B    Set up sample problem.    C    Change entry I,J to S.    D    Divide row I by S.    DEC  Use decimal arithmetic.    DET  Determinant of the matrix    E    Enter a matrix with I rows and J columns.    EDET Print the ERO determinant.    F    Change to real, fraction, or decimal arithmetic.    G    Add/delete a row or column of the matrix.    H    Display brief help.    HELP Display full help.    I    Interchange rows I and J.    J    Jacobi rotation in (I,J) plane.    K    Open/close transcript file.    L    Enter linear programming mode.    M    Multiply row I by S.    N    Set number of decimal digits.    O    Check matrix for reduced row echelon form.    Q    Quit.    R    Restore matrix.    RAT  Use rational arithmetic.    REAL Use real arithmetic.    S    Store the matrix.    T    Type out the matrix.    TR   Transpose the matrix.    U    Undo last operation.    W    Write matrix to file.    X    Read matrix from file.    Z    Automatic reduction to reduced row echelon form    $    Turn paging OFF.    %    Turn paging ON.    #    Begin a comment line.    ?    Extensive help from the help file.    <    Get input from a file.   If a command has several arguments, they may be listed on the same  line as the command letter, or not.   If the arguments are not included, the program will prompt for them.  3 A Add S times row I to row J.   The "A" command will add S times row I to row J.   Legal commands to add 2.5 times row 2 to row 6 include     A 2.5, 2, 6  or    A 5/2, 2, 6  or the ERO form:    r6 <= r6 + 5/2 r2  3 B Set up sample problem.   The "B" command will set up a sample problem.   The sample problem will overwrite any previous problem that MATMAN   had been working on.   There is a choice of problems:     D, a square matrix whose determinant is to be found;    E, a matrix whose eigenvalues can be found with the "J" command;    I, an inverse to find;    S, a linear system to be solved.  Typing "C" will cancel the choice of a problem.3 C Change entry I, J to S.   The "C" command changes the entry in row I, column J, to S.   The command to change entry 1,3 to 3.5 could be written as     C 1,3, 3.5  or    C 1,3, 7/2 3 D Divide row I by S.   The "D" command divides row I by the number S.   Commands to divide row 1 by -4 include     D 1, -4   or the ERO form:    r1 <= r1 / -4   It might be surprising to see that MATMAN includes both a "D"   and an "M" command.  Why have both, when dividing by 3 is the   same as multiplying by 1/3?     Mathematically, it is true that dividing by 3 is the same as   multiplying by 1/3, but this is not necessarily true on a   computer.  A computer can represent 3 exactly, but 1/3 cannot be  represented exactly in "floating point" arithmetic, what MATMAN   calls "real" arithmetic.  Therefore, if we're using real arithmetic, and we want to modify  a row so an entry that is now 3 becomes 1 instead, we have two  choices:  The "D" command can be used to divide by 3, which is guaranteed  to produce a result which is exactly 1.  The "M" command can be used to multiply by 1/3, which may give  a result of 1, or perhaps a result something like 0.9999...   That's why the "D" command is useful. 3 DEC Use decimal arithmetic  This command tells the program to begin working in decimal   arithmetic.  You will be asked how many decimal places you  want to use, and the current matrix, if any, will be converted  to decimal format. 3 DET Determinant of the matrix  The "DET" command computes the determinant of the current matrix.  The matrix must be square, that is, it must have the same number  of rows as columns.  If the matrix is singular (does not have an inverse) then the  determinant will be zero. 3 E Enter matrix with I rows and J columns.   The "E" command enters a matrix of I rows and J columns.   The program will then request that the elements of the matrix  be entered, one row at a time, separated by commas or spaces.   A 3 by 4 matrix could be entered by typing:     E 3,4    1, 2, 3, 4.0    5, 6, 7, 8    9, 8, 7, 6.5   Each time a matrix is entered, a copy is automatically stored.   This means that, unless you store another matrix in the mean time,  you can always recover your original input matrix with the "R"  command if you regret the changes you have made to it.   The program stores only one matrix.   If additional storage is required, use the "W" command.  3 EDET Print the ERO determinant  When elementary row operations are applied to a matrix A, the  operation may be regarded as the multiplication of A by a matrix  E1, with result A1:    E1 * A = A1.  If another ERO is applied, we may call it "E2", and the result "A2",  and we have the relationship:    E2 * E1 * A = E2 * A1 = A2.  Now let us suppose that after several ERO's have been applied,  we replace the sequence of matrices by their product, "E":    EN * E(N-1) * ... * E2 * E1 = E  Then we have    E * A = AN.  In other words, the result of all the ERO's applied to A can be  computed by multiplying A by a single matrix E.  Now suppose we were trying to compute the determinant of A.  We  know how to use ERO's to reduce A to the identity, so that we would  have the relationship    E * A = I.  But then we know that    det(E) * det(A) = det(I) = 1  or     det(A) = 1/det(E).  In other words, the determinant of A is the inverse of the determinant  of E, the matrix which reduces it to the identity (if such a matrix  exists).    The "EDET" command allows you to print out, at any time, the determinant  of the current matrix E, which is the product of all the elementary  row operations applied to the current matrix A.3 F Change to fractional, real, or decimal arithmetic.   The "F" command chooses the arithmetic form.  For example,    F R  changes to real arithmetic.  The choices are:    F for fractional arithmetic;    R for real arithmetic;    D for decimal arithmetic.   If a matrix has already been entered, it will be converted to   the new arithmetic form.  If decimal arithmetic is chosen, you may also want to issue  the "N" command, to specify the number of decimal places to use.  You may find it easier to use the "DECIMAL", "RATIONAL" or "REAL"  commands. 3 G Add/delete a row or column of the matrix   The "G" command adds or deletes a row or column of the matrix.   Type "+" to add something, and "-" to delete something.   Type "R" if you're interested in a row, or "C" for a column.   If you're adding a row or column, type the position the new object  should occupy.  For instance, you would type "1" if the new  row or column was to be the first row or column in the matrix.  All other rows or columns will automatically shift to make room  for the new one.   If you're adding a row or column, you will then be requested to  enter the values of its entries.   Here is the input that would insert a row at position 3 in  the current matrix, and assign values to its 5 entries:     G +R 3    1.0, 2.0, 3.5, 4.7, 5.3  3 H Display quick help   The "H" command prints one line explanations of the most  useful linear algebra commands.3 HELP Display full help  The "HELP" command prints out every available command,  with a one line explanation.  If you need more help than that, use the "?" command. 3 I Interchange rows I and J.   The "I" command interchanges rows I and J in the matrix.   Commands to switch rows 1 and 2 include     I 2, 1   and the ERO form:    r1 <=> r2  In linear programming mode, you are NOT allowed to switch the  last row to any other position, because of its special function  as the objective row.  3 J Jacobi rotation in (I,J) plane.   The "J" command constructs an orthogonal matrix Q with the property  that TRANSPOSE(Q)*A*Q has zero entries in the (I,J) and (J,I)  positions.   The multiplication is carried out, and the new matrix A is  displayed.   Repeated application of this command to each off-diagonal entry  of a symmetric matrix A will gradually drive A towards a similar  matrix that is diagonal.   As the matrix approaches a diagonal matrix, the diagonal entries  will approach the eigenvalues of the original matrix.   This command may only be used with REAL arithmetic, and requires  that I and J be distinct, that the matrix be square, and that the  matrix be symmetric. 3 K Open/close transcript file   The "K" command opens a file into which is put an exact copy of  everything you or the program types.   This is useful when doing homework, or for checking your work.   A second "K" command will close the file.   The program asks for a filename such as "MATMAN.LPT".  Warning: If a file with this name exists already, then that file   and the information in it will be lost.  MATMAN "overwrites"  the old file, rather than "appending" new information to it.    On most computers, the file will be created in the same directory  where you were working when you started running MATMAN.   Depending on the operating system, you may be able to specify  an alternate location for the file, by specifying directory  information in the name, such as     "B:\MY_PC\MATMAN.LPT"  or    "/usr/users/fred/homework.txt"  or    "Mac disk:problems:transcript.doc"   On a DOS PC, you can generate a hardcopy, as the  file is being constructed, by pressing the "CTL" and  "PRINT SCREEN" keys together.   Once constructed, the file can be edited using any available  editor or word processor.   On a Macintosh computer, you should be able to examine or print  the transcript file with any editor program. 3 L Enter linear programming mode.   The program begins in linear algebra mode.   If you want to solve a linear programming problem, you  should go into linear programming mode immediately.   In linear programming mode, the method of entering the problem  is entirely different.   You may try to enter a problem in linear algebra mode, and then  switch to linear programming mode.  The program tries to make  this transition possible for you.  It needs to know the number of  slack variables and artificial variables. Then, using the "C"  command, you must identify the basic variables.   This method is only recommended for the experienced user. 3 M Multiply row I by S.   The "M" command multiplies row I by the number S.   Commands to multiply row 1 by -4 include     M 1, -4   and the ERO form:    r1 <= -4 r13 N Set number of decimal digits.  The "N" command sets the number of decimal digits used.    This command is only useful if you have chosen decimal arithmetic  with the "DECIMAL" command.  The default number of digits, called "NDIG", is 6.  This means that  decimal quantities will have at most 6 digits.   If NDIG is 6,  the value of 8/3, for instance, will be stored as exactly  2.33333.  Using the "N" command, you can change the number of digits  to any value between 1 and 7.  Using a small value of NDIG  can make the effects of roundoff show up very quickly.  3 O Optimality check.   The "O" command checks the current matrix to see if it is in  either row echelon form or reduced row echelon form, and  if not, explains why not.   An explanation of row echelon form and reduced row echelon  form is given elsewhere in these notes.3 Q Quit.   The "Q" command quits the program.   The program will ask you to confirm this choice by typing "Y".   If a transcript file is open, it will automatically be closed  at this point.  3 R Restore a matrix or tableau from a file.   The "R" command replaces the current matrix by the last matrix  that was saved with the "S" command, or entered with the "E"  command.  The current matrix or tableau is replaced by one stored earlier  with the "S" command, or the last matrix or tableau you entered  using the "E" or "X" command, whichever was most recent.  3 RAT Use rational arithmetic  This command tells the program to begin working in rational   arithmetic.  The current matrix, if any, will be converted to  rational format. 3 REAL Use real arithmetic  This command tells the program to begin working in real   arithmetic.  The current matrix, if any, will be converted to  real form. 3 S Store the matrix or tableau in a file.   The "S" command saves a copy of the current matrix.  Whenever you define a matrix or tableau using the "E" command, or  read one in with the "X" command, a copy of the matrix is  automatically saved in memory.   After you've done some work on a problem, you may want to store  a copy before proceeding.   Only one matrix or tableau may be stored at any time, and storing  a new one destroys any old information.   The matrix or tableau is only stored in memory, so when you quit  the program, this information is lost.   See the "W" command for a more permanent storage method.  3 T Type out the matrix or tableau.   The "T" command allows you to examine the matrix or tableau.   In linear algebra mode, this command will also print out the   determinant of the product of the ERO matrices. 3 TR Transpose the matrix   The "TR" command will "flip" the matrix, essentially replacing A(I,J)  by A(J,I).   If the matrix is currently the following 2 by 3:    1  2  3    4  5  6  then the "TR" command will replace it by the 3 by 2 matrix:    1 4    2 5    3 6  If you, for example, desperately want to use elementary column  operations rather than row operations, you can flip your matrix,  apply row operations to it and then flip it back.   This is equivalent to the column operations you would have used.   Because MATMAN allows matrices to have significantly more columns  than rows, it is possible for a matrix to have too many columns  for you to be allowed to transpose it.   In such a case, MATMAN will simply refuse to do so. 3 U Undo the last operation.   The "U" command will allow you to recover from a  command you regret giving, or gave by mistake.   The matrix will be restored to its form as it was just before   your previous command.   This only works one time;  you cannot backtrack using several  consecutive "U" commands.  3 W Write example to file   The "W" command allows you to specify the name of a file, such as  "Matman.Dat" or "B:DATA" and a label, such as "EXAMPLE 1".   The current matrix or tableau will then be stored in the file.   You can store several problems in the same file, and retrieve  any of them later with the "X" command.  3 X Read example from file   The "X" command allows you to specify the name of a file, such as  "MATMAN.DAT", which presumably was created during a previous run  of MATMAN with the "W" command.   The file should contain the definitions of one or more problems.   MATMAN then searches through that file, and lists the labels of  all the problems stored there.   You will be asked to pick one problem to read into the program  from the file.   Possibly, the example will require that the linear programming  mode or the arithmetic mode be changed.   If so, this will be done automatically, and MATMAN will warn you  that this is being done.   The file "MATMAN.DAT" comes with some examples in it already.  3 Y Turn Autoprint Off or On  When MATMAN commands change the matrix or tableau,  the program automatically prints out the current matrix,   so that these changes can be inspected.  This is called "autoprinting".  If you find the autoprinting featuring unnecessary, you can  turn it off by using the "Y" command.  A second "Y" command  restores it.3 Z Automatic operation   The "Z" command will automatically row reduce the active matrix  using partial pivoting.   Because MATMAN is a teaching program, use of the "Z" command  should be discouraged until the students have had adequate  opportunity to carry out reductions by hand.   Use of the "Z" command requires a password which is available  from the instructor.   Other users who want the convenience of the "Z" command are  welcome to contact the authors.   This command will not work if the password file "MATKEY.DAT" is  missing, or is not in the proper place, or is not set up to allow  MATMAN to read it.   Teachers who adopt this text will be given instructions for  changing the password. 3 # Comments   MATMAN assumes that what you type is a command.  But you may  also wish to simply write a comment or two, to annotate your  work, especially if you are making a file transcript.   You can do this easily by simply beginning a comment line  with a pound sign.  For instance, I could give MATMAN the  following input:     #    #  I'm going to enter my matrix.    #    e 2,2    1,7    5,12    #    #  And now, I want to eliminate entry (2,1).    #    r2 <= r2 -5 r1  3 $ Turn paging OFF   MATMAN will normally pause if it has printed 24 lines of text  without any input from you.  This is so that you won't miss  anything printed on a computer screen, which often can only  display 24 lines.   You may not want MATMAN to do this.  One very good reason  would be if you are going to try to run MATMAN  non-interactively, with an input file you prepare beforehand.   In that case, it's hard enough to type all of the commands  you should give, in the proper order, without having to  worry about when MATMAN will be wanting you to simply  hit RETURN to go on to the next 24 lines.   Simply typing "$" will turn this feature off.  3 % Turn paging ON   If paging was turned OFF with the "$" command, then MATMAN prints  the entire output from each command without pausing every 24 lines.    To turn paging back on, simply type "%".  3 ? Extensive help from the help file.   Sometimes the short one line help offered by the "H" command may  not be clear enough.   In those cases, using the "?" command will allow you, while  running the program, to browse through this help file in search  of information.   This command will not work if MATMAN cannot find and open the  help file, named "matman.hlp".   The rules for where the file "matman.hlp" should be, and how  its access rights should be set, vary depending on the operating  system and machine used.  3 < Get input from a file.   Although MATMAN is designed for interactive use, you can  prepare your commands beforehand in a file, named, for instance,  "matman.inp" and have MATMAN process them.   On a computer running UNIX or DOS, this would be easily done  via the command:     matman < matman.inp   However, it's not easy to do on VMS or on a Macintosh.  Your  alternative is to begin the program interactively, and then  tell the program to get the rest of its input from the file.   If the file does not end with commands that cause MATMAN to  quit, then MATMAN will return control to you and you are free to  type more commands or stop the program.   If "paging" is on when you specify an input file, MATMAN will  automatically turn it off.   If any error occurs while the input file is read, MATMAN will  close the input file, and expect further input from you.    NOTE: Because of a programming bug, if you use the "X" command  inside of an input file, once the example is read, MATMAN  will expect further input from you, and not from the file. 2 Linear Programming Commands   The list of commands available in linear programming mode follows.  Only commands unique to linear programming mode will be explained  here.   This list can be displayed at any time by issuing the "HELP" command.   Many commands are only legal if a tableau has been set up.   The "H" command will only display those commands that are  currently available, and hence that list will change during the  course of the computation.   The list printed here includes ALL possible commands.   In the following list, S, I and J stand for numbers you must  include in the command.   S is typically a multiplier, in real or fractional format,  I and J are usually row or column identifiers.      A    Add S times row I to row J.    B    Set up sample problem.    C    Change entry I,J to S (J=0 for basic variables).    D    Divide row I by S.    DEC  Use decimal arithmetic.    E    Enter a problem with I constraints and J variables.    F    Change to real, fraction, or decimal arithmetic.    HELP Display full help.    I    Interchange rows I and J.    K    Open/close transcript file.    L    Leave linear programming mode.    M    Multiply row I by S.    N    Set number of decimal digits.    O    Check tableau for optimality.    P    Carry out one pivoting step.    Q    Quit.    R    Restore the tableau.    RAT  Use rational arithmetic.    REAL Use real arithmetic.    S    Store the tableau.    T    Type out the matrix or tableau.    TS   Type out the current linear programming solution    U    Undo last operation.    V    Eliminate artificial variables.    W    Write the tableau to file.    X    Read a tableau from file.    Z    Automatic simplex method solution.    $    turn paging OFF.    %    turn paging ON.    #    begins a comment.    ?    Extensive help from the help file.    >    Get input from a file.   If a command has several arguments, you may list them on the same  line as the command letter, or not.   If you do not list all needed arguments, the program will prompt  you for them.  3 A Add S times row I to row J.   The "A" command will add S times row I to row J.   Legal commands to add 2.5 times row 2 to row 6 include     A 2.5, 2, 6  or    A 5/2, 2, 6  or the ERO form:    r6 <= r6 + 5/2 r2  3 B Set up sample problem.   The "B" command sets up a sample problem.   The sample problem will overwrite any previous problem you may  have been working on.   You have the choice of:     a simple problem, with no artificial variables,   or     a more complex problem that requires artificial variables.  3 C Change entry I, J to S.   The "C" command changes the entry in row I, column J, to S.   In either arithmetic, the command to change entry 1,3 to 3.5  could be shortened to     C 1,3, 3.5  or    C 1,3, 7/2  or    C 1,3, 7.0/2.0   This command is useful in correcting errors made in data entry as  well as handling perturbations of the original problem.  3 BASIC Assign row I to basic variable J   The "BASIC" command allows you to set or change the list of basic   variables.   The ONLY reason to do this is if you enter your matrix in linear  algebra mode, and then switch to linear programming mode and want  to keep your matrix.   In linear programming mode, each row of the tableau is associated  (or labeled) with a variable, and for our purposes, these labels  may be thought of as making up column 0.   That's where they appear when the tableau is printed out.   If you issue the command     BASIC 2, 3   for example, the program will change the label of (or basic  variable associated with) row 2 to 3. 3 D Divide row I by S.   The "D" command divides row I by the number S.   Commands to divide row 1 by -4 include     D 1, -4   or the ERO form:    r1 <= r1 / -4   It might be surprising to see that MATMAN includes both a "D"   and an "M" command.  Why have both, when dividing by 3 is the   same as multiplying by 1/3?     Mathematically, it is true that dividing by 3 is the same as   multiplying by 1/3, but this is not necessarily true on a   computer.  A computer can represent 3 exactly, but 1/3 cannot be  represented exactly in "floating point" arithmetic, what MATMAN   calls "real" arithmetic.  Therefore, if we're using real arithmetic, and we want to modify  a row so an entry that is now 3 becomes 1 instead, we have two  choices:  The "D" command can be used to divide by 3, which is guaranteed  to produce a result which is exactly 1.  The "M" command can be used to multiply by 1/3, which may give  a result of 1, or perhaps a result something like 0.9999...   That's why the "D" command is useful.  3 DEC Use decimal arithmetic  This command tells the program to begin working in decimal   arithmetic.  You will be asked how many decimal places you  want to use, and the current matrix, if any, will be converted  to decimal format. 3 E Enter problem with I constraints and J variables   The "E" command means you want to set up a problem with I  constraints and J variables.   I is simply the number of inequalities/equalities which the  variables must satisfy.   The program then asks you to enter each constraint.   You must do this in a somewhat unusual form;  you must first  enter the 'sign' of the constraint, followed by the coefficients  and right hand side.   For example, if the constraint     9*X1 + 2*X2 < 7   would be entered as     '< 9, 2, 7'   while the constraint     3*X1 + 5*X2 - 7*X3 = 8   would be entered as     '= 3, 5, -7, 8'.   If there are variables whose coefficients are zero, then those  zeroes MUST be entered as well.  For instance, the constraint     X1 + X3 < 2   would be entered as     < 1, 0, 1, 2   This assumes we are using three variables.  If instead we were  using four variables, then the coefficient of X4 is also zero,  and we would enter the constraint as:     < 1, 0, 1, 0, 2   Finally, the objective function coefficients and constant term  should be entered.   Each time you enter a tableau, a copy is automatically stored.   This means that, unless you store another tableau in the mean  time, you can recover your original tableau with the "R"  command if you regret the changes you have made to it.   The program stores only one tableau.   If additional storage is required, use the "W" command.  3 F Change to fractional, real, or decimal arithmetic.   The "F" command chooses the arithmetic form.  For example,    F R  changes to real arithmetic.  The choices are:    F for fractional arithmetic;    R for real arithmetic;    D for decimal arithmetic.   If a matrix has already been entered, it will be converted to   the new arithmetic form.  If decimal arithmetic is chosen, you may also want to issue  the "N" command, to specify the number of decimal places to use.  You may find it easier to use the "DECIMAL", "RATIONAL", or "REAL"  commands. 3 G Add a constraint and slack variable to tableau   (THIS COMMAND IS NOT WORKING YET!)   The "G" command allows you to add a new constraint to the tableau.  The constraint will inserted into the tableau as the last  constraint.   A corresponding slack variable will automatically be added as  well.  3 H Display quick help   The "H" command prints one line explanations of the most  useful linear algebra commands.3 HELP Display full help  The "HELP" command prints out every available command,  with a one line explanation.  If you need more help than that, use the "?" command. 3 I Interchange rows I and J.   The "I" command interchanges rows I and J in the matrix.   Commands to switch rows 1 and 2 include     I 2, 1   and the ERO form:    r1 <=> r2  In linear programming mode, you are NOT allowed to switch the  last row to any other position, because of its special function  as the objective row.  3 K Open/close transcript file   The "K" command opens a file into which is put an exact copy of  everything you or the program types.   This is useful when doing homework, or for checking your work.   A second "K" command will close the file.   The program will ask you to give the file a name such as  "MATMAN.LPT".   On most computers, this will cause the file to be created in  the same directory where you were working when you started  running MATMAN.   Depending on the operating system, you may be able to specify  an alternate location for the file, by specifying directory  information in the name, such as     "B:\MY_PC\MATMAN.LPT"  or    "/usr/users/fred/homework.txt"  or    "Mac disk:problems:transcript.doc"   On a DOS PC, you can generate a hardcopy, as the  file is being constructed, by pressing the "CTL" and  "PRINT SCREEN" keys together.   Once constructed, the file can be edited using any available  editor or word processor.   On a Macintosh computer, you should be able to examine or print  the transcript file with any editor program.  3 L Leave linear programming mode.   The "L" command moves the program to linear algebra mode.  Any linear programming work done will be discarded.  3 M Multiply row I by S.   The "M" command multiplies row I by the number S.   Commands to multiply row 1 by -4 include     M 1, -4   and the ERO form:    r1 <= -4 r13 N Set number of decimal digits.  The "N" command sets the number of decimal digits used.    This command is only useful if you have chosen decimal arithmetic  with the "DECIMAL" command.  The default number of digits, called "NDIG", is 6.  This means that  decimal quantities will have at most 6 digits.   If NDIG is 6,  the value of 8/3, for instance, will be stored as exactly  2.33333.  Using the "N" command, you can change the number of digits  to any value between 1 and 7.  Using a small value of NDIG  can make the effects of roundoff show up very quickly.   3 O Optimality check.   The "O" command checks the current solution for optimality.   If the solution is optimal, then the objective function has  reached its maximum possible value.  3 P Pivot, entering variable I, departing variable J.   The "P" command carries out one step of the pivoting operation.  You will be shown the objective row, and asked to pick a proper  entering variable, I.   Then you will be shown the feasibility ratios, and asked to pick  a proper departing variable, J.   If the program accepts your choices, the pivoting operation will  be carried out.   If you have made improper choices, the program will ask you to  try again. 3 Q Quit.   The "Q" command quits the program.   The program will ask you to confirm this choice by typing "Y".   If a transcript file is open, it will automatically be closed  at this point.   Control is returned to the computer operating system.  3 R Restore a matrix or tableau from a file.   The "R" command replaces the current matrix by the last matrix  that was saved with the "S" command, or entered with the "E"  command.  The current matrix or tableau is replaced by one stored earlier  with the "S" command, or the last matrix or tableau you entered  using the "E" or "X" command, whichever was most recent.  3 RAT Use rational arithmetic  This command tells the program to begin working in rational   arithmetic.  The current matrix will be converted to rational  form. 3 REAL Use real arithmetic  This command tells the program to begin working in real   arithmetic.  The current matrix will be converted to real form. 3 S Store the matrix or tableau in a file.   The "S" command saves a copy of the current matrix.  Whenever a matrix or tableau is defined using the "E" command, or  read in with the "X" command, a copy of the matrix is automatically   saved in memory.   After you've done some work on a problem, you may want to store  a copy before proceeding.   Only one matrix or tableau may be stored at any time, and storing  a new one destroys any old information.   The matrix or tableau is only stored in memory, so when the  program is terminated, this information is lost.   See the "W" command for a more permanent storage method.  3 T Type out the matrix or tableau.   The "T" command prints out the current matrix or tableau.   In linear algebra mode, this command will also print out the   determinant of the product of the ERO matrices. 3 TS Type out the linear programming solution  The "TS" command causes the program to compute the current  linear programming solution and print it out.3 U Undo the last operation.   The "U" command will allow you to recover from a  command you regret giving, or gave by mistake.   The matrix will be restored to its form as it was just before   your previous command.   This only works one time;  you cannot backtrack using several  consecutive "U" commands.  3 V Remove artificial variables.   The "V" command removes the columns of the tableau corresponding  to artificial variables.   This command is only appropriate after the simplex method has   been applied to the auxiliary problem of the two phase method.  3 W Write example to file   The "W" command allows you to specify the name of a file, such as  "Matman.Dat" or "B:DATA" and a label, such as "EXAMPLE 1".   The current matrix or tableau will then be stored in the file.   You can store several problems in the same file, and retrieve  any of them later with the "X" command.  3 X Read example from file   The "X" command allows you to specify the name of a file, such as  "MATMAN.DAT", which presumably was created during a previous run  of MATMAN with the "W" command.   The file should contain the definitions of one or more problems.   MATMAN then searches through that file, and lists the labels of  all the problems stored there.   You will be asked to pick one problem to read into the program  from the file.   Possibly, the example will require that the linear programming  mode or the arithmetic mode be changed.   If so, this will be done automatically, and MATMAN will warn you  that this is being done.   The file "MATMAN.DAT" comes with some examples in it already.  3 Y Turn Autoprint Off or On  After many MATMAN commands, the matrix or tableau has been  changed.  In such cases, the program will automatically print  out the matrix, so that you can see how your change was   carried out.  This is called "autoprinting".  Of course, you can always request a printout anytime by using  the "T" command.  If you find the autoprinting featuring unnecessary, you can  turn it off by using the "Y" command.  A second "Y" command  restores it.3 Z Automatic operation   The "Z" command will automatically carry out the simplex method,  even with artificial variables, though in that case it will pause  and request that you type the "V" command to flush out the  artificial variables at the proper time.   Because MATMAN is a teaching program, use of the "Z" command  should be discouraged until the students have had adequate  opportunity to carry out reductions by hand.   Use of the "Z" command requires a password which is available  from the instructor.   Other users who want the convenience of the "Z" command are  welcome to contact the authors.   This command will not work if the password file "MATKEY.DAT" is  missing, or is not in the proper place, or is not set up to allow  MATMAN to read it.   Teachers who adopt this text will be given instructions for  changing the password. 3 # Comments   MATMAN assumes that what you type is a command.  But you may  also wish to simply write a comment or two, to annotate your  work, especially if you are making a file transcript.   You can do this easily by simply beginning a comment line  with a pound sign.  For instance, I could give MATMAN the  following input:     #    #  I'm going to enter my matrix.    #    e 2,2    1,7    5,12    #    #  And now, I want to eliminate entry (2,1).    #    r2 <= r2 -5 r1  3 $ Turn paging OFF   MATMAN will normally pause if it has printed 24 lines of text  without any input from you.  This is so that you won't miss  anything printed on a computer screen, which often can only  display 24 lines.   You may not want MATMAN to do this.  One very good reason  would be if you are going to try to run MATMAN  non-interactively, with an input file you prepare beforehand.   In that case, it's hard enough to type all of the commands  you should give, in the proper order, without having to  worry about when MATMAN will be wanting you to simply  hit RETURN to go on to the next 24 lines.   Simply typing "$" will turn this feature off.  3 % Turn paging ON   If paging was turned OFF with the "$" command, then MATMAN prints  the entire output from each command without pausing every 24 lines.    To turn paging back on, simply type "%".  3 ? Extensive help from the help file.   Sometimes the short one line help offered by the "H" command may  not be clear enough.   In those cases, using the "?" command will allow you, while  running the program, to browse through this help file in search  of information.   This command will not work if MATMAN cannot find and open the  help file, named "matman.hlp".   The rules for where the file "matman.hlp" should be, and how  its access rights should be set, vary depending on the operating  system and machine used.  3 < Get input from a file.   Although MATMAN is designed for interactive use, you can  prepare your commands beforehand in a file, named, for instance,  "matman.inp" and have MATMAN process them.   On a computer running UNIX or DOS, this would be easily done  via the command:     matman < matman.inp   However, it's not easy to do on VMS or on a Macintosh.  Your  alternative is to begin the program interactively, and then  tell the program to get the rest of its input from the file.   If the file does not end with commands that cause MATMAN to  quit, then MATMAN will return control to you and you are free to  type more commands or stop the program.   If "paging" is on when you specify an input file, MATMAN will  automatically turn it off.   If any error occurs while the input file is read, MATMAN will  close the input file, and expect further input from you.    NOTE: Because of a programming bug, if you use the "X" command  inside of an input file, once the example is read, MATMAN  will expect further input from you, and not from the file. 2 Arithmetic forms   MATMAN can carry out its calculations using fractions, real   numbers, or decimals.   The advantage of the fractional form of arithmetic is that all  calculations are exact.  However, this representation has a  more limited range than real arithmetic, and simple computations  can produce results that cannot be represented, causing overflow   or underflow.   The advantage of real arithmetic is that a very wide  range of numbers can be represented.  However, the accuracy of  the representation is limited.  Also, almost every calculation  with real number will involve some round off, which means that  every result you compute is inaccurate.    The advantage of the decimal form of arithmetic is that it  "looks" like real arithmetic, that is, results are printed  out in a decimal format, but it has some of the exactness  properties of fractional arithmetic.  In particular, if you  see the value 0.33 printed out, then that is the exact   value being represented, and 3 times 0.33 will be exactly 0.99.  This is often not true with real values.  On the other hand,  computations with decimal numbers will have the same sort  of inaccuracies that real numbers suffer.    No matter what arithmetic form you have currently chosen,  you can enter input in any reasonable format you like.  In other words, you can enter the value 1/2 as any of the   following representations:     0.5, 1/2, 1.0/2.0, 5/10, 8/16, 5E-1.   MATMAN will automatically convert your input into the proper form.   Particularly if you are using real arithmetic, the value MATMAN   stores will often not be exactly the value you typed, because the   arithmetic you are using will not be able to store that exact   value.  Thus, in real arithmetic, 2/3 becomes something like   0.666667, and (3/2) * 0.666667 is NOT equal to 1!    To multiply row 2 by 1/3, you may type:     M 2, .33333  or    M 2, 1/3  or    M 2, 1.0/3.0   In fractional arithmetic, the first command would multiply by   33333/100000, not by 1/3.  2 Elementary Row Operations  The main purpose of MATMAN is to teach the use of elementary  row operations or ERO's.    There are three elementary row operations:    I: Interchange two rows of the matrix.    M: Multiply a row by a nonzero value.    A: Add a multiple of one row to another row.  Each of the elementary row operations corresponds to   the premultiplication of the matrix by what is called  an "elementary matrix".  The "I" operation may be written symbolically as    R1 <=> R2  The "M" operation as:    R1 <= S R1  and the "A" operation as"    R1 <= R1 + S R2  Here "R1" and "R2" are two distinct rows, and "S" is any nonzero  number.  One way to describing an ERO to MATMAN is to use a format  similar to the above.  For instance, the following are valid:    r3 <=> r5    r2 <= 3/2 r2    r4 <= r4 - 2 r1  MATMAN also has a set of commands that begin with an identifying  letter.  The three commands above could also be entered as:    i 3,5    m 2, 3/2    a -2,1 4  Using elementary row operations, any matrix can be transformed  into row echelon form.    Moreover, elementary row operations can be used to find a matrix's  rank, inverse, and determinant, and to solve linear systems.3 Solving a linear system   To solve a linear system A*X=Y using elementary row operations,  we build a new matrix, called the augmented matrix, which we will  denote by [A|Y].   This is the original matrix A, with one extra column consisting  of the right hand side Y.   If we reduce this augmented matrix to reduced row echelon form,  then, assuming we do not end up with a row of zeroes in the A  part of the matrix, a solution X will be in the Y position.   In any case the reduced matrix [B|K] is the augmented matrix of  a system B*X = K which is easy to solve and which has the same  solutions as A*X = Y.  3 Inverting a Matrix   The inverse of a square matrix A is a matrix B such that     A*B = B*A = I   where I is the identity matrix.   Systems of linear equations can be symbolically written as A*X=Y,  where A is the matrix of coefficients, X is the set of unknowns,  and Y is the right hand side.   If the inverse matrix of A is known, then the system may be  solved by multiplying both sides by the inverse:     B*A*X=B*Y   but     B*A=I   so     X=B*Y.   This is not a very efficient way to solve linear systems, but  there are other reasons for wanting to find the inverse of a  matrix.   To compute the inverse of a matrix using elementary row  operations, we use the method described above to solve the  equation A*X = I.   Note that in this case, we have not just one right hand side, but  N of them.   Each column of the identity matrix is to be thought of as a  separate right hand side, which we have joined together.   In this case the augmented matrix is [A|I].   We then carry out elementary row operations to reduce A to row  reduced echelon form.   Assuming that A is nonsingular, which in this case will mean that  the reduced matrix A has no zero rows, then A will be reduced to  the identity.   In this case the final matrix is [I|B] where B is the inverse of  A.   For example, we might set up an augmented problem like this:     ( 5  7  6  5   1  0  0  0)    ( 7 10  8  7   0  1  0  0) = [A|I]    ( 6  8 10  9   0  0  1  0)    ( 5  7  9 10   0  0  0  1)   and after carrying out the row reduction, we would end up with:     ( 1  0  0  0   68 -41 -17  10)    ( 0  1  0  0  -41  25  10  -6) = [I|B]    ( 0  0  1  0  -17  10   5  -3)    ( 0  0  0  1   10  -6  -3   2)  3 Computing the Determinant  To compute the determinant of a matrix, we will use several facts:    A) If P, A and R are square matrices, and P*A=R, then       det(P)*det(A)=det(R).    B) The determinant of a matrix in row echelon form is either 1       (because ALL the diagonal entries are 1) or 0 (because at least       one diagonal entry is 0).    C) Every elementary row operation is equivalent to premultiplying       by an elementary matrix.      D) An elementary matrix never has a zero determinant.  Now suppose our matrix is A, and we apply ONE elementary row   operation E to it, and suppose the resulting matrix R is in   row echelon form.  If the determinant of R is 0, then we know that     det(E)*det(A) = det(R) = 0  but det(E) can't be zero because E is an elementary matrix, so  det(A) is zero.    If the determinant of R is 1, then we know that    det(E)*det(A) = det(R) = 1  so det(A) = 1/det(E).  If we have to apply several operations to our matrix, say, E1, E2,  E3, then we know:    det(E3)*det(E2)*det(E1)*det(A) = det(R)  so either det(R)=0 and det(A)=0 or    det(A) = 1 / (det(E3)*det(E2)*det(E1)).  Thus, all we need to know now is the determinants of each kind   of elementary matrix:    ERO                Matrix           Determinant    ---                ------           -----------    R1 <=> R2          I(R1,R2)         -1    R1 <= S R1         M(R1,S)           S    R1 <= R1 + S R2    A(S,R2,R1)        1  Thus, for instance, let us reduce the following matrix A:    A = (4 5)        (3 2)  Step 1: divide row 1 by 4, using M(1,1/4), determinant 1/4.      Result = (1 5/4)             (3  2 )  Step 2: add -3 times row 1 to row 2, determinant 1.    Result = (1  5/4)             (0 -7/4)  Step 3: multiply row 3 by -4/7, using M(2,-4/7), determinant -4/7.    Result = (1 5/4)             (0  1 )  The matrix A has now been transformed to row echelon form,   with determinant 1.  The determinant of the original matrix A is therefore:    det(A) = 1 /( (1/4) * 1 * (-4/7) ) = 1 /(-1/7) = -7.  The EDET command prints out the determinant of the matrix "E"  which is the product of all the elementary row matrices that  were applied to A.  Thus, in this case, EDET would return -1/7,  and we would know that the determinant of A is -7.2 Elementary Matrices  Each elementary row operation applied to a matrix A can be  considered to be the result of premultiplying A by an "elementary  matrix".    There are three elementary row operations, which we can  symbolize by "I", "M" and "A", and there are three corresponding  types of elementary matrices.  Consider the matrix I(1,2) which switches rows 1 and 2 of a   3 by 3 matrix:             (0 1 0)    I(1,2) = (1 0 0)             (0 0 1)  If we work with the matrix         (1 2 3)    A = (4 5 6)        (7 8 9)  Then                 (4 5 6)    I(1,2) * A = (1 2 3)                 (7 8 9)  Similarly, the matrix M(2,4) multiplies row 2 by 4:             (1 0 0)    M(2,4) = (0 4 0)             (0 0 1)  So that                 ( 1  2  3)    M(2,4) * A = (16 20 24)                 ( 7  8  9)  Finally, the matrix A(-7,1,3) adds -7 times row 1 to row 3:                ( 1  0  0)    A(-7,1,3) = ( 0  1  0)                (-7  0  1)  so that                    (1  2   3)    A(-7,1,3) * A = (4  5   6)                    (0 -6 -12)2 Row Echelon Form   A matrix (square or rectangular) is in "row echelon form" if:     1) The first nonzero entry in every row (if any) is a 1.     2) The first 1 in a given row occurs in a column to the right       of the first 1 in the previous row.     3) Rows that are completely zero occur last.   Any matrix can be transformed into row echelon form using a  series of elementary row operations.   For example, the matrix    (1 2 3)    (0 1 6)    (0 0 0)  is in row echelon form.  A matrix is in "reduced row echelon form" if it is also true that:     4) The first 1 in a row has no other nonzero entries in its column.   For example, the matrix    (1 0 3)    (0 1 6)    (0 0 0)  is in reduced row echelon form. 2 Jacobi Iteration   The Jacobi iteration for an eigenproblem is an iterative method  for finding the eigenvalues and eigenvectors of a symmetric  matrix A.   The process involves the computation of a sequence of orthogonal  similarity transformations Q1, Q2, ... which transform the  original matrix A to matrices A1, A2, ... each of which has the  same eigenvalues of A, but each of which is "more" diagonal than  A was.   That is, given A, we find a matrix Q1, and compute A1 as:     A1 = TRANSPOSE(Q1)*A*Q1   and then find a matrix Q2, and compute A2 as:     A2 = TRANSPOSE(Q2)*A1*Q2   and so on.   The matrices Q1, Q2 and so on are determined by a very simple  process.   Q1 is chosen in such a way as to zero out the (1,2) and (2,1)  elements of A.   That is, the (1,2) and (2,1) elements of A1 will be zero.   Q2 will eliminate the (1,3) and (3,1) elements of A1.   Thus A2 will have zeroes in the (1,3) and (3,1) positions.   Unfortunately, the (1,2) and (2,1) positions of A2 will not be  zero!   However, we can sweep through the entire matrix, zeroing out each  off-diagonal element in succession, and starting over when we  reach the last one.   It can be shown that the sum of the squares of the off diagonal  elements decreases to zero with the iteration.   Thus, for some iteration step M, one can expect to have a matrix  AM and a matrix Q = Q1*Q2*...*QM so that     AM = TRANSPOSE(Q) * A * Q   where AM is "essentially" diagonal.   At that point, we can rewrite this equation as     A * Q = LAMBDA * Q   where LAMBDA is the diagonal entries of AM, and LAMBDA is the  eigenvalues of A,  and the transformation matrix Q is the matrix  of eigenvectors of A.   Now the only detail not addressed is the construction of the  individual matrices Q1, Q2 and so on.   How do we make an orthogonal matrix so that the similarity  transform zeroes out a particular pair of entries?   The formula is fairly simple.   Let's assume we want to zero out the entries A(I,J) and A(J,I),  for example.   Then the matrix Q is equal to the identity matrix, except that:     Q(I,I) =  C   Q(I,J) = S    Q(J,I) = -S   Q(J,J) = C   where C=COSINE(THETA) and S=SINE(THETA) are the cosine and sine  of some angle THETA.   A matrix constructed in this way is called a "Givens rotation"  matrix.   We can compute C and S directly (skipping the computation of  THETA) by the following formula:     U = ( A(J,J)-A(I,I) ) / ( 2*A(I,J) )    T = SIGN(U) / (ABS(U) + SQRT(U*U+1))     C = 1/(SQRT(T*T+1)    S = T/(SQRT(T*T+1)   Using this formula, an orthogonal matrix Q can be found so  that     TRANPOSE(Q) * A * Q   has zero (I,J) and (J,I) entries for any given matrix A.   Variations of the Jacobi iteration might choose to try to  zero out the largest off-diagonal element at each step, rather  than simply going down each column in order.  2 Simplex method   The simplest linear programming problem can be phrased as follows:   Find N nonnegative numbers X1, X2, ..., XN, for which the  objective function     Z = A(1)*X1 + A(2)*X2 + ... + A(N)*XN + A(N+1)   attains its maximum possible value, subject to the following  constraints:     B(1,1)*X1 + B(1,2)*X2 + ... + B(1,N)*XN < C(1)    B(2,1)*X1 + B(2,2)*X2 + ... + B(2,N)*XN < C(2)    .........   .........   ...   .........   ....    B(N,1)*X1 + B(2,N)*X2 + ... + B(N,N)*XN < C(N)   (Assume that by '<' we mean less than or equal to, and that '>'  means greater than or equal to.    The simplex method of solving a linear programming problem  involves producing a series of solutions, each of which  satisfies the constraints, but each of which is better than  the previous one.   The first step of the method requires picking an initial solution  which satisfies the constraints, which is called the initial  basic feasible solution.   This solution is mechanically constructed, by setting all the  variables to zero except a few, which also are chosen in a  mechanical way.   The variables which are allowed to take nonzero values are called  basic variables, and the solution method will consist of a series  of steps, each of which involves removing one variable from the  list of basic variables (setting it to zero) and adding a new  variable to the list (allowing it to have a nonzero value).   The simplex method guides us in our choice, so that we can expect  that each step of our search will increase the value of the  objective function.   An important part of the method involves recognizing when we can  go no further, that is, when the solution is the best we can do,  and we have found the maximum possible value of the objective  function, given the constraints.   On the other hand, it is also possible for there to be no  solution for a given problem, and the simplex method includes  some checks to guard against this possibility.    It is easier to solve equations than inequalities,  so for each  constraint I, we add a 'slack' variable, X(N+I), to make the  inequality an equality.   The original variables, X1 through XN, will be called the  "nonslack variables".   For our example problem, we would add two slack variables, and our  inequalities would now become:   2 X1 + 2 X2 + X3      = 8  5 X1 + 3 X2      + X4 = 15   For problems in standard form, it is easy to construct an initial  basic solution:  set all the nonslack variables to zero, and set  the slack variable in equation I to the value of the right hand  side.   Thus, initially, our basic variables are X3 and X4, and our  solution is X1=0, X2=0, X3=8, X4=15.   As we said above, our solution at any step will only have some  variables nonzero, called the basic variables.   The remaining variables, which are required to be zero for the  moment, are called the nonbasic variables.   Both slack and nonslack variables may be used to determine the  current solution, so any variable may be slack/nonslack and  basic/nonbasic.   At the beginning of the method, the slack variables are the  basic variables, each one having the value of the right hand side  of its inequality.   Each step of the simplex method will consist of a method of  choosing a variable to add to the set of basic variables, and  choosing another variable to drop from the set.   These are the 'entering' and 'departing' variables for that step.   If the departing variable is a slack variable, this means that  its corresponding inequality will be satisfied exactly.  3 Pivoting step   To simplify the discussion, we now describe the format of the  matrix or 'tableau' which will keep track of our operations.   Let's first suppose that we began with M inequalities and N  variables.   Our tableau will have M+1 rows and N+M+2 columns.   Each column is labeled with its number: column 1 with label '1',  and so on, although the last two rows will be labeled 'P' and  'C'.   These labels will never vary.   The rows will also be labeled.   But initially, each row will be labeled with the number of its  slack variable.   And on each pivot step, one row label will change.   The row labels are keeping track of the current set of basic  variables, whose values may be found in column C.   The numbers in the tableau are determined initially as follows:     The first M rows and N columns are to contain the coefficients    of the constraints.     Column M+N+2 ('C') contains the right hand sides of the    constraints.     Columns N+1 through N+M will contain the identity matrix or    that portion that fits.     Column N+M+1 ('P') will contain 0 in rows 1 through M.   Finally, row M+1 will contain     minus the coefficients of the objective function in columns    1 through N,     0 in columns N+1 through N+M,     1 in column N+M+1, and     the constant term of the objective function in column N+M+2.   For our example problem, the tableau would look like this:            1     2    3    4    P    C      +-------------------------------    3 !    2     2    1    0    0    8   (  2 X1 +   2 X2 <  8)    4 !    5     3    0    1    0   15   (  5 X1 +   3 X2 < 15)    O ! -120  -100    0    0    1   70   (120 X1 + 100 X2 + 70)   Now that we have the tableau, we can begin the algorithm.   Each step involves picking an 'entering' and a 'departing'  variable.   The entering variable is to be chosen by picking the variable  corresponding to the label of the column for which the objective  entry in row M+1 is the most negative.   If there is a tie, just choose the first one.   Let's suppose this column number is J.   Now select the departing variable by computing, for each row I  for which T(I,J) > 0, the feasibility ratio T(I,N+M+2) / T(I,J).   Choose the variable which labels the row for which the minimum  feasibility ratio is found.   That is the departing variable, where in case of a tie we choose  the first one.   For our example, the most negative objective entry is -120, which  occurs in the column labeled '1' so X1 is going to be our  entering variable.   The feasibility ratios are:     T(1,6)/T(1,1) =   8/2 =  4    T(2,6)/T(2,1) =  15/5 =  3   and the minimum is 3 which occurs in the row which is labeled 4,  so variable 4 is our departing variable.   Now we must modify the tableau to account for these changes.   Let's assume that the departing variable corresponds to row K.   We now do the elementary row operations necessary to reduce  column J of the tableau to column K of the identity matrix.   Thus we divide the K-th row by T(K,J), making T(K,J) equal to 1.   Now we modify each row I by multiplying row K by -T(I,J) and  adding that to row I.   This makes column J all zero except for the entry in row K.   We also modify row M+1 in the same way.   Finally, we change the label for row K so that it is labeled by  the entering variable J.   This procedure can be carried out using the "P" (Pivot) command  or by using the "A" and "M"  commands.   For the example, the tableau is transformed as follows:     Entering variable is X1.    Departing variable X3 corresponds to row 2.     We have J=1, K=2.     We want to reduce column 1 of the tableau to column 2 of the    identity.     We must divide row 2 by T(2,1)=5.     We must then add -5 times row 1 to row 2, which zeroes out the    entry T(2,1).     Then we add -120 times row 1 to row 3.     Then we label row 1 '1'.              1     2     3     4    P     C       +-----------------------------------    3  !     0    4/5    1   -2/5   0     2    1  !     1    3/5    0    1/5   0     3    O  !     0   -28     0    24    1   430   What has now changed?   The basic variables are now X1 and X3, whose values can be read  in the last column.   The current solution can be written (3,0,8,0).   The objective function has changed from 70 to 430.   The objective function increase in this step, as desired.   The process is repeated as long as there are negative entries in  the objective row.   When there are no longer any negative entries, the optimal  solution has been found.   The row labels record the basic variables, and their values will  be found in the last column.   The nonbasic variables are all zero.   The optimal value of the objective function is the last entry in  the last row.   For this example, there is only one more step of the method:     Entering variable is 2.     Departing variable is 3.     Multiply row 1 by 5/4,     Add -3/5 times row 1 to row 2,     Add 28 times row 1 to row 3,     Relabel the first row '2':            1     2     3     4    P     C     +-----------------------------------  2  !     0     1    5/4  -1/2   0   5/2  1  !     1     0   -3/4   1/2   0   3/2  O  !     0     0    35    10    1   500   and so our final solution is (3/2, 5/2, 0, 0) with objective  value 500.  3 Two phase method   For cases where some of the constraints are "=" or ">"  constraints, the two phase method must be used.   The first phase of such a problem involves adding artificial  variables and an artificial objective function.   Then the simplex method is applied to find the solution of the  auxiliary problem which will serve as a basic feasible solution  of the given problem.   After phase I is completed, the artificial variables are removed  and the original objective function is introduced.   Now we apply the simplex method to obtain the optimal solution of  the original  problem.   The first phase was necessary because the basic solution  associated with X1=X2=...=XN=0 was not feasible.   The first phase of the algorithm simply produces an acceptable  starting solution for the second phase.   The artificial variables to be added to the first phase problem  are determined entirely by the constraints which are > or =.   For each > inequality, the coefficient of the slack variable for  that row is  -1, and an artificial variable with a +1 coefficient  is added.   Thus,     X1 + 2*X2 > 6   might become     X1 + 2*X2 - X3 + X7 = 6   where X3 is a (negative) slack variable and X7 is artificial.   For an = constraint, no slack variable is generated for the  equation, but an artificial variable is generated.   Thus     X1 + 2*X2 = 6   would become     X1 + 2*X2 + X8 = 6   where X8 is artificial.   Finally, the artificial objective function is generated.   It is the sum of the artificial variables.   If this problem is solved with the simplex method, and none of  the final basic variables are artificial, then they have values  satisfying the original constraints.   Once the artificial variables are deleted, the second phase begins.  2 Sample problems   Built-in examples can be accessed via the "B" command.   Linear algebra examples:     Determinant:  use ERO's on an N by N matrix.    Solve:        use ERO's on an N by N+1 matrix.    Inverse:      use ERO's on an N by 2*N matrix.    Eigenvalue:   use Jacobi rotation on an N by N symmetric matrix.    Linear programming examples are:     Standard: All constraints are less-or-equal inequalities.    Advanced: Two constraints are greater-or-equal inequalities.  3 Determinant example  This example shows how the determinant of a matrix can be computed  via elementary row operations.  You may choose the number of rows NROW in the example matrix.  You should then apply a sequence of elementary row operations to  the matrix, so that it is transformed into row echelon form.  If the diagonal of the row echelon form matrix is all 1's,  then the determinant of the matrix is the inverse of the determinant  of the ERO matrices that were applied to it.  If the diagonal of the row echelon form matrix has any zero  entries, then the determinant of the matrix is zero.3 Solve example  This example shows how a system of linear equations can be  solved using elementary row operations.  You may choose the number of rows NROW in the example matrix.  The matrix will have one extra column, in which the right hand  side "b" of the linear system "A * x = b" has been placed.  Using elementary row operations, the first NROW columns of the   matrix can be transformed into the identity matrix, unless  the matrix is singular.  At that point, the solution "b" to the linear system will be in  the final column of the transformed matrix. 3 Inverse example   Elementary row operations can find the inverse of a matrix.   You may choose the number of rows NROW in the example matrix.    The program sets up the NROW by NROW matrix, and automatically   appends a copy of the identity matrix.  Using elementary row operations, the first NROW columns of the   matrix can be transformed into the identity matrix.   By doing so, the trailing half of the matrix will have been  transformed into the inverse of the original matrix.  3 Eigenvalue example   This example may only be used when real arithmetic has been  chosen, and the program is not in linear programming mode.   Once the example has been set up, the "J" command can be used to  apply Jacobi transformations to the matrix.   These transformations can gradually change a symmetric matrix  to one that is nearly diagonal.   When the matrix is nearly diagonal, the diagonal entries  should be close to the eigenvalues of the original matrix.   The example matrix is     5 4 1 1    4 5 1 1    1 1 4 2    1 1 2 4   The eigenvalues of this matrix are 10, 5, 2, and 1.   Repeated application of the "J" command should result in a  matrix that is "almost" diagonal, and which has diagonal  entries close the the eigenvalues of the matrix.  3 Standard linear programming example   The following is a sample linear programming problem:   Find nonnegative X1 and X2 for which the function     Z = 120*X1 + 100*X2 + 70.0   attains its maximum value, subject to the conditions     2*X1 + 2*X2 < 8,    5*X1 + 3*X2 < 15.   The solution of this problem is     X1 = 1.5,    X2 = 2.5,    Z  = 430.  3 Advanced linear programming example   Often a linear programming problem cannot be described in  standard form.   In particular, some of the constraints might be ">", or "="  constraints, rather than "<".   Such problems can be solved using the two phase method.   An example of a problem in nonstandard form is:    "Find nonnegative X1 and X2 for which Z = 40*X1 + 30*X2    attains its maximum value, subject to these constraints"       X1 + 2*X2 > 6    2*X1 +   X2 > 4      X1 +   X2 < 5    2*X1 +   X2 < 8   The first step of the two phase method for solving this  nonstandard problem is to add "artificial variables" to the  problem, as well as a new objective function.   The new problem looks like this:    "Find nonnegative X1 through X8 for which Z = - X7 - X8    attains its maximum value, subject to these constraints:"       X1 + 2*X2 - X3                    +   X7        = 6    2*X1 +   X2      - X4                      +   X8 = 4      X1 +   X2           +   X5                      = 5      X1 +   X2                  +   X6               = 8   The added variables X3, X4, X5, and X6 are called slack variables,  while X7 and X8 are called artificial variables.   The artificial variables X7 and X8 were added to take care of the   fact that the first two inequalities have the wrong direction in  the original problem.   The solution to this first problem is     (2/3, 8/3, 0, 0, 5/3, 4, 0, 0),   and the (temporary) objective function has the value 0.   When the artificial variables are eliminated from this problem,  to carry out the second phase, the solution is     (3, 2, 1, 4, 0, 0)   with the objective function having a value of 180.  2 DOS PC version   The PC version of MATMAN should run properly on a PC that  uses Microsoft DOS, Windows 3.1 or Windows 95, although in all   cases, MATMAN will actually be running under DOS.  To run MATMAN on a DOS PC under DOS, insert the MATMAN disk  in the computer's floppy drive.  Then change your working  directory to that same drive, which you might do by typing    A:  Then, to begin execution of the program, type     MATMAN   If MATMAN will be used regularly on the PC, it may be best to  make a directory on the hard disk, and copy at least the  following four files from the floppy:     MATMAN.EXE    MATMAN.HLP    MATMAN.DAT    MATKEY.DAT   These files are enough to run MATMAN directly on the hard drive.   If the program seems to be in an infinite loop, or needs to  be terminated immediately, typing CTRL-C should kill it.   If your computer is running Microsoft Windows 3.0 or 3.1, then  you have the choice of getting to a DOS prompt while still  running Windows, by clicking on one of the "MS-DOS prompt" icons,  or you can simply shut down Windows.  If your computer is running Microsoft Windows 95, then you should  click on the "START" icon on the Toolbar, go the the "PROGRAMS"  item on the menu, slide over to the right and choose "MS-DOS Prompt".  Once you have gotten from Windows to a DOS prompt, you simply  repeat the instructions given earlier for computers running DOS  directly. 3 Redirecting input and output on the PC   Although the program is designed for interactive use, you may  prepare a set of input commands, store them in a file, and "feed"  them to the program using the standard DOS redirection symbol  "<".  If the input file were called "MYWORDS", then the execution  statement would be:     MATMAN < MYWORDS   Similarly, although MATMAN has a built in capability of saving  in a file a copy of everything that appeared on the screen, you  may instead choose to use the DOS redirection symbol ">" to  store the output in a file.  In this case, you will surely  also want to have prepared the input in advance, since you  will see no prompts on the screen, so the execution command  might look like:     MATMAN < MYWORDS > OUTPUT   If you are going to "feed" an input file to MATMAN, you should  turn off paging by issuing the "$" command as the first command  in the file.  Normally, MATMAN will pause after 24 lines of  output, and ask you to hit RETURN before it will proceed.  Typing  "$" tells MATMAN not to do that.  If you leave MATMAN in "paging"  mode, then it will be almost impossible to properly set up an  input file, since you will have to anticipate where to insert  extra blank lines that signify hitting RETURN.  3 Compilation details on the PC   The program was compiled on a Gateway 2000 PC, using Microsoft  FORTRAN version 5.1, and running Windows 3.1.   The source code file was broken up into several separate files to  make it possible to compile.  The files were given names  like "MATMAN1.FOR", because the Microsoft FORTRAN compiler  requires the "FOR" extension.   The compilation statements had the form:     FL /FPi /c MATMAN1.FOR   The compilation switch "/FPi" was used, so that the program  would run correctly whether or not a machine had an 8087  math coprocessor chip.  If the machine has a math coprocessor  chip, the program will exploit it.   The LINK statement, which created the executable, was     LINK MATMAN1+MATMAN2+MATMAN3+MATMAN4+MATMAN5+MATMAN6+MATMAN7   The library used was LLIBFOR7.LIB.2 Windows PC version  If you have the Windows version of MATMAN, it cannot be run on  a PC that is only running DOS.  If the MATMAN executable program is on a floppy disk in the A:  drive, then to run it, you should select the START icon on the  Windows Toolbar, slide up to the "RUN" item and click.  When you get a blank command line to fill in, type    A:MATMAN_W.EXE  Because this is a Windows version of the program, it executes in  its own window, which can be moved or resized.  You can also easily  cut and paste, and do other operations that cannot be done with a  DOS application.2 Macintosh version   To use MATMAN on a Macintosh, you may copy the files      MATMAN_68K or MATMAN_PPC    MATMAN.HLP    MATMAN.DAT    MATKEY.DAT   from the floppy disk into a folder on your hard disk,   or use the files directly from the floppy disk.    In either case, you should open the folder or disk containing  the files, and click twice on the MATMAN_68K or MATMAN_PPC file.    This should open up a command window where you can type your   input, and where MATMAN will print its responses.    You can cut and paste from the command window.  Once you  have stopped the MATMAN program with the "Q" command, you  can save the entire command window to a file by going to the  "FILE" menu and choosing "SAVE AS".  Otherwise, you can  close the command window by clicking once in the small box in  the extreme upper left corner of the window.   If the program seems to be in an infinite loop, or needs to  be terminated immediately, hold down COMMAND-Period, that is,  hold down the COMMAND key (the one with the cloverleaf on it)  and press the period key.  3 Compilation details on the Macintosh   The 68K version of MATMAN was compiled on an Apple Macintosh II   computer, running System 7.5, using Absoft Mac FORTRAN II   version 3.4.   The PowerPC version of MATMAN was compiled on an Apple PowerPC,  running System 7.5, using Absoft FORTRAN version 4.1.  The latest versions of the Absoft compiler have several useful features:  * The "-N9" compiler option, which causes the the program to check    every half-second to see whether the COMMAND-period keys have    been pushed, signaling that the user wishes to abort the program.  * The "-N13" compiler option, which corrects a problem in which    the program was running out of stack memory, resulting in    no output appearing on the screen.  * The "-mrwe" switch, which causes the program output to appear    in a more manageable window, with user control over the fonts    and font sizes.  * The ability to cut and paste inside the command window.2 UNIX version of MATMAN   Educators who want a UNIX version of MATMAN for noncommercial  use will be given a copy of the source code to install.     On UNIX, if you're working in the same directory in which the  executable program is stored, the program can be run simply by  typing:     matman   However, if the executable program is in another directory, you   may need to specify the full directory name to run the program,  as in:     /usr/users/burkardt/bin/matman   Sophisticated users will know how to place MATMAN in their  UNIX PATH, so that it can be run by invoking its name, no  matter where the user is currently working.  If MATMAN has been installed by an instructor for use by students  from other accounts, then the instruct must "unprotect" the  executable program, the help file, the data file and the MATMAN  password file, so that UNIX will allow the students to access them.   The commands, which should be issued in the directory where MATMAN  is installed, would be something like this:     chmod +x matman    chmod +r matman.hlp    chmod +r matman.dat    chmod +r matkey.dat   If you are installing MATMAN in this way, for access by users  from other accounts, you should also modify the source code so  that MATMAN knows where the data files are.   The lines to be replaced currently read:     filhlp='matman.hlp'    filkey='matkey.dat'    fildef='matman.dat'   and might be changed, for instance, to read     filhlp='/usr/burkardt/matman.hlp'    filkey='/usr/burkardt/matkey.dat'    fildef='/usr/burkardt/matman.dat'   If the program seems to be in an infinite loop, or needs to  be terminated immediately, typing CTRL-C should kill it.  3 Compilation details on UNIX   MATMAN has been compiled and run on the following UNIX machines:     a DEC ALPHA AXP running OSF/1,    a Silicon Graphics IRIS workstation running IRIX,    a SUN SparcStation running SOLARIS.   For the IRIS, the command to compile and link was:     f77 matman.f    mv a.out matman   For the ALPHA and SUN, the command to compile and link was:     f77 -fast matman.f    mv a.out matman  3 Redirecting input and output on UNIX   Although MATMAN is designed for interactive use, you  may prepare a set of input commands, store them in a  file, and "feed" them to the program using the standard UNIX  redirection symbol "<".    If the input file were called "mywords", then the execution   statement would be:     matman < mywords   Similarly, although MATMAN has a built-in capability of saving  in a file a copy of everything that appeared on the screen, you  may instead choose to use the UNIX redirection symbol ">" to  store the output in a file.    In this case, you will surely also want to have prepared the   input in advance, since you will see no prompts on the screen,   so the execution command might look like:     matman < mywords > output   If you are going to "feed" an input file to MATMAN, you should  turn off paging by issuing the "$" command as the first command  in the file.    Normally, MATMAN will pause after 24 lines of output, and ask you  to hit RETURN before it will proceed.  Typing "$" tells MATMAN not   to do that.    If you leave MATMAN in "paging" mode, then it will be almost   impossible to properly set up an input file, since you will have   to anticipate where to insert extra blank lines that signify   hitting RETURN.  2 VMS version   Anyone who wants a VMS version of MATMAN will be given a  copy of the source code to install.    On VMS, if you're working in the same directory in which the  executable program is stored, the program can be run simply  by typing:     RUN MATMAN   On VMS, it is also possible for a single copy of MATMAN to  be installed by an instructor, and then used by students from  other accounts.   In that case, the instructor must "unprotect" the executable  program, the help file and the data file, so that VMS will allow  the students to access them.   The commands required would be something like this:     SET PROTECT=(W:RE) MATMAN.EXE    SET PROTECT=(W:R)  MATMAN.HLP    SET PROTECT=(W:R)  MATMAN.DAT    SET PROTECT=(W:R)  MATKEY.DAT   Then the instructor must tell the students the location of the  directory where the files are kept, which might be     USR$ROOT:[INSTRUCTOR.PROGRAMS]   The students can then run the program by typing a command like     RUN USR$ROOT:[INSTRUCTOR.PROGRAMS]MATMAN   If you are installing MATMAN in this way, for access by users  from other accounts, you should also modify the source code so  that the program knows where the data files are.   The lines to be replaced currently read:     filhlp='matman.hlp'    filkey='matkey.dat'    fildef='matman.dat'   and might be changed, for instance, to read     filhlp='USR$ROOT:[INSTRUCTOR.PROGRAMS]MATMAN.HLP'    filkey='USR$ROOT:[INSTRUCTOR.PROGRAMS]MATKEY.DAT'    fildef='USR$ROOT:[INSTRUCTOR.PROGRAMS]MATMAN.DAT'   Also, there are three OPEN statements in the program, which  need to be modified if other users are going to access the files.   These places are marked in the program.  The original OPEN  statements need to be changed to include the two VMS specific  keywords:    SHARED, READONLY   This allows more than one user to open the file at any time,  but only to read them, not to modify them.   Also, the routine TRANSC should be modified.  Two of the OPEN  statements should have the words     FORM='UNFORMATTED', CARRIAGECONTROL='LIST'  inserted, so that the transcript file will print out properly,  rather than seeming to have lost column 1.  If the program seems to be in an infinite loop, or needs to  be terminated immediately, typing CTRL-Y should kill it.  3 Compilation details on VMS   This program was compiled on a VAX/VMS system using the DEC  FORTRAN compiler.  The commands used to compile and load the  program were:     FORTRAN/NOLIST MATMAN.FOR    LINK/NOMAP MATMAN.OBJ  3 Redirecting input and output on VMS   Although the program is designed for interactive use, you  may prepare a set of input commands, store them in a  file, and "feed" them to the program using the VMS ASSIGN  command to tell the program where to look.  If the input file  were called  "MYWORDS.DAT", then the execution statements would  be:     ASSIGN/USER MYWORDS.DAT SYS$INPUT    RUN MATMAN   Similarly, although MATMAN has a built in capability of saving  in a file a copy of everything that appeared on the screen, you  may instead choose to use the ASSIGN command to store the output  in a file.  In this case, you will surely also want to have  prepared the input in advance, since you will see no prompts on  the screen, so the execution command might look like:     ASSIGN/USER MYWORDS.DAT SYS$INPUT    ASSIGN/USER OUTPUT.DAT SYS$OUTPUT    RUN MATMAN   If you are going to "feed" an input file to MATMAN, you should  turn off paging by issuing the "$" command as the first command  in the file.  Normally, MATMAN will pause after 24 lines of  output, and ask you to hit RETURN before it will proceed.  Typing  "$" tells MATMAN not to do that.  If you leave MATMAN in "paging"  mode, then it will be almost impossible to properly set up an  input file, since you will have to anticipate where to insert  extra blank lines that signify hitting RETURN.  2 DOUBLE PRECISION version   In FORTRAN, it is possible to request that all real  calculations be carried out with greater than usual precision.   Normally, if a variable is declared to be "REAL", then the  value of the variable is stored using one word of  computer memory, equivalent to 32 bits, or 4 bytes.  Roughly  speaking, this allows computations with this variable to be  accurate to about 7 or 8 decimal places.   If, instead of being declared "REAL", the variable is declared  "DOUBLE PRECISION", then two words are used to store the value  of the variable, and computations involving the variable will  generally be accurate to about 14 to 16 decimal places.   The greater accuracy does have two costs: the program will take  up more memory, and real computations will take longer.   MATMAN is written to use the normal, "REAL" arithmetic form  for real calculations.  However, it is a very simple matter  to convert MATMAN to double precision.  Using any text editor  you like, simply replace MOST occurrences of the string "real"  by the string "double precision" and recompile the code.   Note that using double precision will NOT improve the performance  of the fraction and decimal arithmetic options in MATMAN.  2 64 bit integer version  The fraction and decimal arithmetic modes used in MATMAN assume   that an integer is stored in 32 bits, and that the maximum legal   integer, called MAXINT by the program, is 2**(31)-1, or   2,147,483,647.   If you convert to a double precision version of MATMAN, that only  improves the accuracy of "real" representations and computations.   Fraction and decimal representations and computations will not   change.  However, if your machine uses 64 bits for integers, then you can   get MATMAN to take advantage of this fact, and improve the range   and accuracy of fraction and decimal representations.  To do this, you must change the value of MAXDIG in the program   from 7 to 14, which allows decimal fractions to go as high as 14   digits, and you need to replace all the assignments of MAXINT,   replacing the current value by the value of the largest 64 bit   integer, which should be 2**(63)-1, which is equal to  9,223,372,036,854,775,807. 